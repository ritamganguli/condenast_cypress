#!/usr/bin/env node
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/tsup/assets/esm_shims.js
import { fileURLToPath } from "url";
import path from "path";
var init_esm_shims = __esm({
  "../../node_modules/tsup/assets/esm_shims.js"() {
  }
});

// bin/lib/@commander-js/extra-typings/index.js
var require_extra_typings = __commonJS({
  "bin/lib/@commander-js/extra-typings/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var commander = __require("commander");
    exports = module.exports = {};
    exports.program = new commander.Command();
    exports.Argument = commander.Argument;
    exports.Command = commander.Command;
    exports.CommanderError = commander.CommanderError;
    exports.Help = commander.Help;
    exports.InvalidArgumentError = commander.InvalidArgumentError;
    exports.InvalidOptionArgumentError = commander.InvalidArgumentError;
    exports.Option = commander.Option;
    exports.createCommand = (name) => new commander.Command(name);
    exports.createOption = (flags, description) => new commander.Option(flags, description);
    exports.createArgument = (name, description) => new commander.Argument(name, description);
  }
});

// bin/cli.ts
init_esm_shims();
import "source-map-support/register";

// lib/errors.ts
init_esm_shims();
var ValidationError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "";
  }
};

// lib/log.ts
init_esm_shims();
import chalk from "chalk";
import util from "util";
var log = (...args) => console.log(util.format(...args));
var info = log;
var withError = (msg) => chalk.bgRed.white(" ERROR ") + " " + msg;
var withWarning = (msg) => chalk.bgYellow.black(" WARNING ") + " " + msg;
var warn = (...args) => log(withWarning(util.format(...args)));
var error = (...args) => log(withError(util.format(...args)) + "\n");
var title = (color, ...args) => info("\n  " + chalk[color].bold(util.format(...args)) + "  \n");
var divider = () => console.log("\n" + chalk.gray(Array(100).fill("=").join("")) + "\n");
var spacer = (n = 0) => console.log(Array(n).fill("").join("\n"));
var cyan = chalk.cyan;
var blue = chalk.blueBright;
var red = chalk.red;
var green = chalk.greenBright;
var gray = chalk.gray;
var white = chalk.white;
var magenta = chalk.magenta;
var bold = chalk.bold;

// lib/run.ts
init_esm_shims();

// lib/init.ts
init_esm_shims();

// lib/require.ts
init_esm_shims();
import { createRequire } from "module";
var require2 = createRequire(import.meta.url);

// lib/stdout.ts
init_esm_shims();
import cp from "child_process";
var orginal = cp.spawn;
cp.spawn = function(command, args, options) {
  if (command.match(/Cypress/)) {
    const process2 = orginal(command, args, {
      ...options,
      // using pipe enables capturing stdout and stderr
      stdio: ["pipe", "pipe", "pipe"]
    });
    return process2;
  }
  return orginal(command, args, options);
};

// lib/ws.ts
init_esm_shims();

// lib/capture.ts
init_esm_shims();
import Debug from "debug";
var debug = Debug("currents:capture");
var _write = process.stdout.write;
var _log = process.log;
var restore = function() {
  process.stdout.write = _write;
  process.log = _log;
};
var stdout = function() {
  debug("capturing stdout");
  let logs = [];
  const { write } = process.stdout;
  const { log: log2 } = process;
  if (log2) {
    process.log = function(str) {
      logs.push(str);
      return log2.apply(this, arguments);
    };
  }
  process.stdout.write = function(str) {
    logs.push(str);
    return write.apply(this, arguments);
  };
  return {
    toString() {
      return logs.join("");
    },
    data: logs,
    restore,
    reset: () => {
      debug("resetting captured stdout");
      logs = [];
    }
  };
};
var initialOutput = "";
var capturedOutput = null;
var initCapture = () => capturedOutput = stdout();
var cutInitialOutput = () => {
  if (!capturedOutput)
    throw new Error("capturedOutput is null");
  initialOutput = capturedOutput.toString();
  capturedOutput.reset();
};
var resetCapture = () => {
  if (!capturedOutput)
    throw new Error("capturedOutput is null");
  capturedOutput.reset();
};
var getCapturedOutput = () => {
  if (!capturedOutput)
    throw new Error("capturedOutput is null");
  return capturedOutput.toString();
};
var getInitialOutput = () => initialOutput;

// lib/httpClient/index.ts
init_esm_shims();

// lib/httpClient/config.ts
init_esm_shims();
import { isAxiosError } from "axios";
var isRetriableError = (err) => {
  if (!isAxiosError(err)) {
    return false;
  }
  if (err.code === "ECONNREFUSED") {
    return true;
  }
  return !!(err?.response?.status && 500 <= err.response.status && err.response.status < 600);
};
var getDelay = (i) => [15 * 1e3, 30 * 1e3, 60 * 1e3][i - 1];
var baseURL = "https://cy.currents.dev";
var getAPIBaseUrl = () => baseURL ?? "https://cy.currents.dev";
var setAPIBaseUrl = (url) => baseURL = url ?? "https://cy.currents.dev";

// lib/httpClient/httpClient.ts
init_esm_shims();
import axios from "axios";
import axiosRetry from "axios-retry";
import Debug2 from "debug";
import _2 from "lodash";
import prettyMilliseconds from "pretty-ms";

// lib/httpClient/printErrors.ts
init_esm_shims();
import _ from "lodash";
function maybePrintErrors(err) {
  if (!err.response?.data || !err.response?.status) {
    return;
  }
  const { message, errors } = err.response.data;
  switch (err.response.status) {
    case 401:
      warn("Received 401 Unauthorized");
      break;
    case 422:
      spacer(1);
      warn(...formatGenericError(message, errors));
      spacer(1);
      break;
    default:
      break;
  }
}
function formatGenericError(message, errors) {
  if (!_.isString(message)) {
    return ["Unexpected error from the cloud service"];
  }
  if (errors?.length === 0) {
    return [message];
  }
  return [
    message,
    `
${(errors ?? []).map((e) => `  - ${e}`).join("\n")}
`
  ];
}

// lib/httpClient/httpClient.ts
var debug2 = Debug2("currents:api");
var MAX_RETRIES = 3;
var _client = null;
function getClient() {
  if (_client) {
    return _client;
  }
  _client = axios.create({
    baseURL: getAPIBaseUrl()
  });
  _client.interceptors.request.use((config) => {
    const headers = {
      ...config.headers,
      // @ts-ignore
      "x-cypress-request-attempt": config["axios-retry"]?.retryCount ?? 0,
      "x-cypress-version": _cypressVersion ?? "0.0.0",
      "x-ccy-version": _currentsVersion ?? "0.0.0"
    };
    if (_runId) {
      headers["x-cypress-run-id"] = _runId;
    }
    if (!headers["Content-Type"]) {
      headers["Content-Type"] = "application/json";
    }
    const req = {
      ...config,
      headers
    };
    debug2("network request: %o", {
      ..._2.pick(req, "method", "url", "headers"),
      data: Buffer.isBuffer(req.data) ? "buffer" : req.data
    });
    return req;
  });
  axiosRetry(_client, {
    retries: MAX_RETRIES,
    retryCondition: isRetriableError,
    retryDelay: getDelay,
    // @ts-ignore
    onRetry
  });
  return _client;
}
var _runId = void 0;
var setRunId = (runId) => {
  _runId = runId;
};
var _cypressVersion = void 0;
var setCypressVersion = (cypressVersion) => {
  _cypressVersion = cypressVersion;
};
var _currentsVersion = void 0;
var setCurrentsVersion = (v) => {
  _currentsVersion = v;
};
function onRetry(retryCount, err, _config2) {
  warn(
    "Network request failed: '%s'. Next attempt is in %s (%d/%d).",
    err.message,
    prettyMilliseconds(getDelay(retryCount)),
    retryCount,
    MAX_RETRIES
  );
}
var makeRequest = (config) => {
  return getClient()(config).then((res) => {
    debug2("network response: %o", _2.omit(res, "request", "config"));
    return res;
  }).catch((error2) => {
    maybePrintErrors(error2);
    throw new ValidationError(error2.message);
  });
};

// lib/init.ts
var cypressPkg = require2("cypress/package.json");
var pkg = require2("cypress-cloud/package.json");
initCapture();
setCypressVersion(cypressPkg.version);
setCurrentsVersion(pkg.version);

// lib/run.ts
import Debug16 from "debug";

// lib/api/index.ts
init_esm_shims();

// lib/api/api.ts
init_esm_shims();

// lib/api/warnings.ts
init_esm_shims();
import _3 from "lodash";
function printWarnings(warnings) {
  warn("Notice from cloud service:");
  warnings.map((w) => {
    spacer(1);
    info(magenta.bold(w.message));
    Object.entries(_3.omit(w, "message")).map(([key, value]) => {
      info("- %s: %s", key, value);
    });
    spacer(1);
  });
}

// lib/api/api.ts
var createRun = async (payload) => {
  const response = await makeRequest({
    method: "POST",
    url: "/runs",
    data: payload
  });
  if ((response.data.warnings?.length ?? 0) > 0) {
    printWarnings(response.data.warnings);
  }
  return response.data;
};
var createInstance = async ({
  runId,
  groupId,
  machineId,
  platform: platform2
}) => {
  const response = await makeRequest({
    method: "POST",
    url: `runs/${runId}/instances`,
    data: {
      runId,
      groupId,
      machineId,
      platform: platform2
    }
  });
  return response.data;
};
var createBatchedInstances = async (data) => {
  const respone = await makeRequest({
    method: "POST",
    url: `runs/${data.runId}/cy/instances`,
    data
  });
  return respone.data;
};
var setInstanceTests = (instanceId, payload) => makeRequest({
  method: "POST",
  url: `instances/${instanceId}/tests`,
  data: payload
}).then((result) => result.data);
var updateInstanceResults = (instanceId, payload) => makeRequest({
  method: "POST",
  url: `instances/${instanceId}/results`,
  data: payload
}).then((result) => result.data);
var reportInstanceResultsMerged = (instanceId, payload) => makeRequest({
  method: "POST",
  url: `instances/${instanceId}/cy/results`,
  data: payload
}).then((result) => result.data);
var updateInstanceStdout = (instanceId, stdout2) => makeRequest({
  method: "PUT",
  url: `instances/${instanceId}/stdout`,
  data: {
    stdout: stdout2
  }
});

// lib/api/types/index.ts
init_esm_shims();

// lib/api/types/instance.ts
init_esm_shims();

// lib/api/types/run.ts
init_esm_shims();

// lib/api/types/test.ts
init_esm_shims();

// lib/ciProvider.ts
init_esm_shims();
import debugFn from "debug";
import _4 from "lodash";
var debug3 = debugFn("currents:ci");
var join = (char, ...pieces) => {
  return _4.chain(pieces).compact().join(char).value();
};
var toCamelObject = (obj, key) => {
  return _4.set(obj, _4.camelCase(key), process.env[key]);
};
var extract = (envKeys) => {
  return _4.transform(envKeys, toCamelObject, {});
};
var isTeamFoundation = () => {
  return process.env.TF_BUILD && process.env.TF_BUILD_BUILDNUMBER;
};
var isAzureCi = () => {
  return process.env.TF_BUILD && process.env.AZURE_HTTP_USER_AGENT;
};
var isAWSCodeBuild = () => {
  return _4.some(process.env, (val, key) => {
    return /^CODEBUILD_/.test(key);
  });
};
var isBamboo = () => {
  return process.env.bamboo_buildNumber;
};
var isCodeshipBasic = () => {
  return process.env.CI_NAME && process.env.CI_NAME === "codeship" && process.env.CODESHIP;
};
var isCodeshipPro = () => {
  return process.env.CI_NAME && process.env.CI_NAME === "codeship" && !process.env.CODESHIP;
};
var isConcourse = () => {
  return _4.some(process.env, (val, key) => {
    return /^CONCOURSE_/.test(key);
  });
};
var isGitlab = () => {
  return process.env.GITLAB_CI || process.env.CI_SERVER_NAME && /^GitLab/.test(process.env.CI_SERVER_NAME);
};
var isGoogleCloud = () => {
  return process.env.GCP_PROJECT || process.env.GCLOUD_PROJECT || process.env.GOOGLE_CLOUD_PROJECT;
};
var isJenkins = () => {
  return process.env.JENKINS_URL || process.env.JENKINS_HOME || process.env.JENKINS_VERSION || process.env.HUDSON_URL || process.env.HUDSON_HOME;
};
var isWercker = () => {
  return process.env.WERCKER || process.env.WERCKER_MAIN_PIPELINE_STARTED;
};
var CI_PROVIDERS = {
  appveyor: "APPVEYOR",
  azure: isAzureCi,
  awsCodeBuild: isAWSCodeBuild,
  bamboo: isBamboo,
  bitbucket: "BITBUCKET_BUILD_NUMBER",
  buildkite: "BUILDKITE",
  circle: "CIRCLECI",
  codeshipBasic: isCodeshipBasic,
  codeshipPro: isCodeshipPro,
  concourse: isConcourse,
  codeFresh: "CF_BUILD_ID",
  drone: "DRONE",
  githubActions: "GITHUB_ACTIONS",
  gitlab: isGitlab,
  goCD: "GO_JOB_NAME",
  googleCloud: isGoogleCloud,
  jenkins: isJenkins,
  semaphore: "SEMAPHORE",
  shippable: "SHIPPABLE",
  teamcity: "TEAMCITY_VERSION",
  teamfoundation: isTeamFoundation,
  travis: "TRAVIS",
  wercker: isWercker,
  netlify: "NETLIFY",
  layerci: "LAYERCI"
};
function _detectProviderName() {
  const { env } = process;
  return _4.findKey(CI_PROVIDERS, (value) => {
    if (_4.isString(value)) {
      return env[value];
    }
    if (_4.isFunction(value)) {
      return value();
    }
  });
}
var _providerCiParams = () => {
  return {
    appveyor: extract([
      "APPVEYOR_JOB_ID",
      "APPVEYOR_ACCOUNT_NAME",
      "APPVEYOR_PROJECT_SLUG",
      "APPVEYOR_BUILD_NUMBER",
      "APPVEYOR_BUILD_VERSION",
      "APPVEYOR_PULL_REQUEST_NUMBER",
      "APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH"
    ]),
    azure: extract([
      "BUILD_BUILDID",
      "BUILD_BUILDNUMBER",
      "BUILD_CONTAINERID",
      "BUILD_REPOSITORY_URI"
    ]),
    awsCodeBuild: extract([
      "CODEBUILD_BUILD_ID",
      "CODEBUILD_BUILD_NUMBER",
      "CODEBUILD_RESOLVED_SOURCE_VERSION",
      "CODEBUILD_SOURCE_REPO_URL",
      "CODEBUILD_SOURCE_VERSION"
    ]),
    bamboo: extract([
      "bamboo_buildNumber",
      "bamboo_buildResultsUrl",
      "bamboo_planRepository_repositoryUrl",
      "bamboo_buildKey"
    ]),
    bitbucket: extract([
      "BITBUCKET_REPO_SLUG",
      "BITBUCKET_REPO_OWNER",
      "BITBUCKET_BUILD_NUMBER",
      "BITBUCKET_PARALLEL_STEP",
      "BITBUCKET_STEP_RUN_NUMBER",
      // the PR variables are only set on pull request builds
      "BITBUCKET_PR_ID",
      "BITBUCKET_PR_DESTINATION_BRANCH",
      "BITBUCKET_PR_DESTINATION_COMMIT"
    ]),
    buildkite: extract([
      "BUILDKITE_REPO",
      "BUILDKITE_SOURCE",
      "BUILDKITE_JOB_ID",
      "BUILDKITE_BUILD_ID",
      "BUILDKITE_BUILD_URL",
      "BUILDKITE_BUILD_NUMBER",
      "BUILDKITE_PULL_REQUEST",
      "BUILDKITE_PULL_REQUEST_REPO",
      "BUILDKITE_PULL_REQUEST_BASE_BRANCH"
    ]),
    circle: extract([
      "CIRCLE_JOB",
      "CIRCLE_BUILD_NUM",
      "CIRCLE_BUILD_URL",
      "CIRCLE_PR_NUMBER",
      "CIRCLE_PR_REPONAME",
      "CIRCLE_PR_USERNAME",
      "CIRCLE_COMPARE_URL",
      "CIRCLE_WORKFLOW_ID",
      "CIRCLE_PULL_REQUEST",
      "CIRCLE_REPOSITORY_URL",
      "CI_PULL_REQUEST"
    ]),
    codeshipBasic: extract([
      "CI_BUILD_ID",
      "CI_REPO_NAME",
      "CI_BUILD_URL",
      "CI_PROJECT_ID",
      "CI_BUILD_NUMBER",
      "CI_PULL_REQUEST"
    ]),
    // CodeshipPro provides very few CI variables
    // https://documentation.codeship.com/pro/builds-and-configuration/environment-variables/
    codeshipPro: extract(["CI_BUILD_ID", "CI_REPO_NAME", "CI_PROJECT_ID"]),
    // https://concourse-ci.org/implementing-resource-types.html#resource-metadata
    concourse: extract([
      "BUILD_ID",
      "BUILD_NAME",
      "BUILD_JOB_NAME",
      "BUILD_PIPELINE_NAME",
      "BUILD_TEAM_NAME",
      "ATC_EXTERNAL_URL"
    ]),
    // https://codefresh.io/docs/docs/codefresh-yaml/variables/
    codeFresh: extract([
      "CF_BUILD_ID",
      "CF_BUILD_URL",
      "CF_CURRENT_ATTEMPT",
      "CF_STEP_NAME",
      "CF_PIPELINE_NAME",
      "CF_PIPELINE_TRIGGER_ID",
      // variables added for pull requests
      "CF_PULL_REQUEST_ID",
      "CF_PULL_REQUEST_IS_FORK",
      "CF_PULL_REQUEST_NUMBER",
      "CF_PULL_REQUEST_TARGET"
    ]),
    drone: extract([
      "DRONE_JOB_NUMBER",
      "DRONE_BUILD_LINK",
      "DRONE_BUILD_NUMBER",
      "DRONE_PULL_REQUEST"
    ]),
    // https://help.github.com/en/actions/automating-your-workflow-with-github-actions/using-environment-variables#default-environment-variables
    githubActions: extract([
      "GITHUB_WORKFLOW",
      "GITHUB_ACTION",
      "GITHUB_EVENT_NAME",
      "GITHUB_RUN_ID",
      "GITHUB_RUN_ATTEMPT",
      "GITHUB_REPOSITORY"
    ]),
    // see https://docs.gitlab.com/ee/ci/variables/
    gitlab: extract([
      // pipeline is common among all jobs
      "CI_PIPELINE_ID",
      "CI_PIPELINE_URL",
      // individual jobs
      "CI_BUILD_ID",
      // build id and job id are aliases
      "CI_JOB_ID",
      "CI_JOB_URL",
      "CI_JOB_NAME",
      // other information
      "GITLAB_HOST",
      "CI_PROJECT_ID",
      "CI_PROJECT_URL",
      "CI_REPOSITORY_URL",
      "CI_ENVIRONMENT_URL",
      "CI_DEFAULT_BRANCH"
      // for PRs: https://gitlab.com/gitlab-org/gitlab-ce/issues/23902
    ]),
    // https://docs.gocd.org/current/faq/dev_use_current_revision_in_build.html#standard-gocd-environment-variables
    goCD: extract([
      "GO_SERVER_URL",
      "GO_ENVIRONMENT_NAME",
      "GO_PIPELINE_NAME",
      "GO_PIPELINE_COUNTER",
      "GO_PIPELINE_LABEL",
      "GO_STAGE_NAME",
      "GO_STAGE_COUNTER",
      "GO_JOB_NAME",
      "GO_TRIGGER_USER",
      "GO_REVISION",
      "GO_TO_REVISION",
      "GO_FROM_REVISION",
      "GO_MATERIAL_HAS_CHANGED"
    ]),
    googleCloud: extract([
      // individual jobs
      "BUILD_ID",
      "PROJECT_ID",
      // other information
      "REPO_NAME",
      "BRANCH_NAME",
      "TAG_NAME",
      "COMMIT_SHA",
      "SHORT_SHA"
      // https://cloud.google.com/cloud-build/docs/api/reference/rest/Shared.Types/Build
    ]),
    jenkins: extract(["BUILD_ID", "BUILD_URL", "BUILD_NUMBER", "ghprbPullId"]),
    // https://semaphoreci.com/docs/available-environment-variables.html
    // some come from v1, some from v2 of semaphore
    semaphore: extract([
      "SEMAPHORE_BRANCH_ID",
      "SEMAPHORE_BUILD_NUMBER",
      "SEMAPHORE_CURRENT_JOB",
      "SEMAPHORE_CURRENT_THREAD",
      "SEMAPHORE_EXECUTABLE_UUID",
      "SEMAPHORE_GIT_BRANCH",
      "SEMAPHORE_GIT_DIR",
      "SEMAPHORE_GIT_REF",
      "SEMAPHORE_GIT_REF_TYPE",
      "SEMAPHORE_GIT_REPO_SLUG",
      "SEMAPHORE_GIT_SHA",
      "SEMAPHORE_GIT_URL",
      "SEMAPHORE_JOB_COUNT",
      "SEMAPHORE_JOB_ID",
      // v2
      "SEMAPHORE_JOB_NAME",
      "SEMAPHORE_JOB_UUID",
      // v1
      "SEMAPHORE_PIPELINE_ID",
      "SEMAPHORE_PLATFORM",
      "SEMAPHORE_PROJECT_DIR",
      "SEMAPHORE_PROJECT_HASH_ID",
      "SEMAPHORE_PROJECT_ID",
      // v2
      "SEMAPHORE_PROJECT_NAME",
      "SEMAPHORE_PROJECT_UUID",
      // v1
      "SEMAPHORE_REPO_SLUG",
      "SEMAPHORE_TRIGGER_SOURCE",
      "SEMAPHORE_WORKFLOW_ID",
      "PULL_REQUEST_NUMBER"
      // pull requests from forks ONLY
    ]),
    // see http://docs.shippable.com/ci/env-vars/
    shippable: extract([
      // build variables
      "SHIPPABLE_BUILD_ID",
      // "5b93354cabfabb07007f01fd"
      "SHIPPABLE_BUILD_NUMBER",
      // "4"
      "SHIPPABLE_COMMIT_RANGE",
      // "sha1...sha2"
      "SHIPPABLE_CONTAINER_NAME",
      // "c.exec.cypress-example-kitchensink.4.1"
      "SHIPPABLE_JOB_ID",
      // "1"
      "SHIPPABLE_JOB_NUMBER",
      // "1"
      "SHIPPABLE_REPO_SLUG",
      // "<username>/<repo>"
      // additional information that Shippable provides
      "IS_FORK",
      // "true"
      "IS_GIT_TAG",
      // "false"
      "IS_PRERELEASE",
      // "false"
      "IS_RELEASE",
      // "false"
      "REPOSITORY_URL",
      // "https://github.com/....git"
      "REPO_FULL_NAME",
      // "<username>/<repo>"
      "REPO_NAME",
      // "cypress-example-kitchensink"
      "BUILD_URL",
      // "https://app.shippable.com/github/<username>/<repo>/runs/1"
      // Pull request information
      "BASE_BRANCH",
      // Name of the target branch into which the pull request changes will be merged.
      "HEAD_BRANCH",
      // This is only set for pull requests and is the name of the branch the pull request was opened from.
      "IS_PULL_REQUEST",
      // "false" or "true"
      "PULL_REQUEST",
      // Pull request number if the job is a pull request. If not, this will be set to false.
      "PULL_REQUEST_BASE_BRANCH",
      // Name of the branch that the pull request will be merged into. It should be the same as BASE_BRANCH.
      "PULL_REQUEST_REPO_FULL_NAME"
      // Full name of the repository from where the pull request originated.
    ]),
    teamcity: null,
    teamfoundation: extract([
      "BUILD_BUILDID",
      "BUILD_BUILDNUMBER",
      "BUILD_CONTAINERID"
    ]),
    travis: extract([
      "TRAVIS_JOB_ID",
      "TRAVIS_BUILD_ID",
      "TRAVIS_BUILD_WEB_URL",
      "TRAVIS_REPO_SLUG",
      "TRAVIS_JOB_NUMBER",
      "TRAVIS_EVENT_TYPE",
      "TRAVIS_COMMIT_RANGE",
      "TRAVIS_BUILD_NUMBER",
      "TRAVIS_PULL_REQUEST",
      "TRAVIS_PULL_REQUEST_BRANCH",
      "TRAVIS_PULL_REQUEST_SHA"
    ]),
    wercker: null,
    // https://docs.netlify.com/configure-builds/environment-variables/#deploy-urls-and-metadata
    netlify: extract([
      "BUILD_ID",
      "CONTEXT",
      "URL",
      "DEPLOY_URL",
      "DEPLOY_PRIME_URL",
      "DEPLOY_ID"
    ]),
    // https://layerci.com/docs/layerfile-reference/build-env
    layerci: extract([
      "LAYERCI_JOB_ID",
      "LAYERCI_RUNNER_ID",
      "RETRY_INDEX",
      "LAYERCI_PULL_REQUEST",
      "LAYERCI_REPO_NAME",
      "LAYERCI_REPO_OWNER",
      "LAYERCI_BRANCH",
      "GIT_TAG"
      // short hex for commits
    ])
  };
};
var _providerCommitParams = () => {
  const { env } = process;
  return {
    appveyor: {
      sha: env.APPVEYOR_REPO_COMMIT,
      // since APPVEYOR_REPO_BRANCH will be the target branch on a PR
      // we need to use PULL_REQUEST_HEAD_REPO_BRANCH if it exists.
      // e.g. if you have a PR: develop <- my-feature-branch
      // my-feature-branch is APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH
      // develop           is APPVEYOR_REPO_BRANCH
      branch: env.APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH || env.APPVEYOR_REPO_BRANCH,
      message: join(
        "\n",
        env.APPVEYOR_REPO_COMMIT_MESSAGE,
        env.APPVEYOR_REPO_COMMIT_MESSAGE_EXTENDED
      ),
      authorName: env.APPVEYOR_REPO_COMMIT_AUTHOR,
      authorEmail: env.APPVEYOR_REPO_COMMIT_AUTHOR_EMAIL
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    awsCodeBuild: {
      sha: env.CODEBUILD_RESOLVED_SOURCE_VERSION,
      // branch: ???,
      // message: ???
      // authorName: ???
      // authorEmail: ???
      remoteOrigin: env.CODEBUILD_SOURCE_REPO_URL
      // defaultBranch: ???
    },
    azure: {
      sha: env.BUILD_SOURCEVERSION,
      branch: env.BUILD_SOURCEBRANCHNAME,
      message: env.BUILD_SOURCEVERSIONMESSAGE,
      authorName: env.BUILD_SOURCEVERSIONAUTHOR,
      authorEmail: env.BUILD_REQUESTEDFOREMAIL
    },
    bamboo: {
      sha: env.bamboo_planRepository_revision,
      branch: env.bamboo_planRepository_branch,
      // message: ???
      authorName: env.bamboo_planRepository_username,
      // authorEmail: ???
      remoteOrigin: env.bamboo_planRepository_repositoryURL
      // defaultBranch: ???
    },
    bitbucket: {
      sha: env.BITBUCKET_COMMIT,
      branch: env.BITBUCKET_BRANCH
      // message: ???
      // authorName: ???
      // authorEmail: ???
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    buildkite: {
      sha: env.BUILDKITE_COMMIT,
      branch: env.BUILDKITE_BRANCH,
      message: env.BUILDKITE_MESSAGE,
      authorName: env.BUILDKITE_BUILD_CREATOR,
      authorEmail: env.BUILDKITE_BUILD_CREATOR_EMAIL,
      remoteOrigin: env.BUILDKITE_REPO,
      defaultBranch: env.BUILDKITE_PIPELINE_DEFAULT_BRANCH
    },
    circle: {
      sha: env.CIRCLE_SHA1,
      branch: env.CIRCLE_BRANCH,
      // message: ???
      authorName: env.CIRCLE_USERNAME,
      // authorEmail: ???
      remoteOrigin: env.CIRCLE_REPOSITORY_URL
      // defaultBranch: ???
    },
    codeshipBasic: {
      sha: env.CI_COMMIT_ID,
      branch: env.CI_BRANCH,
      message: env.CI_COMMIT_MESSAGE,
      authorName: env.CI_COMMITTER_NAME,
      authorEmail: env.CI_COMMITTER_EMAIL
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    codeshipPro: {
      sha: env.CI_COMMIT_ID,
      branch: env.CI_BRANCH,
      message: env.CI_COMMIT_MESSAGE,
      authorName: env.CI_COMMITTER_NAME,
      authorEmail: env.CI_COMMITTER_EMAIL
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    codeFresh: {
      sha: env.CF_REVISION,
      branch: env.CF_BRANCH,
      message: env.CF_COMMIT_MESSAGE,
      authorName: env.CF_COMMIT_AUTHOR
    },
    drone: {
      sha: env.DRONE_COMMIT_SHA,
      // https://docs.drone.io/pipeline/environment/reference/drone-source-branch/
      branch: env.DRONE_SOURCE_BRANCH,
      message: env.DRONE_COMMIT_MESSAGE,
      authorName: env.DRONE_COMMIT_AUTHOR,
      authorEmail: env.DRONE_COMMIT_AUTHOR_EMAIL,
      remoteOrigin: env.DRONE_GIT_HTTP_URL,
      defaultBranch: env.DRONE_REPO_BRANCH
    },
    githubActions: {
      sha: env.GITHUB_SHA,
      branch: env.GH_BRANCH || env.GITHUB_REF,
      defaultBranch: env.GITHUB_BASE_REF,
      remoteBranch: env.GITHUB_HEAD_REF,
      runAttempt: env.GITHUB_RUN_ATTEMPT
    },
    gitlab: {
      sha: env.CI_COMMIT_SHA,
      branch: env.CI_COMMIT_REF_NAME,
      message: env.CI_COMMIT_MESSAGE,
      authorName: env.GITLAB_USER_NAME,
      authorEmail: env.GITLAB_USER_EMAIL,
      remoteOrigin: env.CI_REPOSITORY_URL,
      defaultBranch: env.CI_DEFAULT_BRANCH
    },
    googleCloud: {
      sha: env.COMMIT_SHA,
      branch: env.BRANCH_NAME
      // message: ??
      // authorName: ??
      // authorEmail: ??
      // remoteOrigin: ???
      // defaultBranch: ??
    },
    jenkins: {
      sha: env.GIT_COMMIT,
      branch: env.GIT_BRANCH
      // message: ???
      // authorName: ???
      // authorEmail: ???
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    // Only from forks? https://semaphoreci.com/docs/available-environment-variables.html
    semaphore: {
      sha: env.SEMAPHORE_GIT_SHA,
      branch: env.SEMAPHORE_GIT_BRANCH,
      // message: ???
      // authorName: ???
      // authorEmail: ???
      remoteOrigin: env.SEMAPHORE_GIT_REPO_SLUG
      // defaultBranch: ???
    },
    shippable: {
      sha: env.COMMIT,
      branch: env.BRANCH,
      message: env.COMMIT_MESSAGE,
      authorName: env.COMMITTER
      // authorEmail: ???
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    snap: null,
    teamcity: null,
    teamfoundation: {
      sha: env.BUILD_SOURCEVERSION,
      branch: env.BUILD_SOURCEBRANCHNAME,
      message: env.BUILD_SOURCEVERSIONMESSAGE,
      authorName: env.BUILD_SOURCEVERSIONAUTHOR
    },
    travis: {
      sha: env.TRAVIS_PULL_REQUEST_SHA || env.TRAVIS_COMMIT,
      // for PRs, TRAVIS_BRANCH is the base branch being merged into
      branch: env.TRAVIS_PULL_REQUEST_BRANCH || env.TRAVIS_BRANCH,
      // authorName: ???
      // authorEmail: ???
      message: env.TRAVIS_COMMIT_MESSAGE
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    wercker: null,
    netlify: {
      sha: env.COMMIT_REF,
      branch: env.BRANCH,
      remoteOrigin: env.REPOSITORY_URL
    },
    layerci: {
      sha: env.GIT_COMMIT,
      branch: env.LAYERCI_BRANCH,
      message: env.GIT_COMMIT_TITLE
    }
  };
};
var _get = (fn) => {
  const providerName = getCiProvider();
  if (!providerName)
    return {};
  return _4.chain(fn()).get(providerName).value();
};
function checkForCiBuildFromCi(ciProvider) {
  if (ciProvider && detectableCiBuildIdProviders().includes(ciProvider))
    return true;
  throw new ValidationError(
    `Could not determine CI build ID from the environment. Please provide a unique CI build ID using the --ci-build-id CLI flag or 'ciBuildId' parameter for 'run' method.`
  );
}
function detectableCiBuildIdProviders() {
  return _4.chain(_providerCiParams()).omitBy(_4.isNull).keys().value();
}
function getCiProvider() {
  return _detectProviderName() || null;
}
function getCiParams() {
  return _get(_providerCiParams);
}
function getCommitParams() {
  return _get(_providerCommitParams);
}
function getCI(ciBuildId) {
  const params = getCiParams();
  const provider = getCiProvider();
  if (!ciBuildId)
    checkForCiBuildFromCi(provider);
  debug3("detected CI provider: %s", provider);
  debug3("detected CI params: %O", params);
  return {
    params,
    provider
  };
}
function getCommitDefaults(existingInfo) {
  debug3("git commit existing info");
  debug3(existingInfo);
  const commitParamsObj = getCommitParams();
  debug3("commit info from provider environment variables: %O", commitParamsObj);
  const combined = _4.transform(
    existingInfo,
    (memo, value, key) => {
      return memo[key] = _4.defaultTo(value || commitParamsObj[key], null);
    }
  );
  debug3("combined git and environment variables from provider");
  debug3(combined);
  return combined;
}

// lib/config/index.ts
init_esm_shims();

// lib/config/config.ts
init_esm_shims();
import Debug5 from "debug";
import path3 from "path";

// lib/bootstrap/index.ts
init_esm_shims();

// lib/bootstrap/bootstrap.ts
init_esm_shims();
import { getBinPath } from "cy2";
import Debug4 from "debug";
import execa from "execa";
import fs from "fs";

// lib/fs.ts
init_esm_shims();
import { file } from "tmp-promise";
var createTempFile = async () => {
  const { path: path5 } = await file();
  return path5;
};

// lib/bootstrap/serializer.ts
init_esm_shims();
import Debug3 from "debug";
import _5 from "lodash";
import { customAlphabet } from "nanoid";
var debug4 = Debug3("currents:boot");
var getDummySpec = customAlphabet("abcdefghijklmnopqrstuvwxyz", 10);
function getBootstrapArgs({
  params,
  port,
  tempFilePath
}) {
  return _5.chain(getCypressCLIParams(params)).thru((opts) => ({
    ...opts,
    // merge the env with the currents specific env variables
    env: {
      ...opts.env ?? {},
      currents_temp_file: tempFilePath,
      currents_port: port,
      currents_debug_enabled: process.env.DEBUG?.includes("currents:") ? true : false
    }
  })).tap((opts) => {
    debug4("cypress bootstrap params: %o", opts);
  }).thru(serializeOptions).tap((opts) => {
    debug4("cypress bootstrap serialized params: %o", opts);
  }).thru((args) => {
    return [
      ...args,
      "--spec",
      getDummySpec(),
      params.testingType === "component" ? "--component" : "--e2e"
    ];
  }).value();
}
function getCypressCLIParams(params) {
  const result = getCypressRunAPIParams(params);
  const testingType = result.testingType === "component" ? {
    component: true
  } : {};
  return {
    ..._5.omit(result, "testingType"),
    ...testingType
  };
}
function serializeOptions(options) {
  return Object.entries(options).flatMap(([key, value]) => {
    const _key = dashed(key);
    if (typeof value === "boolean") {
      return value === true ? [`--${_key}`] : [`--${_key}`, false];
    }
    if (_5.isObject(value)) {
      return [`--${_key}`, serializeComplexParam(value)];
    }
    return [`--${_key}`, value.toString()];
  });
}
function serializeComplexParam(param) {
  return JSON.stringify(param);
}
var dashed = (v) => v.replace(/[A-Z]/g, (m) => "-" + m.toLowerCase());

// lib/bootstrap/bootstrap.ts
var debug5 = Debug4("currents:boot");
var bootCypress = async (port, params) => {
  debug5("booting cypress...");
  const tempFilePath = await createTempFile();
  const cypressBin = await getBinPath(require2.resolve("cypress"));
  debug5("cypress executable location: %s", cypressBin);
  const args = getBootstrapArgs({ port, tempFilePath, params });
  debug5("booting cypress with args: %o", args);
  const { stdout: stdout2, stderr } = await execCypress(cypressBin, args);
  if (!fs.existsSync(tempFilePath)) {
    throw new Error(
      `Cannot resolve cypress configuration from ${tempFilePath}. Please report the issue.`
    );
  }
  try {
    const f = fs.readFileSync(tempFilePath, "utf-8");
    if (!f) {
      throw new Error("Is cypress-cloud/plugin installed?");
    }
    debug5("cypress config '%s': '%s'", tempFilePath, f);
    return JSON.parse(f);
  } catch (err) {
    debug5("read config temp file failed: %o", err);
    info(bold("Cypress stdout:\n"), stdout2);
    info(bold("Cypress stderr:\n"), stderr);
    throw new ValidationError(`Unable to resolve cypress configuration
- make sure that 'cypress-cloud/plugin' is installed
- report the issue together with cypress stdout and stderr
`);
  }
};
async function execCypress(cypressBin, args) {
  let stdout2 = "";
  let stderr = "";
  try {
    await execa(cypressBin, ["run", ...args], {
      stdio: "pipe",
      env: {
        ...process.env,
        // prevent warnings about recording mode
        CYPRESS_RECORD_KEY: void 0,
        CYPRESS_PROJECT_ID: void 0
      }
    });
  } catch (err) {
    debug5("exec cypress failed (certain failures are expected): %o", err);
    stdout2 = err.stdout;
    stderr = err.stderr;
  }
  return { stdout: stdout2, stderr };
}

// lib/utils.ts
init_esm_shims();
import path2 from "path";
function toArray(val) {
  return val ? typeof val === "string" ? [val] : val : [];
}
function toPosix(file2, sep = path2.sep) {
  return file2.split(sep).join(path2.posix.sep);
}
var getRandomPort = () => {
  const min = 1024;
  const max = 65535;
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

// lib/config/config.ts
var debug6 = Debug5("currents:config");
var _config = null;
function getCurrentsConfig(projectRoot) {
  if (_config) {
    return _config;
  }
  const defaultConfig = {
    e2e: {
      batchSize: 3
    },
    component: {
      batchSize: 5
    },
    cloudServiceUrl: "https://cy.currents.dev"
  };
  const configFilePath = getConfigFilePath(projectRoot);
  try {
    const resolvedPath = path3.resolve(...configFilePath);
    debug6("loading currents config file from '%s'", resolvedPath);
    const fsConfig = require2(resolvedPath);
    _config = {
      ...defaultConfig,
      ...fsConfig
    };
    return _config;
  } catch (e) {
    warn("failed to load config file: %s", configFilePath);
    debug6("failure details: %s", e);
    _config = defaultConfig;
    return _config;
  }
}
async function getMergedConfig(params) {
  debug6("resolving cypress config");
  const cypressResolvedConfig = await bootCypress(getRandomPort(), params);
  debug6("cypress resolvedConfig: %O", cypressResolvedConfig);
  const rawE2EPattern = cypressResolvedConfig.rawJson?.e2e?.specPattern;
  let additionalIgnorePattern = [];
  if (params.testingType === "component" && rawE2EPattern) {
    additionalIgnorePattern = rawE2EPattern;
  }
  const result = {
    projectRoot: cypressResolvedConfig?.projectRoot || process.cwd(),
    projectId: params.projectId,
    specPattern: cypressResolvedConfig?.specPattern || "**/*.*",
    excludeSpecPattern: (
      // @ts-ignore
      cypressResolvedConfig?.resolved.excludeSpecPattern.value ?? []
    ),
    additionalIgnorePattern,
    resolved: cypressResolvedConfig
  };
  debug6("merged config: %O", result);
  return result;
}
function getConfigFilePath(projectRoot = null) {
  return [projectRoot ?? process.cwd(), "currents.config.js"];
}

// lib/config/params.ts
init_esm_shims();
import Debug6 from "debug";
import _6 from "lodash";
var debug7 = Debug6("currents:validateParams");
function resolveCurrentsParams(params) {
  const configFromFile = getCurrentsConfig(params.project);
  const cloudServiceUrl = params.cloudServiceUrl ?? process.env.CURRENTS_API_URL ?? configFromFile.cloudServiceUrl;
  const recordKey = params.recordKey ?? process.env.CURRENTS_RECORD_KEY ?? configFromFile.recordKey;
  const projectId = params.projectId ?? process.env.CURRENTS_PROJECT_ID ?? configFromFile.projectId;
  const testingType = params.testingType ?? "e2e";
  const batchSize = testingType === "e2e" ? configFromFile.e2e.batchSize : configFromFile.component.batchSize;
  return {
    ...params,
    cloudServiceUrl,
    recordKey,
    projectId,
    batchSize,
    testingType
  };
}
var projectIdError = `Cannot resolve projectId. Please use one of the following:
- provide it as a "projectId" property for "run" API method
- set CURRENTS_PROJECT_ID environment variable
- set "projectId" in "currents.config.js" file`;
var cloudServiceUrlError = `Cannot resolve cloud service URL. Please use one of the following:
- provide it as a "cloudServiceUrl" property for "run" API method
- set CURRENTS_API_URL environment variable
- set "cloudServiceUrl" in "currents.config.js" file`;
var cloudServiceInvalidUrlError = `Invalid cloud service URL provided`;
var recordKeyError = `Cannot resolve record key. Please use one of the following:

- pass it as a CLI flag '-k, --key <record-key>'
- provide it as a "recordKey" property for "run" API method
- set CURRENTS_RECORD_KEY environment variable
- set "recordKey" in "currents.config.js" file
`;
function validateParams(_params) {
  const params = resolveCurrentsParams(_params);
  if (!params.cloudServiceUrl) {
    throw new ValidationError(cloudServiceUrlError);
  }
  if (!params.projectId) {
    throw new ValidationError(projectIdError);
  }
  if (!params.recordKey) {
    throw new ValidationError(recordKeyError);
  }
  validateURL(params.cloudServiceUrl);
  const requiredParameters = [
    "testingType",
    "batchSize",
    "projectId"
  ];
  requiredParameters.forEach((key) => {
    if (typeof params[key] === "undefined") {
      error('Missing required parameter "%s"', key);
      throw new Error("Missing required parameter");
    }
  });
  params.tag = parseTags(params.tag);
  params.autoCancelAfterFailures = getAutoCancelValue(
    params.autoCancelAfterFailures
  );
  debug7("validated currents params: %o", params);
  return params;
}
function getAutoCancelValue(value) {
  if (typeof value === "undefined") {
    return void 0;
  }
  if (typeof value === "boolean") {
    return value ? 1 : false;
  }
  if (typeof value === "number" && value > 0) {
    return value;
  }
  throw new ValidationError(
    `autoCancelAfterFailures: should be a positive integer or "false". Got: "${value}"`
  );
}
function isOffline(params) {
  return params.record === false;
}
function parseTags(tagString) {
  if (!tagString) {
    return [];
  }
  if (Array.isArray(tagString)) {
    return tagString.filter(Boolean);
  }
  return tagString.split(",").map((tag) => tag.trim()).filter(Boolean);
}
function validateURL(url) {
  try {
    new URL(url);
  } catch (err) {
    throw new ValidationError(`${cloudServiceInvalidUrlError}: "${url}"`);
  }
}
function getCypressRunAPIParams(params) {
  return {
    ..._6.pickBy(
      _6.omit(params, [
        "autoCancelAfterFailures",
        "cloudServiceUrl",
        "batchSize",
        "projectId",
        "key",
        "recordKey",
        "record",
        "group",
        "parallel",
        "tag",
        "ciBuildId",
        "spec",
        "exit",
        "headed",
        "headless"
      ]),
      Boolean
    ),
    record: false
  };
}
function preprocessParams(params) {
  return {
    ...params,
    spec: processSpecParam(params.spec)
  };
}
function processSpecParam(spec) {
  if (!spec) {
    return void 0;
  }
  if (Array.isArray(spec)) {
    return _6.flatten(spec.map((i) => i.split(",")));
  }
  return spec.split(",");
}

// lib/cypress/index.ts
init_esm_shims();

// lib/cypress/cypress.ts
init_esm_shims();
import cypress from "cypress";
import Debug7 from "debug";
import _7 from "lodash";
var debug8 = Debug7("currents:cypress");
function runBareCypress(params = {}) {
  const p = {
    ...params,
    ciBuildId: void 0,
    tag: void 0,
    parallel: void 0,
    record: false,
    group: void 0,
    spec: _7.flatten(params.spec).join(",")
  };
  debug8("Running bare Cypress with params %o", p);
  return cypress.run(p);
}
async function runSpecFile({ spec }, cypressRunOptions) {
  const runAPIOptions = getCypressRunAPIParams(cypressRunOptions);
  const options = {
    ...runAPIOptions,
    config: {
      ...runAPIOptions.config,
      trashAssetsBeforeRuns: false
    },
    env: {
      ...runAPIOptions.env,
      currents_ws: true
    },
    spec
  };
  debug8("running cypress with options %o", options);
  const result = await cypress.run(options);
  debug8("cypress run result %o", result);
  return result;
}
var runSpecFileSafe = async ({ spec }, cypressRunOptions) => {
  try {
    return await runSpecFile({ spec }, cypressRunOptions);
  } catch (error2) {
    debug8("cypress run exception %o", error2);
    return {
      status: "failed",
      failures: 1,
      message: `Cypress process crashed with an error:
${error2.message}
${error2.stack}}`
    };
  }
};

// lib/git.ts
init_esm_shims();
import git from "@cypress/commit-info";
var getGitInfo = async (projectRoot) => {
  const commitInfo = await git.commitInfo(projectRoot);
  return getCommitDefaults({
    branch: commitInfo.branch,
    remoteOrigin: commitInfo.remote,
    authorEmail: commitInfo.email,
    authorName: commitInfo.author,
    message: commitInfo.message,
    sha: commitInfo.sha
  });
};

// lib/platform/index.ts
init_esm_shims();

// lib/platform/browser.ts
init_esm_shims();
import Debug8 from "debug";
var debug9 = Debug8("currents:browser");
function guessBrowser(browser, availableBrowsers = []) {
  debug9(
    "guessing browser from '%s', available browsers: %o",
    browser,
    availableBrowsers
  );
  let result = availableBrowsers.find((b) => b.name === browser);
  if (result) {
    debug9("identified browser by name: %o", result);
    return {
      browserName: result.displayName,
      browserVersion: result.version
    };
  }
  result = availableBrowsers.find((b) => b.path === browser);
  if (result) {
    debug9("identified browser by path: %o", result);
    return {
      browserName: result.displayName ?? result.name,
      browserVersion: result.version
    };
  }
  warn("Unable to identify browser name and version");
  return {
    browserName: "unknown",
    browserVersion: "unknown"
  };
}

// lib/platform/platform.ts
init_esm_shims();
import Debug9 from "debug";
import getos from "getos";
import { cpus, freemem, platform, release, totalmem } from "os";
import { promisify } from "util";
var debug10 = Debug9("currents:platform");
var getOsVersion = async () => {
  if (platform() === "linux") {
    try {
      const linuxOs = await promisify(getos)();
      if ("dist" in linuxOs && "release" in linuxOs) {
        return [linuxOs.dist, linuxOs.release].join(" - ");
      } else {
        return release();
      }
    } catch {
      return release();
    }
  }
  return release();
};
var getPlatformInfo = async () => {
  const osVersion = await getOsVersion();
  const result = {
    osName: platform(),
    osVersion,
    osCpus: cpus(),
    osMemory: {
      free: freemem(),
      total: totalmem()
    }
  };
  debug10("platform info: %o", result);
  return result;
};

// lib/platform/index.ts
async function getPlatform({
  browser,
  config
}) {
  return {
    ...await getPlatformInfo(),
    ...guessBrowser(browser ?? "electron", config.resolved?.browsers)
  };
}

// lib/results/index.ts
init_esm_shims();

// lib/results/results.ts
init_esm_shims();
import Debug10 from "debug";
import _8 from "lodash";
import { nanoid } from "nanoid";
var debug11 = Debug10("currents:results");
var isSuccessResult = (result) => {
  return result.status === "finished";
};
var getScreenshotsSummary = (tests = []) => {
  return tests.flatMap(
    (test, i) => test.attempts.flatMap(
      (a, ai) => a.screenshots.flatMap((s) => ({
        ...s,
        testId: `r${i}`,
        testAttemptIndex: ai,
        screenshotId: nanoid()
      }))
    )
  );
};
var getStats = (stats) => {
  return {
    ...stats,
    wallClockDuration: stats.duration,
    wallClockStartedAt: stats.startedAt,
    wallClockEndedAt: stats.endedAt
  };
};
var getTestAttempt = (attempt) => {
  return {
    ...attempt,
    state: attempt.state,
    wallClockDuration: attempt.duration,
    wallClockStartedAt: attempt.startedAt
  };
};
var getInstanceResultPayload = (runResult) => {
  const altTests = [];
  if (runResult.error && !runResult.tests?.length) {
    altTests.push(getFakeTestFromException(runResult.error, runResult.stats));
  }
  return {
    stats: getStats(runResult.stats),
    reporterStats: runResult.reporterStats,
    exception: runResult.error ?? null,
    video: !!runResult.video,
    // Did the instance generate a video?
    screenshots: getScreenshotsSummary(runResult.tests ?? []),
    tests: runResult.tests?.map((test, i) => ({
      displayError: test.displayError,
      state: test.state,
      hooks: runResult.hooks,
      attempts: test.attempts?.map(getTestAttempt) ?? [],
      clientId: `r${i}`
    })) ?? altTests
  };
};
function getFakeTestFromException(error2, stats) {
  return {
    title: ["Unknown"],
    body: "",
    displayError: error2.split("\n")[0],
    state: "failed",
    hooks: [],
    attempts: [
      getTestAttempt({
        state: "failed",
        duration: 0,
        error: {
          name: "Error",
          message: error2.split("\n")[0],
          stack: error2
        },
        screenshots: [],
        startedAt: stats.startedAt,
        videoTimestamp: 0
      })
    ],
    clientId: "r0"
  };
}
var getInstanceTestsPayload = (runResult, config) => {
  const altTests = [];
  if (runResult.error && !runResult.tests?.length) {
    altTests.push(getFakeTestFromException(runResult.error, runResult.stats));
  }
  return {
    config,
    tests: runResult.tests?.map((test, i) => ({
      title: test.title,
      config: null,
      body: test.body,
      clientId: `r${i}`,
      hookIds: []
    })) ?? altTests,
    hooks: runResult.hooks
  };
};
var summarizeTestResults = (input, config) => {
  if (!input.length) {
    return getEmptyCypressResults(config);
  }
  const overall = input.reduce(
    (acc, {
      totalDuration,
      totalFailed,
      totalPassed,
      totalPending,
      totalSkipped,
      totalTests,
      totalSuites
    }) => ({
      totalDuration: acc.totalDuration + totalDuration,
      totalSuites: acc.totalSuites + totalSuites,
      totalPending: acc.totalPending + totalPending,
      totalFailed: acc.totalFailed + totalFailed,
      totalSkipped: acc.totalSkipped + totalSkipped,
      totalPassed: acc.totalPassed + totalPassed,
      totalTests: acc.totalTests + totalTests
    }),
    emptyStats
  );
  const firstResult = input[0];
  const startItems = input.map((i) => i.startedTestsAt).sort();
  const endItems = input.map((i) => i.endedTestsAt).sort();
  const runs = input.map((i) => i.runs).flat();
  return {
    ...overall,
    runs,
    startedTestsAt: _8.first(startItems),
    endedTestsAt: _8.last(endItems),
    ..._8.pick(
      firstResult,
      "browserName",
      "browserVersion",
      "browserPath",
      "osName",
      "osVersion",
      "cypressVersion",
      "config"
    ),
    status: "finished"
  };
};
function getEmptyCypressResults(config) {
  return {
    ...emptyStats,
    status: "finished",
    startedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    endedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    runs: [],
    // @ts-ignore
    config
  };
}
var emptyStats = {
  totalDuration: 0,
  totalSuites: 0,
  totalPending: 0,
  totalFailed: 0,
  totalSkipped: 0,
  totalPassed: 0,
  totalTests: 0
};
function getFailedDummyResult({
  specs,
  error: error2,
  config
}) {
  const start = (/* @__PURE__ */ new Date()).toISOString();
  const end = (/* @__PURE__ */ new Date()).toISOString();
  return {
    config,
    status: "finished",
    startedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    endedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    totalDuration: 0,
    totalSuites: 1,
    totalFailed: 1,
    totalPassed: 0,
    totalPending: 0,
    totalSkipped: 0,
    totalTests: 1,
    browserName: "unknown",
    browserVersion: "unknown",
    browserPath: "unknown",
    osName: "unknown",
    osVersion: "unknown",
    cypressVersion: "unknown",
    runs: specs.map((s) => ({
      stats: {
        suites: 1,
        tests: 1,
        passes: 0,
        pending: 0,
        skipped: 0,
        failures: 1,
        startedAt: start,
        endedAt: end,
        duration: 0
      },
      reporter: "spec",
      reporterStats: {},
      hooks: [],
      error: error2,
      video: null,
      spec: {
        name: s,
        relative: "",
        absolute: "",
        relativeToCommonRoot: ""
      },
      tests: [
        {
          title: ["Unknown"],
          state: "failed",
          body: "// This test is automatically generated due to execution failure",
          displayError: error2,
          attempts: [
            {
              state: "failed",
              startedAt: start,
              duration: 0,
              videoTimestamp: 0,
              screenshots: [],
              error: {
                name: "CloudExecutionError",
                message: error2,
                stack: ""
              }
            }
          ]
        }
      ],
      shouldUploadVideo: false,
      skippedSpec: false
    }))
  };
}
function normalizeRawResult(rawResult, specs, config) {
  if (!isSuccessResult(rawResult)) {
    return getFailedDummyResult({
      specs,
      error: rawResult.message,
      config
    });
  }
  return rawResult;
}
function getSummaryForSpec(spec, runResult) {
  const run2 = runResult.runs.find((r) => r.spec.relative === spec);
  if (!run2) {
    return;
  }
  const stats = getStats(run2.stats);
  return {
    ...runResult,
    runs: [run2],
    totalSuites: 1,
    totalDuration: stats.wallClockDuration,
    totalTests: stats.tests,
    totalFailed: stats.failures,
    totalPassed: stats.passes,
    totalPending: stats.pending,
    totalSkipped: stats.skipped,
    startedTestsAt: stats.wallClockStartedAt,
    endedTestsAt: stats.wallClockEndedAt
  };
}

// lib/results/table.ts
init_esm_shims();
import _9 from "lodash";
import prettyMS from "pretty-ms";
import { table } from "table";
var failureIcon = red("\u2716");
var successIcon = green("\u2714");
var summaryTable = (r) => {
  const overallSpecCount = r.runs.length;
  const failedSpecsCount = _9.sum(
    r.runs.filter((v) => v.stats.failures + v.stats.skipped > 0).map(() => 1)
  );
  const hasFailed = failedSpecsCount > 0;
  const verdict = hasFailed ? red(`${failedSpecsCount} of ${overallSpecCount} failed`) : overallSpecCount > 0 ? "All specs passed!" : "No specs executed";
  const data = r.runs.map((r2) => [
    r2.stats.failures + r2.stats.skipped > 0 ? failureIcon : successIcon,
    r2.spec.relativeToCommonRoot,
    gray(prettyMS(r2.stats.duration)),
    white(r2.stats.tests ?? 0),
    r2.stats.passes ? green(r2.stats.passes) : gray("-"),
    r2.stats.failures ? red(r2.stats.failures) : gray("-"),
    r2.stats.pending ? cyan(r2.stats.pending) : gray("-"),
    r2.stats.skipped ? red(r2.stats.skipped) : gray("-")
  ]);
  return table(
    [
      [
        "",
        // marker
        gray("Spec"),
        "",
        gray("Tests"),
        gray("Passing"),
        gray("Failing"),
        gray("Pending"),
        gray("Skipped")
      ],
      ...data,
      [
        hasFailed ? failureIcon : successIcon,
        // marker
        verdict,
        gray(prettyMS(r.totalDuration ?? 0)),
        overallSpecCount > 0 ? white(r.totalTests ?? 0) : gray("-"),
        r.totalPassed ? green(r.totalPassed) : gray("-"),
        r.totalFailed ? red(r.totalFailed) : gray("-"),
        r.totalPending ? cyan(r.totalPending) : gray("-"),
        r.totalSkipped ? red(r.totalSkipped) : gray("-")
      ]
    ],
    {
      border,
      columnDefault: {
        width: 8
      },
      columns: [
        { alignment: "left", width: 2 },
        { alignment: "left", width: 30 },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" }
      ],
      // singleLine: true,
      drawHorizontalLine: (lineIndex, rowCount) => {
        return lineIndex === 1 || lineIndex === 0 || lineIndex === rowCount - 1 || lineIndex === rowCount;
      },
      drawVerticalLine: (lineIndex, rowCount) => {
        return lineIndex === 0 || rowCount === lineIndex;
      }
    }
  );
};
var border = _9.mapValues(
  {
    topBody: `\u2500`,
    topJoin: `\u252C`,
    topLeft: `  \u250C`,
    topRight: `\u2510`,
    bottomBody: `\u2500`,
    bottomJoin: `\u2534`,
    bottomLeft: `  \u2514`,
    bottomRight: `\u2518`,
    bodyLeft: `  \u2502`,
    bodyRight: `\u2502`,
    bodyJoin: `\u2502`,
    joinBody: `\u2500`,
    joinLeft: `  \u251C`,
    joinRight: `\u2524`,
    joinJoin: `\u253C`
  },
  (v) => gray(v)
);

// lib/results/uploadResults.ts
init_esm_shims();
import Debug13 from "debug";

// lib/artifacts.ts
init_esm_shims();
import Debug12 from "debug";

// lib/lang.ts
init_esm_shims();
import bluebird from "bluebird";
bluebird.Promise.config({
  cancellation: true
});
var BPromise = bluebird.Promise;
var safe = (fn, ifFaled, ifSucceed) => async (...args) => {
  try {
    const r = await fn(...args);
    ifSucceed();
    return r;
  } catch (e) {
    ifFaled(e);
  }
};

// lib/upload.ts
init_esm_shims();
import Debug11 from "debug";
import fs2 from "fs";
var readFile = fs2.promises.readFile;
var debug12 = Debug11("currents:upload");
function uploadVideo(file2, url) {
  return uploadFile(file2, url, "video/mp4");
}
function uploadImage(file2, url) {
  return uploadFile(file2, url, "image/png");
}
async function uploadFile(file2, url, type) {
  debug12('uploading file "%s" to "%s"', file2, url);
  const f = await readFile(file2);
  await makeRequest({
    url,
    method: "PUT",
    data: f,
    headers: {
      "Content-Type": type
    }
  });
}

// lib/artifacts.ts
var debug13 = Debug12("currents:artifacts");
async function uploadArtifacts({
  videoPath,
  videoUploadUrl,
  screenshots,
  screenshotUploadUrls
}) {
  debug13("uploading artifacts: %o", {
    videoPath,
    videoUploadUrl,
    screenshots,
    screenshotUploadUrls
  });
  const totalUploads = (videoPath ? 1 : 0) + screenshots.length;
  if (totalUploads === 0) {
    return;
  }
  if (videoUploadUrl && videoPath) {
    await safe(
      uploadVideo,
      (e) => debug13("failed uploading video %s. Error: %o", videoPath, e),
      () => debug13("success uploading", videoPath)
    )(videoPath, videoUploadUrl);
  }
  if (screenshotUploadUrls && screenshotUploadUrls.length) {
    await Promise.all(
      screenshots.map((screenshot) => {
        const url = screenshotUploadUrls.find(
          (urls) => urls.screenshotId === screenshot.screenshotId
        )?.uploadUrl;
        if (!url) {
          debug13(
            "No upload url for screenshot %o, screenshotUploadUrls: %o",
            screenshot,
            screenshotUploadUrls
          );
          warn("Cannot find upload url for screenshot: %s", screenshot.path);
          return Promise.resolve();
        }
        return safe(
          uploadImage,
          (e) => debug13(
            "failed uploading screenshot %s. Error: %o",
            screenshot.path,
            e
          ),
          () => debug13("success uploading", screenshot.path)
        )(screenshot.path, url);
      })
    );
  }
}
var uploadStdoutSafe = safe(
  updateInstanceStdout,
  () => {
  },
  () => {
  }
);

// lib/env.ts
init_esm_shims();
var isCurrents = () => !!process.env.CURRENTS_ENFORCE_IS_CURRENTS || getAPIBaseUrl() === "https://cy.currents.dev";

// lib/state.ts
init_esm_shims();

// lib/pubsub.ts
init_esm_shims();
import EventEmitter from "events";
var pubsub = new EventEmitter();

// lib/state.ts
var state = {
  cancellationReason: null
};
var setCancellationReason = (reason) => {
  if (state.cancellationReason) {
    return;
  }
  state.cancellationReason = reason;
  pubsub.emit("runCancelled" /* RUN_CANCELLED */, reason);
};

// lib/results/uploadResults.ts
var debug14 = Debug13("currents:results");
async function getUploadResultsTask({
  instanceId,
  spec,
  runResult,
  output
}) {
  const run2 = runResult.runs.find((r) => r.spec.relative === spec);
  if (!run2) {
    warn('Cannot determine run result for spec "%s"', spec);
    return;
  }
  return processCypressResults(
    instanceId,
    {
      // replace the runs with the run for the specified spec
      ...runResult,
      runs: [run2]
    },
    output
  );
}
async function processCypressResults(instanceId, results, stdout2) {
  const run2 = results.runs[0];
  if (!run2) {
    throw new Error("No run found in Cypress results");
  }
  const instanceResults = getInstanceResultPayload(run2);
  const instanceTests = getInstanceTestsPayload(run2, results.config);
  const { videoUploadUrl, screenshotUploadUrls, cloud } = await reportResults(
    instanceId,
    instanceTests,
    instanceResults
  );
  if (cloud?.shouldCancel) {
    debug14("instance %s should cancel", instanceId);
    setCancellationReason(cloud.shouldCancel);
  }
  debug14("instance %s artifact upload instructions %o", instanceId, {
    videoUploadUrl,
    screenshotUploadUrls
  });
  return Promise.all([
    uploadArtifacts({
      videoUploadUrl,
      videoPath: run2.video,
      screenshotUploadUrls,
      screenshots: instanceResults.screenshots
    }),
    uploadStdoutSafe(instanceId, getInitialOutput() + stdout2)
  ]);
}
async function reportResults(instanceId, instanceTests, instanceResults) {
  debug14("reporting instance %s results...", instanceId);
  if (isCurrents()) {
    return reportInstanceResultsMerged(instanceId, {
      tests: instanceTests,
      results: instanceResults
    });
  }
  await setInstanceTests(instanceId, instanceTests);
  return updateInstanceResults(instanceId, instanceResults);
}

// lib/runner/index.ts
init_esm_shims();

// lib/runner/cancellable.ts
init_esm_shims();

// lib/runner/runner.ts
init_esm_shims();
import Debug14 from "debug";

// lib/runner/state.ts
init_esm_shims();
var summary = {};
var uploadTasks = [];

// lib/runner/runner.ts
var debug15 = Debug14("currents:runner");
async function runTillDone({
  runId,
  groupId,
  machineId,
  platform: platform2,
  config,
  specs: allSpecs
}, params) {
  let hasMore = true;
  while (hasMore) {
    const newTasks = await runBatch({
      runMeta: {
        runId,
        groupId,
        machineId,
        platform: platform2
      },
      allSpecs,
      params,
      config
    });
    if (!newTasks.length) {
      debug15("No more tasks to run. Uploads queue: %d", uploadTasks.length);
      hasMore = false;
      break;
    }
    newTasks.forEach((task) => {
      if (task.summary.specSummary) {
        summary[task.summary.spec] = task.summary.specSummary;
      }
      uploadTasks.push(task.uploadTasks);
    });
  }
}
async function runBatch({
  runMeta,
  config,
  params,
  allSpecs
}) {
  let batch = {
    specs: [],
    claimedInstances: 0,
    totalInstances: 0
  };
  if (isCurrents()) {
    debug15("Getting batched tasks: %d", params.batchSize);
    batch = await createBatchedInstances({
      ...runMeta,
      batchSize: params.batchSize
    });
    debug15("Got batched tasks: %o", batch);
  } else {
    const response = await createInstance(runMeta);
    if (response.spec !== null && response.instanceId !== null) {
      batch.specs.push({
        spec: response.spec,
        instanceId: response.instanceId
      });
    }
    batch.claimedInstances = response.claimedInstances;
    batch.totalInstances = response.totalInstances;
  }
  if (batch.specs.length === 0) {
    return [];
  }
  divider();
  info(
    "Running: %s (%d/%d)",
    batch.specs.map((s) => s.spec).join(", "),
    batch.claimedInstances,
    batch.totalInstances
  );
  const rawResult = await runSpecFileSafe(
    {
      // use absolute paths -  user can run the program from a different directory, e.g. nx or a monorepo workspace
      // cypress still reports the path relative to the project root
      spec: batch.specs.map((bs) => getSpecAbsolutePath(allSpecs, bs.spec)).join(",")
    },
    params
  );
  const normalizedResult = normalizeRawResult(
    rawResult,
    batch.specs.map((s) => s.spec),
    config
  );
  title("blue", "Reporting results and artifacts in background...");
  const output = getCapturedOutput();
  resetCapture();
  const batchResult = batch.specs.map((spec) => {
    const specSummary = getSummaryForSpec(spec.spec, normalizedResult);
    if (!specSummary) {
      warn('Cannot find run result for spec "%s"', spec.spec);
    }
    return {
      summary: {
        spec: spec.spec,
        specSummary
      },
      uploadTasks: getUploadResultsTask({
        ...spec,
        runResult: normalizedResult,
        output
      }).catch(error)
    };
  });
  return batchResult;
}
function getSpecAbsolutePath(allSpecs, relative) {
  const absolutePath = allSpecs.find((i) => i.relative === relative)?.absolute;
  if (!absolutePath) {
    warn(
      'Cannot find absolute path for spec. Spec: "%s", candidates: %o',
      relative,
      allSpecs
    );
    throw new Error(`Cannot find absolute path for spec`);
  }
  return absolutePath;
}

// lib/runner/cancellable.ts
var cancellable = null;
function onRunCancelled(reason) {
  warn(
    `Run cancelled: %s. Waiting for uploads to complete and stopping execution...`,
    reason
  );
  cancellable?.cancel();
}
async function runTillDoneOrCancelled(...args) {
  return new Promise((_resolve, _reject) => {
    cancellable = new BPromise((resolve, reject, onCancel) => {
      if (!onCancel) {
        _reject(new Error("BlueBird is misconfigured: onCancel is undefined"));
        return;
      }
      onCancel(() => _resolve(summary));
      runTillDone(...args).then(
        () => {
          resolve();
          _resolve(summary);
        },
        (error2) => {
          reject();
          _reject(error2);
        }
      );
    });
    pubsub.addListener("runCancelled" /* RUN_CANCELLED */, onRunCancelled);
  }).finally(() => {
    pubsub.removeListener("runCancelled" /* RUN_CANCELLED */, onRunCancelled);
  });
}

// lib/specMatcher/index.ts
init_esm_shims();

// lib/specMatcher/getSpecFiles.ts
init_esm_shims();

// lib/specMatcher/specMatcher.ts
init_esm_shims();
import Debug15 from "debug";
import path4 from "path";
import commonPathPrefix from "common-path-prefix";
import globby from "globby";
import _10 from "lodash";
import os from "os";
var debug16 = Debug15("currents:specs");
async function findSpecs({
  projectRoot,
  testingType,
  specPattern,
  configSpecPattern,
  excludeSpecPattern,
  additionalIgnorePattern
}) {
  configSpecPattern = toArray(configSpecPattern);
  specPattern = toArray(specPattern);
  excludeSpecPattern = toArray(excludeSpecPattern) || [];
  additionalIgnorePattern = toArray(additionalIgnorePattern) || [];
  debug16("exploring spec files for execution %O", {
    testingType,
    projectRoot,
    specPattern,
    configSpecPattern,
    excludeSpecPattern,
    additionalIgnorePattern
  });
  if (!specPattern || !configSpecPattern) {
    throw Error("Could not find glob patterns for exploring specs");
  }
  let specAbsolutePaths = await getFilesByGlob(projectRoot, specPattern, {
    absolute: true,
    ignore: [...excludeSpecPattern, ...additionalIgnorePattern]
  });
  if (!_10.isEqual(specPattern, configSpecPattern)) {
    const defaultSpecAbsolutePaths = await getFilesByGlob(
      projectRoot,
      configSpecPattern,
      {
        absolute: true,
        ignore: [...excludeSpecPattern, ...additionalIgnorePattern]
      }
    );
    specAbsolutePaths = _10.intersection(
      specAbsolutePaths,
      defaultSpecAbsolutePaths
    );
  }
  return matchedSpecs({
    projectRoot,
    testingType,
    specAbsolutePaths,
    specPattern
  });
}
async function getFilesByGlob(projectRoot, glob, globOptions) {
  const workingDirectoryPrefix = path4.join(projectRoot, path4.sep);
  const globs = [].concat(glob).map(
    (globPattern) => globPattern.startsWith("./") ? globPattern.replace("./", "") : globPattern
  ).map((globPattern) => {
    if (globPattern.startsWith(workingDirectoryPrefix)) {
      return globPattern.replace(workingDirectoryPrefix, "");
    }
    return globPattern;
  });
  if (os.platform() === "win32") {
    debug16("updating glob patterns to POSIX");
    for (const i in globs) {
      const cur = globs[i];
      if (!cur)
        throw new Error("undefined glob received");
      globs[i] = toPosix(cur);
    }
  }
  try {
    debug16("globbing pattern(s): %o", globs);
    debug16("within directory: %s", projectRoot);
    return matchGlobs(globs, {
      onlyFiles: true,
      absolute: true,
      cwd: projectRoot,
      ...globOptions,
      ignore: (globOptions?.ignore ?? []).concat("**/node_modules/**")
    });
  } catch (e) {
    debug16("error in getFilesByGlob %o", e);
    return [];
  }
}
var matchGlobs = async (globs, globbyOptions) => {
  return await globby(globs, globbyOptions);
};
function matchedSpecs({
  projectRoot,
  testingType,
  specAbsolutePaths
}) {
  debug16("found specs %o", specAbsolutePaths);
  let commonRoot = "";
  if (specAbsolutePaths.length === 1) {
    commonRoot = path4.dirname(specAbsolutePaths[0]);
  } else {
    commonRoot = commonPathPrefix(specAbsolutePaths);
  }
  return specAbsolutePaths.map(
    (absolute) => transformSpec({
      projectRoot,
      absolute,
      testingType,
      commonRoot,
      platform: os.platform(),
      sep: path4.sep
    })
  );
}
function transformSpec({
  projectRoot,
  absolute,
  testingType,
  commonRoot,
  platform: platform2,
  sep
}) {
  if (platform2 === "win32") {
    absolute = toPosix(absolute, sep);
    projectRoot = toPosix(projectRoot, sep);
  }
  const relative = path4.relative(projectRoot, absolute);
  const parsedFile = path4.parse(absolute);
  const fileExtension = path4.extname(absolute);
  const specFileExtension = [".spec", ".test", "-spec", "-test", ".cy"].map((ext) => ext + fileExtension).find((ext) => absolute.endsWith(ext)) || fileExtension;
  const parts = absolute.split(projectRoot);
  let name = parts[parts.length - 1] || "";
  if (name.startsWith("/")) {
    name = name.slice(1);
  }
  const LEADING_SLASH = /^\/|/g;
  const relativeToCommonRoot = absolute.replace(commonRoot, "").replace(LEADING_SLASH, "");
  return {
    fileExtension,
    baseName: parsedFile.base,
    fileName: parsedFile.base.replace(specFileExtension, ""),
    specFileExtension,
    relativeToCommonRoot,
    specType: testingType === "component" ? "component" : "integration",
    name,
    relative,
    absolute
  };
}

// lib/specMatcher/getSpecFiles.ts
var getSpecFiles = async ({
  config,
  params
}) => {
  const specPattern = getSpecPattern(config.specPattern, params.spec);
  const specs = await findSpecs({
    // https://docs.cypress.io/guides/guides/command-line#cypress-run-spec-lt-spec-gt
    projectRoot: params.project ?? config.projectRoot,
    testingType: params.testingType,
    specPattern,
    configSpecPattern: config.specPattern,
    excludeSpecPattern: config.excludeSpecPattern,
    additionalIgnorePattern: config.additionalIgnorePattern
  });
  if (specs.length === 0) {
    warn(
      "Found no spec files. Was looking for spec files that match both configSpecPattern and specPattern relative to projectRoot. Configuration: %O",
      {
        projectRoot: config.projectRoot,
        specPattern,
        configSpecPattern: config.specPattern,
        excludeSpecPattern: [
          config.excludeSpecPattern,
          config.additionalIgnorePattern
        ].flat(2),
        testingType: params.testingType
      }
    );
  }
  return { specs, specPattern };
};
function getSpecPattern(configPattern, explicit) {
  return explicit || configPattern;
}

// lib/run.ts
var debug17 = Debug16("currents:run");
async function run(params = {}) {
  debug17("run params %o", params);
  params = preprocessParams(params);
  debug17("params after preprocess %o", params);
  if (isOffline(params)) {
    info(`Skipping cloud orchestration because --record is set to false`);
    return runBareCypress(params);
  }
  const validatedParams = validateParams(params);
  setAPIBaseUrl(validatedParams.cloudServiceUrl);
  const {
    recordKey,
    projectId,
    group,
    parallel,
    ciBuildId,
    tag,
    testingType,
    batchSize,
    autoCancelAfterFailures
  } = validatedParams;
  const config = await getMergedConfig(validatedParams);
  const { specs, specPattern } = await getSpecFiles({
    config,
    params: validatedParams
  });
  if (specs.length === 0) {
    return;
  }
  const platform2 = await getPlatform({
    config,
    browser: validatedParams.browser
  });
  divider();
  info("Discovered %d spec files", specs.length);
  info(
    `Tags: ${tag.length > 0 ? tag.join(",") : false}; Group: ${group ?? false}; Parallel: ${parallel ?? false}; Batch Size: ${batchSize}`
  );
  info("Connecting to cloud orchestration service...");
  const run2 = await createRun({
    ci: getCI(ciBuildId),
    specs: specs.map((spec) => spec.relative),
    commit: await getGitInfo(config.projectRoot),
    group,
    platform: platform2,
    parallel: parallel ?? false,
    ciBuildId,
    projectId,
    recordKey,
    specPattern: [specPattern].flat(2),
    tags: tag,
    testingType,
    batchSize,
    autoCancelAfterFailures
  });
  info("\u{1F3A5} Run URL:", bold(run2.runUrl));
  setRunId(run2.runId);
  cutInitialOutput();
  await runTillDoneOrCancelled(
    {
      runId: run2.runId,
      groupId: run2.groupId,
      machineId: run2.machineId,
      platform: platform2,
      config,
      specs
    },
    validatedParams
  );
  divider();
  await Promise.allSettled(uploadTasks);
  const _summary = summarizeTestResults(Object.values(summary), config);
  title("white", "Cloud Run Finished");
  console.log(summaryTable(_summary));
  info("\u{1F3C1} Recorded Run:", bold(run2.runUrl));
  spacer();
  if (_summary.status === "finished") {
    return {
      ..._summary,
      runUrl: run2.runUrl
    };
  }
  return _summary;
}

// bin/lib/index.ts
init_esm_shims();

// bin/lib/cli.ts
init_esm_shims();
import Debug17 from "debug";

// bin/lib/parser.ts
init_esm_shims();
import _11 from "lodash";
import assert from "node:assert";
var nestedObjectsInCurlyBracesRe = /\{(.+?)\}/g;
var nestedArraysInSquareBracketsRe = /\[(.+?)\]/g;
var everythingAfterFirstEqualRe = /=(.*)/;
var sanitizeAndConvertNestedArgs = (str, argName) => {
  if (!str) {
    return;
  }
  assert(_11.isString(argName) && argName.trim() !== "");
  try {
    if (typeof str === "object") {
      return str;
    }
    const parsed = tryJSONParse(str);
    if (parsed) {
      return parsed;
    }
    return _11.chain(str).replace(nestedObjectsInCurlyBracesRe, commasToPipes).replace(nestedArraysInSquareBracketsRe, commasToPipes).split(",").map((pair) => {
      return pair.split(everythingAfterFirstEqualRe);
    }).fromPairs().mapValues(JSONOrCoerce).value();
  } catch (err) {
    error("could not parse CLI option '%s' value: %s", argName, str);
    error("error %o", err);
    return void 0;
  }
};
var tryJSONParse = (str) => {
  try {
    return JSON.parse(str) === Infinity ? null : JSON.parse(str);
  } catch (err) {
    return null;
  }
};
var commasToPipes = (match) => {
  return match.split(",").join("|");
};
var pipesToCommas = (str) => {
  return str.split("|").join(",");
};
var JSONOrCoerce = (str) => {
  const parsed = tryJSONParse(str);
  if (parsed) {
    return parsed;
  }
  str = pipesToCommas(str);
  const parsed2 = tryJSONParse(str);
  if (parsed2) {
    return parsed2;
  }
  return coerce(str);
};
var coerce = (value) => {
  const num = _11.toNumber(value);
  if (_11.invoke(num, "toString") === value) {
    return num;
  }
  const bool = toBoolean(value);
  if (_11.invoke(bool, "toString") === value) {
    return bool;
  }
  const obj = tryJSONParse(value);
  if (obj && typeof obj === "object") {
    return obj;
  }
  const arr = _11.toArray(value);
  if (_11.invoke(arr, "toString") === value) {
    return arr;
  }
  return value;
};
var toBoolean = (value) => {
  switch (value) {
    case "true":
      return true;
    case "false":
      return false;
    default:
      return value;
  }
};

// bin/lib/program.ts
init_esm_shims();
var import_extra_typings = __toESM(require_extra_typings());
var createProgram = (command = new import_extra_typings.Command()) => command.name("cypress-cloud").description(
  "Runs Cypress tests on CI using Currents as an orchestration and reporting service"
).option(
  "-b, --browser <browser-name-or-path>",
  "runs Cypress in the browser with the given name; if a filesystem path is supplied, Cypress will attempt to use the browser at that path"
).option(
  "--ci-build-id <id>",
  "the unique identifier for a run, this value is automatically detected for most CI providers"
).addOption(
  new import_extra_typings.Option("--component", "runs Cypress component test").default(false).implies({
    e2e: false
  })
).option(
  "-c, --config <config>",
  "sets Cypress configuration values. separate multiple values with a comma. overrides any value in cypress.config.{js,ts,mjs,cjs}"
).option(
  "-e, --env <env>",
  "sets environment variables. separate multiple values with a comma. overrides any value in cypress.config.{js,ts,mjs,cjs} or cypress.env.json"
).option(
  "-C, --config-file <config-file>",
  'specify Cypress config file, path to script file where Cypress configuration values are set. defaults to "cypress.config.{js,ts,mjs,cjs}"'
).addOption(new import_extra_typings.Option("--e2e", "runs end to end tests").default(true)).option("--group <name>", "a named group for recorded runs in Currents").addOption(
  new import_extra_typings.Option(
    "-k, --key <record-key>",
    "your secret Record Key obtained from Currents. you can omit this if you set a CURRENTS_RECORD_KEY environment variable"
  ).env("CURRENTS_RECORD_KEY")
).option(
  "--parallel",
  "enables concurrent runs and automatic load balancing of specs across multiple machines or processes",
  false
).addOption(
  new import_extra_typings.Option(
    "-p, --port <number>",
    "runs Cypress on a specific port. overrides any value in cypress.config.{js,ts,mjs,cjs}"
  ).argParser((i) => parseInt(i, 10))
).option(
  "-P, --project <project-path>",
  "path to your Cypress project root location - defaults to the current working directory"
).option("-q, --quiet", "suppress verbose output from Cypress").addOption(
  new import_extra_typings.Option(
    "--record [bool]",
    "records the run and sends test results, screenshots and videos to Currents"
  ).default(true).argParser((i) => i === "false" ? false : true)
).option(
  "-r, --reporter <reporter>",
  'use a specific mocha reporter for Cypress, pass a path to use a custom reporter, defaults to "spec"'
).option(
  "-o, --reporter-options <reporter-options>",
  'options for the mocha reporter. defaults to "null"'
).addOption(
  new import_extra_typings.Option(
    "-s, --spec <spec-pattern>",
    'define specific glob pattern for running the spec file(s), Defaults to the "specMatch" entry from the "cypress.config.{js,ts,mjs,cjs}" file'
  ).argParser(parseCommaSeparatedList)
).option(
  "-t, --tag <tag>",
  "comma-separated tag(s) for recorded runs in Currents",
  parseCommaSeparatedList
).addOption(
  new import_extra_typings.Option(
    "--auto-cancel-after-failures <number | false>",
    "Automatically abort the run after the specified number of failed tests. Overrides the default project settings. If set, must be a positive integer or 'false' to disable (Currents-only)"
  ).argParser(parseAutoCancelFailures)
);
var program = createProgram();
function parseCommaSeparatedList(value, previous = []) {
  if (value) {
    return previous.concat(value.split(",").map((t) => t.trim()));
  }
  return previous;
}
function parseAutoCancelFailures(value) {
  if (value === "false") {
    return false;
  }
  const parsedValue = parseInt(value, 10);
  if (isNaN(parsedValue) || parsedValue < 1) {
    throw new Error(
      "Invalid argument provided. Must be a positive integer or 'false'."
    );
  }
  return parsedValue;
}

// bin/lib/cli.ts
var debug18 = Debug17("currents:cli");
function parseCLIOptions(_program = program, ...args) {
  _program.parse(...args);
  debug18("parsed CLI flags %o", _program.opts());
  const { e2e, component } = _program.opts();
  if (e2e && component) {
    _program.error("Cannot use both e2e and component options");
  }
  return getRunParametersFromCLI(_program.opts());
}
function getRunParametersFromCLI(cliOptions) {
  const { component, e2e, ...restOptions } = cliOptions;
  const testingType = component ? "component" : "e2e";
  const result = {
    ...restOptions,
    config: sanitizeAndConvertNestedArgs(cliOptions.config, "config"),
    env: sanitizeAndConvertNestedArgs(cliOptions.env, "env"),
    reporterOptions: sanitizeAndConvertNestedArgs(
      cliOptions.reporterOptions,
      "reporterOptions"
    ),
    testingType,
    recordKey: cliOptions.key
  };
  debug18("parsed run params: %o", result);
  return result;
}

// bin/cli.ts
async function main() {
  return run(parseCLIOptions());
}
main().then((result) => {
  if (!result) {
    process.exit(0);
  }
  if (result.status === "failed") {
    process.exit(1);
  }
  const overallFailed = result.totalFailed + result.totalSkipped;
  if (overallFailed > 0) {
    process.exit(overallFailed);
  }
  process.exit(0);
}).catch((err) => {
  if (err instanceof ValidationError) {
    program.error(withError(err.toString()));
  } else {
    console.error(err);
  }
  process.exit(1);
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RzdXAvYXNzZXRzL2VzbV9zaGltcy5qcyIsICIuLi8uLi9iaW4vbGliL0Bjb21tYW5kZXItanMvZXh0cmEtdHlwaW5ncy9pbmRleC5qcyIsICIuLi8uLi9iaW4vY2xpLnRzIiwgIi4uLy4uL2xpYi9lcnJvcnMudHMiLCAiLi4vLi4vbGliL2xvZy50cyIsICIuLi8uLi9saWIvcnVuLnRzIiwgIi4uLy4uL2xpYi9pbml0LnRzIiwgIi4uLy4uL2xpYi9yZXF1aXJlLnRzIiwgIi4uLy4uL2xpYi9zdGRvdXQudHMiLCAiLi4vLi4vbGliL3dzLnRzIiwgIi4uLy4uL2xpYi9jYXB0dXJlLnRzIiwgIi4uLy4uL2xpYi9odHRwQ2xpZW50L2luZGV4LnRzIiwgIi4uLy4uL2xpYi9odHRwQ2xpZW50L2NvbmZpZy50cyIsICIuLi8uLi9saWIvaHR0cENsaWVudC9odHRwQ2xpZW50LnRzIiwgIi4uLy4uL2xpYi9odHRwQ2xpZW50L3ByaW50RXJyb3JzLnRzIiwgIi4uLy4uL2xpYi9hcGkvaW5kZXgudHMiLCAiLi4vLi4vbGliL2FwaS9hcGkudHMiLCAiLi4vLi4vbGliL2FwaS93YXJuaW5ncy50cyIsICIuLi8uLi9saWIvYXBpL3R5cGVzL2luZGV4LnRzIiwgIi4uLy4uL2xpYi9hcGkvdHlwZXMvaW5zdGFuY2UudHMiLCAiLi4vLi4vbGliL2FwaS90eXBlcy9ydW4udHMiLCAiLi4vLi4vbGliL2FwaS90eXBlcy90ZXN0LnRzIiwgIi4uLy4uL2xpYi9jaVByb3ZpZGVyLnRzIiwgIi4uLy4uL2xpYi9jb25maWcvaW5kZXgudHMiLCAiLi4vLi4vbGliL2NvbmZpZy9jb25maWcudHMiLCAiLi4vLi4vbGliL2Jvb3RzdHJhcC9pbmRleC50cyIsICIuLi8uLi9saWIvYm9vdHN0cmFwL2Jvb3RzdHJhcC50cyIsICIuLi8uLi9saWIvZnMudHMiLCAiLi4vLi4vbGliL2Jvb3RzdHJhcC9zZXJpYWxpemVyLnRzIiwgIi4uLy4uL2xpYi91dGlscy50cyIsICIuLi8uLi9saWIvY29uZmlnL3BhcmFtcy50cyIsICIuLi8uLi9saWIvY3lwcmVzcy9pbmRleC50cyIsICIuLi8uLi9saWIvY3lwcmVzcy9jeXByZXNzLnRzIiwgIi4uLy4uL2xpYi9naXQudHMiLCAiLi4vLi4vbGliL3BsYXRmb3JtL2luZGV4LnRzIiwgIi4uLy4uL2xpYi9wbGF0Zm9ybS9icm93c2VyLnRzIiwgIi4uLy4uL2xpYi9wbGF0Zm9ybS9wbGF0Zm9ybS50cyIsICIuLi8uLi9saWIvcmVzdWx0cy9pbmRleC50cyIsICIuLi8uLi9saWIvcmVzdWx0cy9yZXN1bHRzLnRzIiwgIi4uLy4uL2xpYi9yZXN1bHRzL3RhYmxlLnRzIiwgIi4uLy4uL2xpYi9yZXN1bHRzL3VwbG9hZFJlc3VsdHMudHMiLCAiLi4vLi4vbGliL2FydGlmYWN0cy50cyIsICIuLi8uLi9saWIvbGFuZy50cyIsICIuLi8uLi9saWIvdXBsb2FkLnRzIiwgIi4uLy4uL2xpYi9lbnYudHMiLCAiLi4vLi4vbGliL3N0YXRlLnRzIiwgIi4uLy4uL2xpYi9wdWJzdWIudHMiLCAiLi4vLi4vbGliL3J1bm5lci9pbmRleC50cyIsICIuLi8uLi9saWIvcnVubmVyL2NhbmNlbGxhYmxlLnRzIiwgIi4uLy4uL2xpYi9ydW5uZXIvcnVubmVyLnRzIiwgIi4uLy4uL2xpYi9ydW5uZXIvc3RhdGUudHMiLCAiLi4vLi4vbGliL3NwZWNNYXRjaGVyL2luZGV4LnRzIiwgIi4uLy4uL2xpYi9zcGVjTWF0Y2hlci9nZXRTcGVjRmlsZXMudHMiLCAiLi4vLi4vbGliL3NwZWNNYXRjaGVyL3NwZWNNYXRjaGVyLnRzIiwgIi4uLy4uL2Jpbi9saWIvaW5kZXgudHMiLCAiLi4vLi4vYmluL2xpYi9jbGkudHMiLCAiLi4vLi4vYmluL2xpYi9wYXJzZXIudHMiLCAiLi4vLi4vYmluL2xpYi9wcm9ncmFtLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLyBTaGltIGdsb2JhbHMgaW4gZXNtIGJ1bmRsZVxuaW1wb3J0IHsgZmlsZVVSTFRvUGF0aCB9IGZyb20gJ3VybCdcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnXG5cbmNvbnN0IGdldEZpbGVuYW1lID0gKCkgPT4gZmlsZVVSTFRvUGF0aChpbXBvcnQubWV0YS51cmwpXG5jb25zdCBnZXREaXJuYW1lID0gKCkgPT4gcGF0aC5kaXJuYW1lKGdldEZpbGVuYW1lKCkpXG5cbmV4cG9ydCBjb25zdCBfX2Rpcm5hbWUgPSAvKiBAX19QVVJFX18gKi8gZ2V0RGlybmFtZSgpXG5leHBvcnQgY29uc3QgX19maWxlbmFtZSA9IC8qIEBfX1BVUkVfXyAqLyBnZXRGaWxlbmFtZSgpXG4iLCAiY29uc3QgY29tbWFuZGVyID0gcmVxdWlyZShcImNvbW1hbmRlclwiKTtcblxuLy8gQHRzLWNoZWNrXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBSZXR1cm4gYSBkaWZmZXJlbnQgZ2xvYmFsIHByb2dyYW0gdGhhbiBjb21tYW5kZXIsXG4vLyBhbmQgZG9uJ3QgYWxzbyByZXR1cm4gaXQgYXMgZGVmYXVsdCBleHBvcnQuXG5leHBvcnRzLnByb2dyYW0gPSBuZXcgY29tbWFuZGVyLkNvbW1hbmQoKTtcblxuLyoqXG4gKiBFeHBvc2UgY2xhc3Nlcy4gVGhlIEZvb1QgdmVyc2lvbnMgYXJlIGp1c3QgdHlwZXMsIHNvIHJldHVybiBDb21tYW5kZXIgb3JpZ2luYWwgaW1wbGVtZW50YXRpb25zIVxuICovXG5cbmV4cG9ydHMuQXJndW1lbnQgPSBjb21tYW5kZXIuQXJndW1lbnQ7XG5leHBvcnRzLkNvbW1hbmQgPSBjb21tYW5kZXIuQ29tbWFuZDtcbmV4cG9ydHMuQ29tbWFuZGVyRXJyb3IgPSBjb21tYW5kZXIuQ29tbWFuZGVyRXJyb3I7XG5leHBvcnRzLkhlbHAgPSBjb21tYW5kZXIuSGVscDtcbmV4cG9ydHMuSW52YWxpZEFyZ3VtZW50RXJyb3IgPSBjb21tYW5kZXIuSW52YWxpZEFyZ3VtZW50RXJyb3I7XG5leHBvcnRzLkludmFsaWRPcHRpb25Bcmd1bWVudEVycm9yID0gY29tbWFuZGVyLkludmFsaWRBcmd1bWVudEVycm9yOyAvLyBEZXByZWNhdGVkXG5leHBvcnRzLk9wdGlvbiA9IGNvbW1hbmRlci5PcHRpb247XG5cbi8vIEluIENvbW1hbmRlciwgdGhlIGNyZWF0ZSByb3V0aW5lcyBlbmQgdXAgYmVpbmcgYWxpYXNlcyBmb3IgdGhlIG1hdGNoaW5nXG4vLyBtZXRob2RzIG9uIHRoZSBnbG9iYWwgcHJvZ3JhbSBkdWUgdG8gdGhlIChkZXByZWNhdGVkKSBsZWdhY3kgZGVmYXVsdCBleHBvcnQuXG4vLyBIZXJlIHdlIHJvbGwgb3VyIG93biwgdGhlIHdheSBDb21tYW5kZXIgbWlnaHQgaW4gZnV0dXJlLlxuZXhwb3J0cy5jcmVhdGVDb21tYW5kID0gKG5hbWUpID0+IG5ldyBjb21tYW5kZXIuQ29tbWFuZChuYW1lKTtcbmV4cG9ydHMuY3JlYXRlT3B0aW9uID0gKGZsYWdzLCBkZXNjcmlwdGlvbikgPT5cbiAgbmV3IGNvbW1hbmRlci5PcHRpb24oZmxhZ3MsIGRlc2NyaXB0aW9uKTtcbmV4cG9ydHMuY3JlYXRlQXJndW1lbnQgPSAobmFtZSwgZGVzY3JpcHRpb24pID0+XG4gIG5ldyBjb21tYW5kZXIuQXJndW1lbnQobmFtZSwgZGVzY3JpcHRpb24pO1xuIiwgIiMhL3Vzci9iaW4vZW52IG5vZGVcbmltcG9ydCBcInNvdXJjZS1tYXAtc3VwcG9ydC9yZWdpc3RlclwiO1xuXG5pbXBvcnQgeyBWYWxpZGF0aW9uRXJyb3IgfSBmcm9tIFwiLi4vbGliL2Vycm9yc1wiO1xuaW1wb3J0IHsgd2l0aEVycm9yIH0gZnJvbSBcIi4uL2xpYi9sb2dcIjtcbmltcG9ydCB7IHJ1biB9IGZyb20gXCIuLi9saWIvcnVuXCI7XG5pbXBvcnQgeyBwYXJzZUNMSU9wdGlvbnMsIHByb2dyYW0gfSBmcm9tIFwiLi9saWJcIjtcblxuYXN5bmMgZnVuY3Rpb24gbWFpbigpIHtcbiAgcmV0dXJuIHJ1bihwYXJzZUNMSU9wdGlvbnMoKSk7XG59XG5cbm1haW4oKVxuICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHByb2Nlc3MuZXhpdCgwKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICB9XG5cbiAgICBjb25zdCBvdmVyYWxsRmFpbGVkID0gcmVzdWx0LnRvdGFsRmFpbGVkICsgcmVzdWx0LnRvdGFsU2tpcHBlZDtcbiAgICBpZiAob3ZlcmFsbEZhaWxlZCA+IDApIHtcbiAgICAgIHByb2Nlc3MuZXhpdChvdmVyYWxsRmFpbGVkKTtcbiAgICB9XG4gICAgcHJvY2Vzcy5leGl0KDApO1xuICB9KVxuICAuY2F0Y2goKGVycikgPT4ge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBWYWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgIHByb2dyYW0uZXJyb3Iod2l0aEVycm9yKGVyci50b1N0cmluZygpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9XG4gICAgcHJvY2Vzcy5leGl0KDEpO1xuICB9KTtcbiIsICJleHBvcnQgY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICB9XG59XG4iLCAiaW1wb3J0IGNoYWxrIGZyb20gXCJjaGFsa1wiO1xuaW1wb3J0IHV0aWwgZnJvbSBcInV0aWxcIjtcblxuY29uc3QgbG9nID0gKC4uLmFyZ3M6IHVua25vd25bXSkgPT4gY29uc29sZS5sb2codXRpbC5mb3JtYXQoLi4uYXJncykpO1xuXG5leHBvcnQgY29uc3QgaW5mbyA9IGxvZztcblxuZXhwb3J0IGNvbnN0IHdpdGhFcnJvciA9IChtc2c6IHN0cmluZykgPT5cbiAgY2hhbGsuYmdSZWQud2hpdGUoXCIgRVJST1IgXCIpICsgXCIgXCIgKyBtc2c7XG5leHBvcnQgY29uc3Qgd2l0aFdhcm5pbmcgPSAobXNnOiBzdHJpbmcpID0+XG4gIGNoYWxrLmJnWWVsbG93LmJsYWNrKFwiIFdBUk5JTkcgXCIpICsgXCIgXCIgKyBtc2c7XG5cbmV4cG9ydCBjb25zdCB3YXJuID0gKC4uLmFyZ3M6IHVua25vd25bXSkgPT5cbiAgbG9nKHdpdGhXYXJuaW5nKHV0aWwuZm9ybWF0KC4uLmFyZ3MpKSk7XG5cbmV4cG9ydCBjb25zdCBzdWNjZXNzID0gKC4uLmFyZ3M6IHVua25vd25bXSkgPT5cbiAgbG9nKGNoYWxrLmdyZWVuKHV0aWwuZm9ybWF0KC4uLmFyZ3MpKSk7XG5cbmV4cG9ydCBjb25zdCBlcnJvciA9ICguLi5hcmdzOiB1bmtub3duW10pID0+XG4gIGxvZyh3aXRoRXJyb3IodXRpbC5mb3JtYXQoLi4uYXJncykpICsgXCJcXG5cIik7XG5cbnR5cGUgQ29sb3IgPSBcInJlZFwiIHwgXCJncmVlblwiIHwgXCJ5ZWxsb3dcIiB8IFwiYmx1ZVwiIHwgXCJtYWdlbnRhXCIgfCBcImN5YW5cIiB8IFwid2hpdGVcIjtcbmV4cG9ydCBjb25zdCB0aXRsZSA9IChjb2xvcjogQ29sb3IsIC4uLmFyZ3M6IHVua25vd25bXSkgPT5cbiAgaW5mbyhcIlxcblwiICsgXCIgIFwiICsgY2hhbGtbY29sb3JdLmJvbGQodXRpbC5mb3JtYXQoLi4uYXJncykpICsgXCIgIFwiICsgXCJcXG5cIik7XG5cbmV4cG9ydCBjb25zdCBkaXZpZGVyID0gKCkgPT5cbiAgY29uc29sZS5sb2coXCJcXG5cIiArIGNoYWxrLmdyYXkoQXJyYXkoMTAwKS5maWxsKFwiPVwiKS5qb2luKFwiXCIpKSArIFwiXFxuXCIpO1xuXG5leHBvcnQgY29uc3Qgc3BhY2VyID0gKG46IG51bWJlciA9IDApID0+XG4gIGNvbnNvbGUubG9nKEFycmF5KG4pLmZpbGwoXCJcIikuam9pbihcIlxcblwiKSk7XG5cbmV4cG9ydCBjb25zdCBjeWFuID0gY2hhbGsuY3lhbjtcbmV4cG9ydCBjb25zdCBibHVlID0gY2hhbGsuYmx1ZUJyaWdodDtcbmV4cG9ydCBjb25zdCByZWQgPSBjaGFsay5yZWQ7XG5leHBvcnQgY29uc3QgZ3JlZW4gPSBjaGFsay5ncmVlbkJyaWdodDtcbmV4cG9ydCBjb25zdCBncmF5ID0gY2hhbGsuZ3JheTtcbmV4cG9ydCBjb25zdCB3aGl0ZSA9IGNoYWxrLndoaXRlO1xuZXhwb3J0IGNvbnN0IG1hZ2VudGEgPSBjaGFsay5tYWdlbnRhO1xuZXhwb3J0IGNvbnN0IGJvbGQgPSBjaGFsay5ib2xkO1xuIiwgImltcG9ydCBcIi4vaW5pdFwiO1xuXG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBDdXJyZW50c1J1blBhcmFtZXRlcnMgfSBmcm9tIFwiLi4vdHlwZXNcIjtcbmltcG9ydCB7IGNyZWF0ZVJ1biB9IGZyb20gXCIuL2FwaVwiO1xuaW1wb3J0IHsgY3V0SW5pdGlhbE91dHB1dCB9IGZyb20gXCIuL2NhcHR1cmVcIjtcbmltcG9ydCB7IGdldENJIH0gZnJvbSBcIi4vY2lQcm92aWRlclwiO1xuaW1wb3J0IHtcbiAgZ2V0TWVyZ2VkQ29uZmlnLFxuICBpc09mZmxpbmUsXG4gIHByZXByb2Nlc3NQYXJhbXMsXG4gIHZhbGlkYXRlUGFyYW1zLFxufSBmcm9tIFwiLi9jb25maWdcIjtcbmltcG9ydCB7IHJ1bkJhcmVDeXByZXNzIH0gZnJvbSBcIi4vY3lwcmVzc1wiO1xuaW1wb3J0IHsgZ2V0R2l0SW5mbyB9IGZyb20gXCIuL2dpdFwiO1xuaW1wb3J0IHsgc2V0QVBJQmFzZVVybCwgc2V0UnVuSWQgfSBmcm9tIFwiLi9odHRwQ2xpZW50XCI7XG5pbXBvcnQgeyBib2xkLCBkaXZpZGVyLCBpbmZvLCBzcGFjZXIsIHRpdGxlIH0gZnJvbSBcIi4vbG9nXCI7XG5pbXBvcnQgeyBnZXRQbGF0Zm9ybSB9IGZyb20gXCIuL3BsYXRmb3JtXCI7XG5pbXBvcnQgeyBzdW1tYXJpemVUZXN0UmVzdWx0cywgc3VtbWFyeVRhYmxlIH0gZnJvbSBcIi4vcmVzdWx0c1wiO1xuaW1wb3J0IHsgcnVuVGlsbERvbmVPckNhbmNlbGxlZCwgc3VtbWFyeSwgdXBsb2FkVGFza3MgfSBmcm9tIFwiLi9ydW5uZXJcIjtcbmltcG9ydCB7IGdldFNwZWNGaWxlcyB9IGZyb20gXCIuL3NwZWNNYXRjaGVyXCI7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpydW5cIik7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBydW4ocGFyYW1zOiBDdXJyZW50c1J1blBhcmFtZXRlcnMgPSB7fSkge1xuICBkZWJ1ZyhcInJ1biBwYXJhbXMgJW9cIiwgcGFyYW1zKTtcbiAgcGFyYW1zID0gcHJlcHJvY2Vzc1BhcmFtcyhwYXJhbXMpO1xuICBkZWJ1ZyhcInBhcmFtcyBhZnRlciBwcmVwcm9jZXNzICVvXCIsIHBhcmFtcyk7XG5cbiAgaWYgKGlzT2ZmbGluZShwYXJhbXMpKSB7XG4gICAgaW5mbyhgU2tpcHBpbmcgY2xvdWQgb3JjaGVzdHJhdGlvbiBiZWNhdXNlIC0tcmVjb3JkIGlzIHNldCB0byBmYWxzZWApO1xuICAgIHJldHVybiBydW5CYXJlQ3lwcmVzcyhwYXJhbXMpO1xuICB9XG4gIGNvbnN0IHZhbGlkYXRlZFBhcmFtcyA9IHZhbGlkYXRlUGFyYW1zKHBhcmFtcyk7XG4gIHNldEFQSUJhc2VVcmwodmFsaWRhdGVkUGFyYW1zLmNsb3VkU2VydmljZVVybCk7XG5cbiAgY29uc3Qge1xuICAgIHJlY29yZEtleSxcbiAgICBwcm9qZWN0SWQsXG4gICAgZ3JvdXAsXG4gICAgcGFyYWxsZWwsXG4gICAgY2lCdWlsZElkLFxuICAgIHRhZyxcbiAgICB0ZXN0aW5nVHlwZSxcbiAgICBiYXRjaFNpemUsXG4gICAgYXV0b0NhbmNlbEFmdGVyRmFpbHVyZXMsXG4gIH0gPSB2YWxpZGF0ZWRQYXJhbXM7XG5cbiAgY29uc3QgY29uZmlnID0gYXdhaXQgZ2V0TWVyZ2VkQ29uZmlnKHZhbGlkYXRlZFBhcmFtcyk7XG4gIGNvbnN0IHsgc3BlY3MsIHNwZWNQYXR0ZXJuIH0gPSBhd2FpdCBnZXRTcGVjRmlsZXMoe1xuICAgIGNvbmZpZyxcbiAgICBwYXJhbXM6IHZhbGlkYXRlZFBhcmFtcyxcbiAgfSk7XG5cbiAgaWYgKHNwZWNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHBsYXRmb3JtID0gYXdhaXQgZ2V0UGxhdGZvcm0oe1xuICAgIGNvbmZpZyxcbiAgICBicm93c2VyOiB2YWxpZGF0ZWRQYXJhbXMuYnJvd3NlcixcbiAgfSk7XG5cbiAgZGl2aWRlcigpO1xuXG4gIGluZm8oXCJEaXNjb3ZlcmVkICVkIHNwZWMgZmlsZXNcIiwgc3BlY3MubGVuZ3RoKTtcbiAgaW5mbyhcbiAgICBgVGFnczogJHt0YWcubGVuZ3RoID4gMCA/IHRhZy5qb2luKFwiLFwiKSA6IGZhbHNlfTsgR3JvdXA6ICR7XG4gICAgICBncm91cCA/PyBmYWxzZVxuICAgIH07IFBhcmFsbGVsOiAke3BhcmFsbGVsID8/IGZhbHNlfTsgQmF0Y2ggU2l6ZTogJHtiYXRjaFNpemV9YFxuICApO1xuICBpbmZvKFwiQ29ubmVjdGluZyB0byBjbG91ZCBvcmNoZXN0cmF0aW9uIHNlcnZpY2UuLi5cIik7XG5cbiAgY29uc3QgcnVuID0gYXdhaXQgY3JlYXRlUnVuKHtcbiAgICBjaTogZ2V0Q0koY2lCdWlsZElkKSxcbiAgICBzcGVjczogc3BlY3MubWFwKChzcGVjKSA9PiBzcGVjLnJlbGF0aXZlKSxcbiAgICBjb21taXQ6IGF3YWl0IGdldEdpdEluZm8oY29uZmlnLnByb2plY3RSb290KSxcbiAgICBncm91cCxcbiAgICBwbGF0Zm9ybSxcbiAgICBwYXJhbGxlbDogcGFyYWxsZWwgPz8gZmFsc2UsXG4gICAgY2lCdWlsZElkLFxuICAgIHByb2plY3RJZCxcbiAgICByZWNvcmRLZXksXG4gICAgc3BlY1BhdHRlcm46IFtzcGVjUGF0dGVybl0uZmxhdCgyKSxcbiAgICB0YWdzOiB0YWcsXG4gICAgdGVzdGluZ1R5cGUsXG4gICAgYmF0Y2hTaXplLFxuICAgIGF1dG9DYW5jZWxBZnRlckZhaWx1cmVzLFxuICB9KTtcblxuICBpbmZvKFwiXHVEODNDXHVERkE1IFJ1biBVUkw6XCIsIGJvbGQocnVuLnJ1blVybCkpO1xuXG4gIHNldFJ1bklkKHJ1bi5ydW5JZCk7XG5cbiAgY3V0SW5pdGlhbE91dHB1dCgpO1xuXG4gIGF3YWl0IHJ1blRpbGxEb25lT3JDYW5jZWxsZWQoXG4gICAge1xuICAgICAgcnVuSWQ6IHJ1bi5ydW5JZCxcbiAgICAgIGdyb3VwSWQ6IHJ1bi5ncm91cElkLFxuICAgICAgbWFjaGluZUlkOiBydW4ubWFjaGluZUlkLFxuICAgICAgcGxhdGZvcm0sXG4gICAgICBjb25maWcsXG4gICAgICBzcGVjcyxcbiAgICB9LFxuICAgIHZhbGlkYXRlZFBhcmFtc1xuICApO1xuXG4gIGRpdmlkZXIoKTtcblxuICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQodXBsb2FkVGFza3MpO1xuICBjb25zdCBfc3VtbWFyeSA9IHN1bW1hcml6ZVRlc3RSZXN1bHRzKE9iamVjdC52YWx1ZXMoc3VtbWFyeSksIGNvbmZpZyk7XG5cbiAgdGl0bGUoXCJ3aGl0ZVwiLCBcIkNsb3VkIFJ1biBGaW5pc2hlZFwiKTtcbiAgY29uc29sZS5sb2coc3VtbWFyeVRhYmxlKF9zdW1tYXJ5KSk7XG4gIGluZm8oXCJcdUQ4M0NcdURGQzEgUmVjb3JkZWQgUnVuOlwiLCBib2xkKHJ1bi5ydW5VcmwpKTtcblxuICBzcGFjZXIoKTtcbiAgaWYgKF9zdW1tYXJ5LnN0YXR1cyA9PT0gXCJmaW5pc2hlZFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLl9zdW1tYXJ5LFxuICAgICAgcnVuVXJsOiBydW4ucnVuVXJsLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIF9zdW1tYXJ5O1xufVxuIiwgImltcG9ydCB7IHJlcXVpcmUgfSBmcm9tIFwiLi4vbGliL3JlcXVpcmVcIjtcbmltcG9ydCBcIi4vc3Rkb3V0XCI7XG5pbXBvcnQgXCIuL3dzXCI7XG5cbmNvbnN0IGN5cHJlc3NQa2cgPSByZXF1aXJlKFwiY3lwcmVzcy9wYWNrYWdlLmpzb25cIik7XG5jb25zdCBwa2cgPSByZXF1aXJlKFwiY3lwcmVzcy1jbG91ZC9wYWNrYWdlLmpzb25cIik7XG5cbmltcG9ydCB7IGluaXRDYXB0dXJlIH0gZnJvbSBcIi4vY2FwdHVyZVwiO1xuaW1wb3J0IHsgc2V0Q3VycmVudHNWZXJzaW9uLCBzZXRDeXByZXNzVmVyc2lvbiB9IGZyb20gXCIuL2h0dHBDbGllbnRcIjtcblxuaW5pdENhcHR1cmUoKTtcbnNldEN5cHJlc3NWZXJzaW9uKGN5cHJlc3NQa2cudmVyc2lvbik7XG5zZXRDdXJyZW50c1ZlcnNpb24ocGtnLnZlcnNpb24pO1xuIiwgImltcG9ydCB7IGNyZWF0ZVJlcXVpcmUgfSBmcm9tIFwibW9kdWxlXCI7XG4vLyByZXF1aXJlcyBzaGltPXRydWUgaW4gcGFja2FnZS5qc29uXG5leHBvcnQgY29uc3QgcmVxdWlyZSA9IGNyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKTtcbiIsICJpbXBvcnQgY3AgZnJvbSBcImNoaWxkX3Byb2Nlc3NcIjtcbmNvbnN0IG9yZ2luYWwgPSBjcC5zcGF3bjtcblxuLy8gQHRzLWlnbm9yZVxuY3Auc3Bhd24gPSBmdW5jdGlvbiAoY29tbWFuZCwgYXJncywgb3B0aW9ucykge1xuICAvLyBAdHMtaWdub3JlXG4gIGlmIChjb21tYW5kLm1hdGNoKC9DeXByZXNzLykpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgcHJvY2VzcyA9IG9yZ2luYWwoY29tbWFuZCwgYXJncywge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIC8vIHVzaW5nIHBpcGUgZW5hYmxlcyBjYXB0dXJpbmcgc3Rkb3V0IGFuZCBzdGRlcnJcbiAgICAgIHN0ZGlvOiBbXCJwaXBlXCIsIFwicGlwZVwiLCBcInBpcGVcIl0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHByb2Nlc3M7XG4gIH1cblxuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiBvcmdpbmFsKGNvbW1hbmQsIGFyZ3MsIG9wdGlvbnMpO1xufTtcbiIsICIvLyBwbHVnIGZvciBmdXR1cmUgd2Vic29ja2V0IHNlcnZlclxuZXhwb3J0IHt9O1xuIiwgImltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpjYXB0dXJlXCIpO1xuXG5jb25zdCBfd3JpdGUgPSBwcm9jZXNzLnN0ZG91dC53cml0ZTtcbmNvbnN0IF9sb2cgPSBwcm9jZXNzLmxvZztcblxuZXhwb3J0IGNvbnN0IHJlc3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHJlc3RvcmUgdG8gdGhlIG9yaWdpbmFsc1xuICBwcm9jZXNzLnN0ZG91dC53cml0ZSA9IF93cml0ZTtcbiAgcHJvY2Vzcy5sb2cgPSBfbG9nO1xufTtcblxuY29uc3QgbG9nczogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+ID0ge307XG5cbmNvbnN0IHN0ZG91dCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoXCJjYXB0dXJpbmcgc3Rkb3V0XCIpO1xuICBsZXQgbG9nczogc3RyaW5nW10gPSBbXTtcblxuICAvLyBsYXppbHkgYmFja3VwIHdyaXRlIHRvIGVuYWJsZSBpbmplY3Rpb25cbiAgY29uc3QgeyB3cml0ZSB9ID0gcHJvY2Vzcy5zdGRvdXQ7XG4gIGNvbnN0IHsgbG9nIH0gPSBwcm9jZXNzO1xuXG4gIC8vIGVsZWN0cm9uIGFkZHMgYSBuZXcgcHJvY2Vzcy5sb2dcbiAgLy8gbWV0aG9kIGZvciB3aW5kb3dzIGluc3RlYWQgb2YgcHJvY2Vzcy5zdGRvdXQud3JpdGVcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2N5cHJlc3MtaW8vY3lwcmVzcy9pc3N1ZXMvOTc3XG4gIGlmIChsb2cpIHtcbiAgICBwcm9jZXNzLmxvZyA9IGZ1bmN0aW9uIChzdHI6IHN0cmluZykge1xuICAgICAgbG9ncy5wdXNoKHN0cik7XG5cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgIHJldHVybiBsb2cuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgcHJvY2Vzcy5zdGRvdXQud3JpdGUgPSBmdW5jdGlvbiAoc3RyOiBzdHJpbmcpIHtcbiAgICBsb2dzLnB1c2goc3RyKTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgcmV0dXJuIHdyaXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBsb2dzLmpvaW4oXCJcIik7XG4gICAgfSxcbiAgICBkYXRhOiBsb2dzLFxuICAgIHJlc3RvcmUsXG4gICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgIGRlYnVnKFwicmVzZXR0aW5nIGNhcHR1cmVkIHN0ZG91dFwiKTtcbiAgICAgIGxvZ3MgPSBbXTtcbiAgICB9LFxuICB9O1xufTtcblxubGV0IGluaXRpYWxPdXRwdXQ6IHN0cmluZyA9IFwiXCI7XG5sZXQgY2FwdHVyZWRPdXRwdXQ6IG51bGwgfCBSZXR1cm5UeXBlPHR5cGVvZiBzdGRvdXQ+ID0gbnVsbDtcblxuZXhwb3J0IGNvbnN0IGluaXRDYXB0dXJlID0gKCkgPT4gKGNhcHR1cmVkT3V0cHV0ID0gc3Rkb3V0KCkpO1xuXG5leHBvcnQgY29uc3QgY3V0SW5pdGlhbE91dHB1dCA9ICgpID0+IHtcbiAgaWYgKCFjYXB0dXJlZE91dHB1dCkgdGhyb3cgbmV3IEVycm9yKFwiY2FwdHVyZWRPdXRwdXQgaXMgbnVsbFwiKTtcbiAgaW5pdGlhbE91dHB1dCA9IGNhcHR1cmVkT3V0cHV0LnRvU3RyaW5nKCk7XG4gIGNhcHR1cmVkT3V0cHV0LnJlc2V0KCk7XG59O1xuZXhwb3J0IGNvbnN0IHJlc2V0Q2FwdHVyZSA9ICgpID0+IHtcbiAgaWYgKCFjYXB0dXJlZE91dHB1dCkgdGhyb3cgbmV3IEVycm9yKFwiY2FwdHVyZWRPdXRwdXQgaXMgbnVsbFwiKTtcbiAgY2FwdHVyZWRPdXRwdXQucmVzZXQoKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRDYXB0dXJlZE91dHB1dCA9ICgpID0+IHtcbiAgaWYgKCFjYXB0dXJlZE91dHB1dCkgdGhyb3cgbmV3IEVycm9yKFwiY2FwdHVyZWRPdXRwdXQgaXMgbnVsbFwiKTtcbiAgcmV0dXJuIGNhcHR1cmVkT3V0cHV0LnRvU3RyaW5nKCk7XG59O1xuZXhwb3J0IGNvbnN0IGdldEluaXRpYWxPdXRwdXQgPSAoKSA9PiBpbml0aWFsT3V0cHV0O1xuIiwgImV4cG9ydCAqIGZyb20gXCIuL2NvbmZpZ1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vaHR0cENsaWVudFwiO1xuIiwgImltcG9ydCB7IEF4aW9zRXJyb3IsIGlzQXhpb3NFcnJvciB9IGZyb20gXCJheGlvc1wiO1xuXG5leHBvcnQgY29uc3QgaXNSZXRyaWFibGVFcnJvciA9IChlcnI6IEF4aW9zRXJyb3IpOiBib29sZWFuID0+IHtcbiAgaWYgKCFpc0F4aW9zRXJyb3IoZXJyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZXJyLmNvZGUgPT09IFwiRUNPTk5SRUZVU0VEXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gISEoXG4gICAgZXJyPy5yZXNwb25zZT8uc3RhdHVzICYmXG4gICAgNTAwIDw9IGVyci5yZXNwb25zZS5zdGF0dXMgJiZcbiAgICBlcnIucmVzcG9uc2Uuc3RhdHVzIDwgNjAwXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0RGVsYXkgPSAoaTogbnVtYmVyKSA9PiBbMTUgKiAxMDAwLCAzMCAqIDEwMDAsIDYwICogMTAwMF1baSAtIDFdO1xuXG5sZXQgYmFzZVVSTCA9IFwiaHR0cHM6Ly9jeS5jdXJyZW50cy5kZXZcIjtcbmV4cG9ydCBjb25zdCBnZXRBUElCYXNlVXJsID0gKCkgPT4gYmFzZVVSTCA/PyBcImh0dHBzOi8vY3kuY3VycmVudHMuZGV2XCI7XG5leHBvcnQgY29uc3Qgc2V0QVBJQmFzZVVybCA9ICh1cmw/OiBzdHJpbmcpID0+XG4gIChiYXNlVVJMID0gdXJsID8/IFwiaHR0cHM6Ly9jeS5jdXJyZW50cy5kZXZcIik7XG4iLCAiaW1wb3J0IGF4aW9zLCB7XG4gIEF4aW9zRXJyb3IsXG4gIEF4aW9zSW5zdGFuY2UsXG4gIEF4aW9zUmVxdWVzdENvbmZpZyxcbiAgQXhpb3NSZXNwb25zZSxcbiAgUmF3QXhpb3NSZXF1ZXN0SGVhZGVycyxcbn0gZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQgYXhpb3NSZXRyeSBmcm9tIFwiYXhpb3MtcmV0cnlcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCBwcmV0dHlNaWxsaXNlY29uZHMgZnJvbSBcInByZXR0eS1tc1wiO1xuaW1wb3J0IHsgVmFsaWRhdGlvbkVycm9yIH0gZnJvbSBcIi4uL2Vycm9yc1wiO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IGdldEFQSUJhc2VVcmwsIGdldERlbGF5LCBpc1JldHJpYWJsZUVycm9yIH0gZnJvbSBcIi4vY29uZmlnXCI7XG5pbXBvcnQgeyBtYXliZVByaW50RXJyb3JzIH0gZnJvbSBcIi4vcHJpbnRFcnJvcnNcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOmFwaVwiKTtcblxuY29uc3QgTUFYX1JFVFJJRVMgPSAzO1xuXG5sZXQgX2NsaWVudDogQXhpb3NJbnN0YW5jZSB8IG51bGwgPSBudWxsO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xpZW50KCkge1xuICBpZiAoX2NsaWVudCkge1xuICAgIHJldHVybiBfY2xpZW50O1xuICB9XG4gIF9jbGllbnQgPSBheGlvcy5jcmVhdGUoe1xuICAgIGJhc2VVUkw6IGdldEFQSUJhc2VVcmwoKSxcbiAgfSk7XG5cbiAgX2NsaWVudC5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UoKGNvbmZpZykgPT4ge1xuICAgIGNvbnN0IGhlYWRlcnM6IFJhd0F4aW9zUmVxdWVzdEhlYWRlcnMgPSB7XG4gICAgICAuLi5jb25maWcuaGVhZGVycyxcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIFwieC1jeXByZXNzLXJlcXVlc3QtYXR0ZW1wdFwiOiBjb25maWdbXCJheGlvcy1yZXRyeVwiXT8ucmV0cnlDb3VudCA/PyAwLFxuICAgICAgXCJ4LWN5cHJlc3MtdmVyc2lvblwiOiBfY3lwcmVzc1ZlcnNpb24gPz8gXCIwLjAuMFwiLFxuICAgICAgXCJ4LWNjeS12ZXJzaW9uXCI6IF9jdXJyZW50c1ZlcnNpb24gPz8gXCIwLjAuMFwiLFxuICAgIH07XG4gICAgaWYgKF9ydW5JZCkge1xuICAgICAgaGVhZGVyc1tcIngtY3lwcmVzcy1ydW4taWRcIl0gPSBfcnVuSWQ7XG4gICAgfVxuICAgIGlmICghaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSkge1xuICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuICAgIH1cbiAgICBjb25zdCByZXEgPSB7XG4gICAgICAuLi5jb25maWcsXG4gICAgICBoZWFkZXJzLFxuICAgIH07XG5cbiAgICBkZWJ1ZyhcIm5ldHdvcmsgcmVxdWVzdDogJW9cIiwge1xuICAgICAgLi4uXy5waWNrKHJlcSwgXCJtZXRob2RcIiwgXCJ1cmxcIiwgXCJoZWFkZXJzXCIpLFxuICAgICAgZGF0YTogQnVmZmVyLmlzQnVmZmVyKHJlcS5kYXRhKSA/IFwiYnVmZmVyXCIgOiByZXEuZGF0YSxcbiAgICB9KTtcbiAgICByZXR1cm4gcmVxO1xuICB9KTtcblxuICBheGlvc1JldHJ5KF9jbGllbnQsIHtcbiAgICByZXRyaWVzOiBNQVhfUkVUUklFUyxcbiAgICByZXRyeUNvbmRpdGlvbjogaXNSZXRyaWFibGVFcnJvcixcbiAgICByZXRyeURlbGF5OiBnZXREZWxheSxcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgb25SZXRyeSxcbiAgfSk7XG4gIHJldHVybiBfY2xpZW50O1xufVxuXG5sZXQgX3J1bklkOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgY29uc3Qgc2V0UnVuSWQgPSAocnVuSWQ6IHN0cmluZykgPT4ge1xuICBfcnVuSWQgPSBydW5JZDtcbn07XG5cbmxldCBfY3lwcmVzc1ZlcnNpb246IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBjb25zdCBzZXRDeXByZXNzVmVyc2lvbiA9IChjeXByZXNzVmVyc2lvbjogc3RyaW5nKSA9PiB7XG4gIF9jeXByZXNzVmVyc2lvbiA9IGN5cHJlc3NWZXJzaW9uO1xufTtcblxubGV0IF9jdXJyZW50c1ZlcnNpb246IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBjb25zdCBzZXRDdXJyZW50c1ZlcnNpb24gPSAodjogc3RyaW5nKSA9PiB7XG4gIF9jdXJyZW50c1ZlcnNpb24gPSB2O1xufTtcblxuZnVuY3Rpb24gb25SZXRyeShcbiAgcmV0cnlDb3VudDogbnVtYmVyLFxuICBlcnI6IEF4aW9zRXJyb3I8eyBtZXNzYWdlOiBzdHJpbmc7IGVycm9ycz86IHN0cmluZ1tdIH0+LFxuICBfY29uZmlnOiBBeGlvc1JlcXVlc3RDb25maWdcbikge1xuICB3YXJuKFxuICAgIFwiTmV0d29yayByZXF1ZXN0IGZhaWxlZDogJyVzJy4gTmV4dCBhdHRlbXB0IGlzIGluICVzICglZC8lZCkuXCIsXG4gICAgZXJyLm1lc3NhZ2UsXG4gICAgcHJldHR5TWlsbGlzZWNvbmRzKGdldERlbGF5KHJldHJ5Q291bnQpKSxcbiAgICByZXRyeUNvdW50LFxuICAgIE1BWF9SRVRSSUVTXG4gICk7XG59XG5cbmV4cG9ydCBjb25zdCBtYWtlUmVxdWVzdCA9IDxUID0gYW55LCBEID0gYW55PihcbiAgY29uZmlnOiBBeGlvc1JlcXVlc3RDb25maWc8RD5cbikgPT4ge1xuICByZXR1cm4gZ2V0Q2xpZW50KCk8RCwgQXhpb3NSZXNwb25zZTxUPj4oY29uZmlnKVxuICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgIGRlYnVnKFwibmV0d29yayByZXNwb25zZTogJW9cIiwgXy5vbWl0KHJlcywgXCJyZXF1ZXN0XCIsIFwiY29uZmlnXCIpKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSlcbiAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBtYXliZVByaW50RXJyb3JzKGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgfSk7XG59O1xuIiwgImltcG9ydCB7IEF4aW9zRXJyb3IgfSBmcm9tIFwiYXhpb3NcIjtcbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCB7IHNwYWNlciwgd2FybiB9IGZyb20gXCIuLi9sb2dcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlUHJpbnRFcnJvcnMoXG4gIGVycjogQXhpb3NFcnJvcjx7IG1lc3NhZ2U6IHN0cmluZzsgZXJyb3JzPzogc3RyaW5nW10gfT5cbikge1xuICBpZiAoIWVyci5yZXNwb25zZT8uZGF0YSB8fCAhZXJyLnJlc3BvbnNlPy5zdGF0dXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB7IG1lc3NhZ2UsIGVycm9ycyB9ID0gZXJyLnJlc3BvbnNlLmRhdGE7XG5cbiAgc3dpdGNoIChlcnIucmVzcG9uc2Uuc3RhdHVzKSB7XG4gICAgY2FzZSA0MDE6XG4gICAgICB3YXJuKFwiUmVjZWl2ZWQgNDAxIFVuYXV0aG9yaXplZFwiKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDIyOlxuICAgICAgc3BhY2VyKDEpO1xuICAgICAgd2FybiguLi5mb3JtYXRHZW5lcmljRXJyb3IobWVzc2FnZSwgZXJyb3JzKSk7XG4gICAgICBzcGFjZXIoMSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEdlbmVyaWNFcnJvcihcbiAgbWVzc2FnZT86IHN0cmluZyxcbiAgZXJyb3JzPzogc3RyaW5nW11cbik6IHN0cmluZ1tdIHtcbiAgaWYgKCFfLmlzU3RyaW5nKG1lc3NhZ2UpKSB7XG4gICAgcmV0dXJuIFtcIlVuZXhwZWN0ZWQgZXJyb3IgZnJvbSB0aGUgY2xvdWQgc2VydmljZVwiXTtcbiAgfVxuXG4gIGlmIChlcnJvcnM/Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbbWVzc2FnZSBhcyBzdHJpbmddO1xuICB9XG4gIHJldHVybiBbXG4gICAgbWVzc2FnZSBhcyBzdHJpbmcsXG4gICAgYFxuJHsoZXJyb3JzID8/IFtdKS5tYXAoKGUpID0+IGAgIC0gJHtlfWApLmpvaW4oXCJcXG5cIil9XG5gLFxuICBdO1xufVxuIiwgImV4cG9ydCAqIGZyb20gXCIuL2FwaVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vdHlwZXNcIjtcbiIsICJpbXBvcnQgeyBtYWtlUmVxdWVzdCB9IGZyb20gXCIuLi9odHRwQ2xpZW50XCI7XG5pbXBvcnQge1xuICBDcmVhdGVJbnN0YW5jZUN5UGF5bG9hZCxcbiAgQ3JlYXRlSW5zdGFuY2VQYXlsb2FkLFxuICBDcmVhdGVJbnN0YW5jZVJlc3BvbnNlLFxuICBDcmVhdGVJbnN0YW5jZXNSZXNwb25zZSxcbiAgQ3JlYXRlUnVuUGF5bG9hZCxcbiAgQ3JlYXRlUnVuUmVzcG9uc2UsXG4gIFNldEluc3RhbmNlVGVzdHNQYXlsb2FkLFxuICBVcGRhdGVJbnN0YW5jZVJlc3VsdHNNZXJnZWRQYXlsb2FkLFxuICBVcGRhdGVJbnN0YW5jZVJlc3VsdHNQYXlsb2FkLFxuICBVcGRhdGVJbnN0YW5jZVJlc3VsdHNSZXNwb25zZSxcbn0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IHByaW50V2FybmluZ3MgfSBmcm9tIFwiLi93YXJuaW5nc1wiO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUnVuID0gYXN5bmMgKHBheWxvYWQ6IENyZWF0ZVJ1blBheWxvYWQpID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtYWtlUmVxdWVzdDxDcmVhdGVSdW5SZXNwb25zZSwgQ3JlYXRlUnVuUGF5bG9hZD4oe1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgdXJsOiBcIi9ydW5zXCIsXG4gICAgZGF0YTogcGF5bG9hZCxcbiAgfSk7XG5cbiAgaWYgKChyZXNwb25zZS5kYXRhLndhcm5pbmdzPy5sZW5ndGggPz8gMCkgPiAwKSB7XG4gICAgcHJpbnRXYXJuaW5ncyhyZXNwb25zZS5kYXRhLndhcm5pbmdzKTtcbiAgfVxuXG4gIHJldHVybiByZXNwb25zZS5kYXRhO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUluc3RhbmNlID0gYXN5bmMgKHtcbiAgcnVuSWQsXG4gIGdyb3VwSWQsXG4gIG1hY2hpbmVJZCxcbiAgcGxhdGZvcm0sXG59OiBDcmVhdGVJbnN0YW5jZVBheWxvYWQpID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtYWtlUmVxdWVzdDxcbiAgICBDcmVhdGVJbnN0YW5jZVJlc3BvbnNlLFxuICAgIENyZWF0ZUluc3RhbmNlUGF5bG9hZFxuICA+KHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIHVybDogYHJ1bnMvJHtydW5JZH0vaW5zdGFuY2VzYCxcbiAgICBkYXRhOiB7XG4gICAgICBydW5JZCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICBtYWNoaW5lSWQsXG4gICAgICBwbGF0Zm9ybSxcbiAgICB9LFxuICB9KTtcblxuICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVCYXRjaGVkSW5zdGFuY2VzID0gYXN5bmMgKGRhdGE6IENyZWF0ZUluc3RhbmNlQ3lQYXlsb2FkKSA9PiB7XG4gIGNvbnN0IHJlc3BvbmUgPSBhd2FpdCBtYWtlUmVxdWVzdDxcbiAgICBDcmVhdGVJbnN0YW5jZXNSZXNwb25zZSxcbiAgICBDcmVhdGVJbnN0YW5jZUN5UGF5bG9hZFxuICA+KHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIHVybDogYHJ1bnMvJHtkYXRhLnJ1bklkfS9jeS9pbnN0YW5jZXNgLFxuICAgIGRhdGEsXG4gIH0pO1xuXG4gIHJldHVybiByZXNwb25lLmRhdGE7XG59O1xuXG5leHBvcnQgY29uc3Qgc2V0SW5zdGFuY2VUZXN0cyA9IChcbiAgaW5zdGFuY2VJZDogc3RyaW5nLFxuICBwYXlsb2FkOiBTZXRJbnN0YW5jZVRlc3RzUGF5bG9hZFxuKSA9PlxuICBtYWtlUmVxdWVzdDx7fSwgU2V0SW5zdGFuY2VUZXN0c1BheWxvYWQ+KHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIHVybDogYGluc3RhbmNlcy8ke2luc3RhbmNlSWR9L3Rlc3RzYCxcbiAgICBkYXRhOiBwYXlsb2FkLFxuICB9KS50aGVuKChyZXN1bHQpID0+IHJlc3VsdC5kYXRhKTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUluc3RhbmNlUmVzdWx0cyA9IChcbiAgaW5zdGFuY2VJZDogc3RyaW5nLFxuICBwYXlsb2FkOiBVcGRhdGVJbnN0YW5jZVJlc3VsdHNQYXlsb2FkXG4pID0+XG4gIG1ha2VSZXF1ZXN0PFVwZGF0ZUluc3RhbmNlUmVzdWx0c1Jlc3BvbnNlLCBVcGRhdGVJbnN0YW5jZVJlc3VsdHNQYXlsb2FkPih7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICB1cmw6IGBpbnN0YW5jZXMvJHtpbnN0YW5jZUlkfS9yZXN1bHRzYCxcbiAgICBkYXRhOiBwYXlsb2FkLFxuICB9KS50aGVuKChyZXN1bHQpID0+IHJlc3VsdC5kYXRhKTtcblxuZXhwb3J0IGNvbnN0IHJlcG9ydEluc3RhbmNlUmVzdWx0c01lcmdlZCA9IChcbiAgaW5zdGFuY2VJZDogc3RyaW5nLFxuICBwYXlsb2FkOiBVcGRhdGVJbnN0YW5jZVJlc3VsdHNNZXJnZWRQYXlsb2FkXG4pID0+XG4gIG1ha2VSZXF1ZXN0PFxuICAgIFVwZGF0ZUluc3RhbmNlUmVzdWx0c1Jlc3BvbnNlLFxuICAgIFVwZGF0ZUluc3RhbmNlUmVzdWx0c01lcmdlZFBheWxvYWRcbiAgPih7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICB1cmw6IGBpbnN0YW5jZXMvJHtpbnN0YW5jZUlkfS9jeS9yZXN1bHRzYCxcbiAgICBkYXRhOiBwYXlsb2FkLFxuICB9KS50aGVuKChyZXN1bHQpID0+IHJlc3VsdC5kYXRhKTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUluc3RhbmNlU3Rkb3V0ID0gKGluc3RhbmNlSWQ6IHN0cmluZywgc3Rkb3V0OiBzdHJpbmcpID0+XG4gIG1ha2VSZXF1ZXN0PGFueSwgeyBzdGRvdXQ6IHN0cmluZyB9Pih7XG4gICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgIHVybDogYGluc3RhbmNlcy8ke2luc3RhbmNlSWR9L3N0ZG91dGAsXG4gICAgZGF0YToge1xuICAgICAgc3Rkb3V0LFxuICAgIH0sXG4gIH0pO1xuIiwgImltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCB7IG1hZ2VudGEgfSBmcm9tIFwiLi4vbG9nXCI7XG5cbmltcG9ydCB7IGluZm8sIHNwYWNlciwgd2FybiB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IENsb3VkV2FybmluZyB9IGZyb20gXCIuL3R5cGVzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmludFdhcm5pbmdzKHdhcm5pbmdzOiBDbG91ZFdhcm5pbmdbXSkge1xuICB3YXJuKFwiTm90aWNlIGZyb20gY2xvdWQgc2VydmljZTpcIik7XG4gIHdhcm5pbmdzLm1hcCgodykgPT4ge1xuICAgIHNwYWNlcigxKTtcbiAgICBpbmZvKG1hZ2VudGEuYm9sZCh3Lm1lc3NhZ2UpKTtcbiAgICBPYmplY3QuZW50cmllcyhfLm9taXQodywgXCJtZXNzYWdlXCIpKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaW5mbyhcIi0gJXM6ICVzXCIsIGtleSwgdmFsdWUpO1xuICAgIH0pO1xuICAgIHNwYWNlcigxKTtcbiAgfSk7XG59XG4iLCAiZXhwb3J0ICogZnJvbSBcIi4vaW5zdGFuY2VcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3J1blwiO1xuZXhwb3J0ICogZnJvbSBcIi4vdGVzdFwiO1xuIiwgImltcG9ydCB7IFBsYXRmb3JtLCBTY3JlZW5zaG90QXJ0aWZhY3QgfSBmcm9tIFwiY3lwcmVzcy1jbG91ZC90eXBlc1wiO1xuaW1wb3J0IHsgU2V0VGVzdHNQYXlsb2FkLCBUZXN0IH0gZnJvbSBcIi4vdGVzdFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNjcmVlbnNob3Qge1xuICBzY3JlZW5zaG90SWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nIHwgbnVsbDtcbiAgdGVzdElkOiBzdHJpbmc7XG4gIHRha2VuQXQ6IHN0cmluZztcbiAgaGVpZ2h0OiBudW1iZXI7XG4gIHdpZHRoOiBudW1iZXI7XG4gIHNjcmVlbnNob3RVUkw6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbnN0YW5jZVJlc3VsdFN0YXRzIHtcbiAgc3VpdGVzOiBudW1iZXI7XG4gIHRlc3RzOiBudW1iZXI7XG4gIHBhc3NlczogbnVtYmVyO1xuICBwZW5kaW5nOiBudW1iZXI7XG4gIHNraXBwZWQ6IG51bWJlcjtcbiAgZmFpbHVyZXM6IG51bWJlcjtcbiAgd2FsbENsb2NrU3RhcnRlZEF0OiBzdHJpbmc7XG4gIHdhbGxDbG9ja0VuZGVkQXQ6IHN0cmluZztcbiAgd2FsbENsb2NrRHVyYXRpb246IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXBvcnRlclN0YXRzIHtcbiAgc3VpdGVzOiBudW1iZXI7XG4gIHRlc3RzOiBudW1iZXI7XG4gIHBhc3NlczogbnVtYmVyO1xuICBwZW5kaW5nOiBudW1iZXI7XG4gIGZhaWx1cmVzOiBudW1iZXI7XG4gIHN0YXJ0OiBzdHJpbmc7XG4gIGVuZDogc3RyaW5nO1xuICBkdXJhdGlvbjogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEN5cHJlc3NDb25maWcge1xuICB2aWRlbzogYm9vbGVhbjtcbiAgdmlkZW9VcGxvYWRPblBhc3NlczogYm9vbGVhbjtcbiAgW2tleTogc3RyaW5nXTogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluc3RhbmNlUmVzdWx0IHtcbiAgc3RhdHM6IEluc3RhbmNlUmVzdWx0U3RhdHM7XG4gIHRlc3RzOiBUZXN0W107XG4gIGVycm9yPzogc3RyaW5nO1xuICByZXBvcnRlclN0YXRzOiBSZXBvcnRlclN0YXRzO1xuICBleGNlcHRpb246IG51bGwgfCBzdHJpbmc7XG4gIGN5cHJlc3NDb25maWc/OiBQaWNrZWRDeXByZXNzQ29uZmlnIHwgbnVsbDtcbiAgc2NyZWVuc2hvdHM6IFNjcmVlbnNob3RbXTtcbiAgdmlkZW86IGJvb2xlYW47XG4gIHZpZGVvVXJsPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFzc2V0VXBsb2FkSW5zdHJ1Y3Rpb24ge1xuICB1cGxvYWRVcmw6IHN0cmluZztcbiAgcmVhZFVybDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNjcmVlbnNob3RVcGxvYWRJbnN0cnVjdGlvbiBleHRlbmRzIEFzc2V0VXBsb2FkSW5zdHJ1Y3Rpb24ge1xuICBzY3JlZW5zaG90SWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgU2V0UmVzdWx0c1Rlc3RzUGF5bG9hZCA9IFBpY2s8XG4gIFRlc3QsXG4gIFwic3RhdGVcIiB8IFwiZGlzcGxheUVycm9yXCIgfCBcImF0dGVtcHRzXCJcbj4gJiB7IGNsaWVudElkOiBzdHJpbmcgfTtcblxuZXhwb3J0IGludGVyZmFjZSBTZXRJbnN0YW5jZVRlc3RzUGF5bG9hZCB7XG4gIGNvbmZpZzogUGlja2VkQ3lwcmVzc0NvbmZpZztcbiAgdGVzdHM6IEFycmF5PFNldFRlc3RzUGF5bG9hZD47XG4gIGhvb2tzOiBDeXByZXNzQ29tbWFuZExpbmUuUnVuUmVzdWx0W1wiaG9va3NcIl07XG59XG5cbmV4cG9ydCB0eXBlIFBpY2tlZEN5cHJlc3NDb25maWcgPSBQaWNrPFxuICBDeXByZXNzQ29uZmlnLFxuICBcInZpZGVvXCIgfCBcInZpZGVvVXBsb2FkT25QYXNzZXNcIlxuPjtcblxuZXhwb3J0IHR5cGUgQ3JlYXRlSW5zdGFuY2VQYXlsb2FkID0ge1xuICBydW5JZDogc3RyaW5nO1xuICBncm91cElkOiBzdHJpbmc7XG4gIG1hY2hpbmVJZDogc3RyaW5nO1xuICBwbGF0Zm9ybTogUGxhdGZvcm07XG59O1xuXG5leHBvcnQgdHlwZSBDcmVhdGVJbnN0YW5jZUN5UGF5bG9hZCA9IENyZWF0ZUluc3RhbmNlUGF5bG9hZCAmIHtcbiAgYmF0Y2hTaXplOiBudW1iZXI7XG59O1xuZXhwb3J0IHR5cGUgQ3JlYXRlSW5zdGFuY2VSZXNwb25zZSA9IHtcbiAgc3BlYzogc3RyaW5nIHwgbnVsbDtcbiAgaW5zdGFuY2VJZDogc3RyaW5nIHwgbnVsbDtcbiAgY2xhaW1lZEluc3RhbmNlczogbnVtYmVyO1xuICB0b3RhbEluc3RhbmNlczogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgSW5zdGFuY2VSZXNwb25zZVNwZWNEZXRhaWxzID0ge1xuICBzcGVjOiBzdHJpbmc7XG4gIGluc3RhbmNlSWQ6IHN0cmluZztcbn07XG5leHBvcnQgdHlwZSBDcmVhdGVJbnN0YW5jZXNSZXNwb25zZSA9IHtcbiAgc3BlY3M6IEFycmF5PEluc3RhbmNlUmVzcG9uc2VTcGVjRGV0YWlscz47XG4gIGNsYWltZWRJbnN0YW5jZXM6IG51bWJlcjtcbiAgdG90YWxJbnN0YW5jZXM6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIFVwZGF0ZUluc3RhbmNlUmVzdWx0c1BheWxvYWQgPSBQaWNrPFxuICBJbnN0YW5jZVJlc3VsdCxcbiAgXCJzdGF0c1wiIHwgXCJleGNlcHRpb25cIiB8IFwidmlkZW9cIlxuPiAmIHtcbiAgdGVzdHM6IEFycmF5PFNldFJlc3VsdHNUZXN0c1BheWxvYWQ+IHwgbnVsbDtcbn0gJiB7XG4gIHJlcG9ydGVyU3RhdHM6IEN5cHJlc3NDb21tYW5kTGluZS5SdW5SZXN1bHRbXCJyZXBvcnRlclN0YXRzXCJdIHwgbnVsbDtcbn0gJiB7XG4gIHNjcmVlbnNob3RzOiBTY3JlZW5zaG90QXJ0aWZhY3RbXTtcbn07XG5cbmV4cG9ydCB0eXBlIFVwZGF0ZUluc3RhbmNlUmVzdWx0c01lcmdlZFBheWxvYWQgPSB7XG4gIHRlc3RzOiBTZXRJbnN0YW5jZVRlc3RzUGF5bG9hZDtcbiAgcmVzdWx0czogVXBkYXRlSW5zdGFuY2VSZXN1bHRzUGF5bG9hZDtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBkYXRlSW5zdGFuY2VSZXN1bHRzUmVzcG9uc2Uge1xuICB2aWRlb1VwbG9hZFVybD86IHN0cmluZyB8IG51bGw7XG4gIHNjcmVlbnNob3RVcGxvYWRVcmxzOiBTY3JlZW5zaG90VXBsb2FkSW5zdHJ1Y3Rpb25bXTtcbiAgY2xvdWQ/OiB7XG4gICAgc2hvdWxkQ2FuY2VsOiBmYWxzZSB8IHN0cmluZztcbiAgfTtcbn1cbiIsICJpbXBvcnQgeyBDaVBhcmFtcywgQ2lQcm92aWRlciB9IGZyb20gXCJjeXByZXNzLWNsb3VkL2xpYi9jaVByb3ZpZGVyXCI7XG5pbXBvcnQgeyBQbGF0Zm9ybSwgVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzIH0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcblxuZXhwb3J0IHR5cGUgQ3JlYXRlUnVuUGF5bG9hZCA9IHtcbiAgY2k6IHtcbiAgICBwYXJhbXM6IENpUGFyYW1zO1xuICAgIHByb3ZpZGVyOiBDaVByb3ZpZGVyO1xuICB9O1xuICBjaUJ1aWxkSWQ/OiBzdHJpbmc7XG4gIHByb2plY3RJZDogc3RyaW5nO1xuICByZWNvcmRLZXk6IHN0cmluZztcbiAgY29tbWl0OiB7XG4gICAgW21lbW9LZXk6IHN0cmluZ106IHN0cmluZyB8IG51bGw7XG4gIH07XG4gIHNwZWNzOiBzdHJpbmdbXTtcbiAgZ3JvdXA/OiBzdHJpbmc7XG4gIHBsYXRmb3JtOiBQbGF0Zm9ybTtcbiAgcGFyYWxsZWw6IGJvb2xlYW47XG4gIHNwZWNQYXR0ZXJuOiBzdHJpbmdbXTtcbiAgdGFncz86IHN0cmluZ1tdO1xuICB0ZXN0aW5nVHlwZTogXCJlMmVcIiB8IFwiY29tcG9uZW50XCI7XG4gIHRpbWVvdXQ/OiBudW1iZXI7XG4gIGJhdGNoU2l6ZT86IG51bWJlcjtcbiAgYXV0b0NhbmNlbEFmdGVyRmFpbHVyZXM6IFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVyc1tcImF1dG9DYW5jZWxBZnRlckZhaWx1cmVzXCJdO1xufTtcblxuZXhwb3J0IHR5cGUgQ2xvdWRXYXJuaW5nID0ge1xuICBtZXNzYWdlOiBzdHJpbmc7XG4gIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bWJlciB8IERhdGU7XG59O1xuXG5leHBvcnQgdHlwZSBDcmVhdGVSdW5SZXNwb25zZSA9IHtcbiAgd2FybmluZ3M6IENsb3VkV2FybmluZ1tdO1xuICBncm91cElkOiBzdHJpbmc7XG4gIG1hY2hpbmVJZDogc3RyaW5nO1xuICBydW5JZDogc3RyaW5nO1xuICBydW5Vcmw6IHN0cmluZztcbiAgaXNOZXdSdW46IGJvb2xlYW47XG59O1xuIiwgImV4cG9ydCBlbnVtIFRlc3RTdGF0ZSB7XG4gIEZhaWxlZCA9IFwiZmFpbGVkXCIsXG4gIFBhc3NlZCA9IFwicGFzc2VkXCIsXG4gIFBlbmRpbmcgPSBcInBlbmRpbmdcIixcbiAgU2tpcHBlZCA9IFwic2tpcHBlZFwiLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlc3RBdHRlbXB0IHtcbiAgc3RhdGU6IFRlc3RTdGF0ZTtcbiAgZXJyb3I6IEN5cHJlc3NDb21tYW5kTGluZS5UZXN0RXJyb3IgfCBudWxsO1xuICB3YWxsQ2xvY2tTdGFydGVkQXQ6IHN0cmluZyB8IG51bGw7XG4gIHdhbGxDbG9ja0R1cmF0aW9uOiBudW1iZXIgfCBudWxsO1xuICB2aWRlb1RpbWVzdGFtcDogbnVtYmVyIHwgbnVsbDtcbn1cblxuaW50ZXJmYWNlIFRlc3RDb25maWcge1xuICByZXRyaWVzOlxuICAgIHwge1xuICAgICAgICBvcGVuTW9kZTogbnVtYmVyO1xuICAgICAgICBydW5Nb2RlOiBudW1iZXI7XG4gICAgICB9XG4gICAgfCBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVzdEhvb2sge1xuICBjbGllbnRJZDogc3RyaW5nO1xuICB0eXBlOiBcImJlZm9yZSBlYWNoXCI7XG4gIHRpdGxlOiBzdHJpbmdbXTtcbiAgYm9keTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlc3Qge1xuICBzdGF0ZTogVGVzdFN0YXRlO1xuICB0ZXN0SWQ6IHN0cmluZztcbiAgZGlzcGxheUVycm9yOiBzdHJpbmcgfCBudWxsO1xuICB0aXRsZTogc3RyaW5nW107XG4gIGNvbmZpZz86IG51bGwgfCBUZXN0Q29uZmlnO1xuICBob29rSWRzOiBzdHJpbmdbXTtcbiAgYm9keTogc3RyaW5nO1xuICBhdHRlbXB0czogVGVzdEF0dGVtcHRbXTtcbiAgaG9va3M6IFRlc3RIb29rW10gfCBudWxsO1xufVxuXG5leHBvcnQgdHlwZSBTZXRUZXN0c1BheWxvYWQgPSBQaWNrPFxuICBUZXN0LFxuICBcImJvZHlcIiB8IFwidGl0bGVcIiB8IFwiY29uZmlnXCIgfCBcImhvb2tJZHNcIlxuPiAmIHsgY2xpZW50SWQ6IHN0cmluZyB9O1xuIiwgImltcG9ydCBkZWJ1Z0ZuIGZyb20gXCJkZWJ1Z1wiO1xuXG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgeyBWYWxpZGF0aW9uRXJyb3IgfSBmcm9tIFwiLi9lcnJvcnNcIjtcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0ZuKFwiY3VycmVudHM6Y2lcIik7XG5cbmNvbnN0IGpvaW4gPSAoY2hhcjogc3RyaW5nLCAuLi5waWVjZXM6IChzdHJpbmcgfCB1bmRlZmluZWQpW10pID0+IHtcbiAgcmV0dXJuIF8uY2hhaW4ocGllY2VzKS5jb21wYWN0KCkuam9pbihjaGFyKS52YWx1ZSgpO1xufTtcblxuY29uc3QgdG9DYW1lbE9iamVjdCA9IChvYmo6IGFueSwga2V5OiBzdHJpbmcpID0+IHtcbiAgcmV0dXJuIF8uc2V0KG9iaiwgXy5jYW1lbENhc2Uoa2V5KSwgcHJvY2Vzcy5lbnZba2V5XSk7XG59O1xuXG5jb25zdCBleHRyYWN0ID0gKGVudktleXM6IHN0cmluZ1tdKSA9PiB7XG4gIHJldHVybiBfLnRyYW5zZm9ybShlbnZLZXlzLCB0b0NhbWVsT2JqZWN0LCB7fSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBydW5uaW5nIG9uIFRlYW1Gb3VuZGF0aW9uIHNlcnZlci5cbiAqIEBzZWUgaHR0cHM6Ly90ZWNobmV0Lm1pY3Jvc29mdC5jb20vZW4tdXMvaGg4NTA0NDgodj12cy45MilcbiAqL1xuY29uc3QgaXNUZWFtRm91bmRhdGlvbiA9ICgpID0+IHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LlRGX0JVSUxEICYmIHByb2Nlc3MuZW52LlRGX0JVSUxEX0JVSUxETlVNQkVSO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgcnVubmluZyBvbiBBenVyZSBDSSBwaXBlbGluZS5cbiAqIFNlZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgaW4gdGhlIGlzc3VlICMzNjU3XG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXByZXNzLWlvL2N5cHJlc3MvaXNzdWVzLzM2NTdcbiAqL1xuY29uc3QgaXNBenVyZUNpID0gKCkgPT4ge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuVEZfQlVJTEQgJiYgcHJvY2Vzcy5lbnYuQVpVUkVfSFRUUF9VU0VSX0FHRU5UO1xufTtcblxuY29uc3QgaXNBV1NDb2RlQnVpbGQgPSAoKSA9PiB7XG4gIHJldHVybiBfLnNvbWUocHJvY2Vzcy5lbnYsICh2YWwsIGtleSkgPT4ge1xuICAgIHJldHVybiAvXkNPREVCVUlMRF8vLnRlc3Qoa2V5KTtcbiAgfSk7XG59O1xuXG5jb25zdCBpc0JhbWJvbyA9ICgpID0+IHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LmJhbWJvb19idWlsZE51bWJlcjtcbn07XG5cbmNvbnN0IGlzQ29kZXNoaXBCYXNpYyA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICBwcm9jZXNzLmVudi5DSV9OQU1FICYmXG4gICAgcHJvY2Vzcy5lbnYuQ0lfTkFNRSA9PT0gXCJjb2Rlc2hpcFwiICYmXG4gICAgcHJvY2Vzcy5lbnYuQ09ERVNISVBcbiAgKTtcbn07XG5cbmNvbnN0IGlzQ29kZXNoaXBQcm8gPSAoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgcHJvY2Vzcy5lbnYuQ0lfTkFNRSAmJlxuICAgIHByb2Nlc3MuZW52LkNJX05BTUUgPT09IFwiY29kZXNoaXBcIiAmJlxuICAgICFwcm9jZXNzLmVudi5DT0RFU0hJUFxuICApO1xufTtcblxuY29uc3QgaXNDb25jb3Vyc2UgPSAoKSA9PiB7XG4gIHJldHVybiBfLnNvbWUocHJvY2Vzcy5lbnYsICh2YWwsIGtleSkgPT4ge1xuICAgIHJldHVybiAvXkNPTkNPVVJTRV8vLnRlc3Qoa2V5KTtcbiAgfSk7XG59O1xuXG5jb25zdCBpc0dpdGxhYiA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICBwcm9jZXNzLmVudi5HSVRMQUJfQ0kgfHxcbiAgICAocHJvY2Vzcy5lbnYuQ0lfU0VSVkVSX05BTUUgJiYgL15HaXRMYWIvLnRlc3QocHJvY2Vzcy5lbnYuQ0lfU0VSVkVSX05BTUUpKVxuICApO1xufTtcblxuY29uc3QgaXNHb29nbGVDbG91ZCA9ICgpID0+IHtcbiAgLy8gc2V0IGF1dG9tYXRpY2FsbHkgZm9yIHRoZSBOb2RlLmpzIDYsIE5vZGUuanMgOCBydW50aW1lcyAobm90IGluIE5vZGUgMTApXG4gIC8vIFRPRE86IG1heSBhbHNvIHBvdGVudGlhbGx5IGhhdmUgWF9HT09HTEVfKiBlbnYgdmFyIHNldFxuICAvLyBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vZnVuY3Rpb25zL2RvY3MvZW52LXZhciNlbnZpcm9ubWVudF92YXJpYWJsZXNfc2V0X2F1dG9tYXRpY2FsbHlcbiAgcmV0dXJuIChcbiAgICBwcm9jZXNzLmVudi5HQ1BfUFJPSkVDVCB8fFxuICAgIHByb2Nlc3MuZW52LkdDTE9VRF9QUk9KRUNUIHx8XG4gICAgcHJvY2Vzcy5lbnYuR09PR0xFX0NMT1VEX1BST0pFQ1RcbiAgKTtcbn07XG5cbmNvbnN0IGlzSmVua2lucyA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICBwcm9jZXNzLmVudi5KRU5LSU5TX1VSTCB8fFxuICAgIHByb2Nlc3MuZW52LkpFTktJTlNfSE9NRSB8fFxuICAgIHByb2Nlc3MuZW52LkpFTktJTlNfVkVSU0lPTiB8fFxuICAgIHByb2Nlc3MuZW52LkhVRFNPTl9VUkwgfHxcbiAgICBwcm9jZXNzLmVudi5IVURTT05fSE9NRVxuICApO1xufTtcblxuY29uc3QgaXNXZXJja2VyID0gKCkgPT4ge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuV0VSQ0tFUiB8fCBwcm9jZXNzLmVudi5XRVJDS0VSX01BSU5fUElQRUxJTkVfU1RBUlRFRDtcbn07XG5cbi8qKlxuICogV2UgZGV0ZWN0IENJIHByb3ZpZGVycyBieSBkZXRlY3RpbmcgYW4gZW52aXJvbm1lbnQgdmFyaWFibGVcbiAqIHVuaXF1ZSB0byB0aGUgcHJvdmlkZXIsIG9yIGJ5IGNhbGxpbmcgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZVxuICogZm9yIHRoYXQgcHJvdmlkZXIuXG4gKlxuICogRm9yIGV4YW1wbGUsIEFwcFZleW9yIENJIGhhcyBlbnZpcm9ubWVudCB0aGVcbiAqIHZhcmlhYmxlIFwiQVBQVkVZT1JcIiBzZXQgZHVyaW5nIHJ1blxuICovXG5jb25zdCBDSV9QUk9WSURFUlMgPSB7XG4gIGFwcHZleW9yOiBcIkFQUFZFWU9SXCIsXG4gIGF6dXJlOiBpc0F6dXJlQ2ksXG4gIGF3c0NvZGVCdWlsZDogaXNBV1NDb2RlQnVpbGQsXG4gIGJhbWJvbzogaXNCYW1ib28sXG4gIGJpdGJ1Y2tldDogXCJCSVRCVUNLRVRfQlVJTERfTlVNQkVSXCIsXG4gIGJ1aWxka2l0ZTogXCJCVUlMREtJVEVcIixcbiAgY2lyY2xlOiBcIkNJUkNMRUNJXCIsXG4gIGNvZGVzaGlwQmFzaWM6IGlzQ29kZXNoaXBCYXNpYyxcbiAgY29kZXNoaXBQcm86IGlzQ29kZXNoaXBQcm8sXG4gIGNvbmNvdXJzZTogaXNDb25jb3Vyc2UsXG4gIGNvZGVGcmVzaDogXCJDRl9CVUlMRF9JRFwiLFxuICBkcm9uZTogXCJEUk9ORVwiLFxuICBnaXRodWJBY3Rpb25zOiBcIkdJVEhVQl9BQ1RJT05TXCIsXG4gIGdpdGxhYjogaXNHaXRsYWIsXG4gIGdvQ0Q6IFwiR09fSk9CX05BTUVcIixcbiAgZ29vZ2xlQ2xvdWQ6IGlzR29vZ2xlQ2xvdWQsXG4gIGplbmtpbnM6IGlzSmVua2lucyxcbiAgc2VtYXBob3JlOiBcIlNFTUFQSE9SRVwiLFxuICBzaGlwcGFibGU6IFwiU0hJUFBBQkxFXCIsXG4gIHRlYW1jaXR5OiBcIlRFQU1DSVRZX1ZFUlNJT05cIixcbiAgdGVhbWZvdW5kYXRpb246IGlzVGVhbUZvdW5kYXRpb24sXG4gIHRyYXZpczogXCJUUkFWSVNcIixcbiAgd2VyY2tlcjogaXNXZXJja2VyLFxuICBuZXRsaWZ5OiBcIk5FVExJRllcIixcbiAgbGF5ZXJjaTogXCJMQVlFUkNJXCIsXG59O1xuXG5mdW5jdGlvbiBfZGV0ZWN0UHJvdmlkZXJOYW1lKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IHsgZW52IH0gPSBwcm9jZXNzO1xuICAvLyByZXR1cm4gdGhlIGtleSBvZiB0aGUgZmlyc3QgcHJvdmlkZXJcbiAgLy8gd2hpY2ggaXMgdHJ1dGh5XG5cbiAgcmV0dXJuIF8uZmluZEtleShDSV9QUk9WSURFUlMsICh2YWx1ZSkgPT4ge1xuICAgIGlmIChfLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGVudlt2YWx1ZV07XG4gICAgfVxuXG4gICAgaWYgKF8uaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIFRPRE86IGRvbid0IGZvciBhYm91dCBidWlsZE51bWJlciFcbi8vIGxvb2sgYXQgdGhlIG9sZCBjb21taXQgdGhhdCB3YXMgcmVtb3ZlZCB0byBzZWUgaG93IHdlIGRpZCBpdFxuY29uc3QgX3Byb3ZpZGVyQ2lQYXJhbXMgPSAoKTogUHJvdmlkZXJDaVBhcmFtc1JlcyA9PiB7XG4gIHJldHVybiB7XG4gICAgYXBwdmV5b3I6IGV4dHJhY3QoW1xuICAgICAgXCJBUFBWRVlPUl9KT0JfSURcIixcbiAgICAgIFwiQVBQVkVZT1JfQUNDT1VOVF9OQU1FXCIsXG4gICAgICBcIkFQUFZFWU9SX1BST0pFQ1RfU0xVR1wiLFxuICAgICAgXCJBUFBWRVlPUl9CVUlMRF9OVU1CRVJcIixcbiAgICAgIFwiQVBQVkVZT1JfQlVJTERfVkVSU0lPTlwiLFxuICAgICAgXCJBUFBWRVlPUl9QVUxMX1JFUVVFU1RfTlVNQkVSXCIsXG4gICAgICBcIkFQUFZFWU9SX1BVTExfUkVRVUVTVF9IRUFEX1JFUE9fQlJBTkNIXCIsXG4gICAgXSksXG4gICAgYXp1cmU6IGV4dHJhY3QoW1xuICAgICAgXCJCVUlMRF9CVUlMRElEXCIsXG4gICAgICBcIkJVSUxEX0JVSUxETlVNQkVSXCIsXG4gICAgICBcIkJVSUxEX0NPTlRBSU5FUklEXCIsXG4gICAgICBcIkJVSUxEX1JFUE9TSVRPUllfVVJJXCIsXG4gICAgXSksXG4gICAgYXdzQ29kZUJ1aWxkOiBleHRyYWN0KFtcbiAgICAgIFwiQ09ERUJVSUxEX0JVSUxEX0lEXCIsXG4gICAgICBcIkNPREVCVUlMRF9CVUlMRF9OVU1CRVJcIixcbiAgICAgIFwiQ09ERUJVSUxEX1JFU09MVkVEX1NPVVJDRV9WRVJTSU9OXCIsXG4gICAgICBcIkNPREVCVUlMRF9TT1VSQ0VfUkVQT19VUkxcIixcbiAgICAgIFwiQ09ERUJVSUxEX1NPVVJDRV9WRVJTSU9OXCIsXG4gICAgXSksXG4gICAgYmFtYm9vOiBleHRyYWN0KFtcbiAgICAgIFwiYmFtYm9vX2J1aWxkTnVtYmVyXCIsXG4gICAgICBcImJhbWJvb19idWlsZFJlc3VsdHNVcmxcIixcbiAgICAgIFwiYmFtYm9vX3BsYW5SZXBvc2l0b3J5X3JlcG9zaXRvcnlVcmxcIixcbiAgICAgIFwiYmFtYm9vX2J1aWxkS2V5XCIsXG4gICAgXSksXG4gICAgYml0YnVja2V0OiBleHRyYWN0KFtcbiAgICAgIFwiQklUQlVDS0VUX1JFUE9fU0xVR1wiLFxuICAgICAgXCJCSVRCVUNLRVRfUkVQT19PV05FUlwiLFxuICAgICAgXCJCSVRCVUNLRVRfQlVJTERfTlVNQkVSXCIsXG4gICAgICBcIkJJVEJVQ0tFVF9QQVJBTExFTF9TVEVQXCIsXG4gICAgICBcIkJJVEJVQ0tFVF9TVEVQX1JVTl9OVU1CRVJcIixcbiAgICAgIC8vIHRoZSBQUiB2YXJpYWJsZXMgYXJlIG9ubHkgc2V0IG9uIHB1bGwgcmVxdWVzdCBidWlsZHNcbiAgICAgIFwiQklUQlVDS0VUX1BSX0lEXCIsXG4gICAgICBcIkJJVEJVQ0tFVF9QUl9ERVNUSU5BVElPTl9CUkFOQ0hcIixcbiAgICAgIFwiQklUQlVDS0VUX1BSX0RFU1RJTkFUSU9OX0NPTU1JVFwiLFxuICAgIF0pLFxuICAgIGJ1aWxka2l0ZTogZXh0cmFjdChbXG4gICAgICBcIkJVSUxES0lURV9SRVBPXCIsXG4gICAgICBcIkJVSUxES0lURV9TT1VSQ0VcIixcbiAgICAgIFwiQlVJTERLSVRFX0pPQl9JRFwiLFxuICAgICAgXCJCVUlMREtJVEVfQlVJTERfSURcIixcbiAgICAgIFwiQlVJTERLSVRFX0JVSUxEX1VSTFwiLFxuICAgICAgXCJCVUlMREtJVEVfQlVJTERfTlVNQkVSXCIsXG4gICAgICBcIkJVSUxES0lURV9QVUxMX1JFUVVFU1RcIixcbiAgICAgIFwiQlVJTERLSVRFX1BVTExfUkVRVUVTVF9SRVBPXCIsXG4gICAgICBcIkJVSUxES0lURV9QVUxMX1JFUVVFU1RfQkFTRV9CUkFOQ0hcIixcbiAgICBdKSxcbiAgICBjaXJjbGU6IGV4dHJhY3QoW1xuICAgICAgXCJDSVJDTEVfSk9CXCIsXG4gICAgICBcIkNJUkNMRV9CVUlMRF9OVU1cIixcbiAgICAgIFwiQ0lSQ0xFX0JVSUxEX1VSTFwiLFxuICAgICAgXCJDSVJDTEVfUFJfTlVNQkVSXCIsXG4gICAgICBcIkNJUkNMRV9QUl9SRVBPTkFNRVwiLFxuICAgICAgXCJDSVJDTEVfUFJfVVNFUk5BTUVcIixcbiAgICAgIFwiQ0lSQ0xFX0NPTVBBUkVfVVJMXCIsXG4gICAgICBcIkNJUkNMRV9XT1JLRkxPV19JRFwiLFxuICAgICAgXCJDSVJDTEVfUFVMTF9SRVFVRVNUXCIsXG4gICAgICBcIkNJUkNMRV9SRVBPU0lUT1JZX1VSTFwiLFxuICAgICAgXCJDSV9QVUxMX1JFUVVFU1RcIixcbiAgICBdKSxcbiAgICBjb2Rlc2hpcEJhc2ljOiBleHRyYWN0KFtcbiAgICAgIFwiQ0lfQlVJTERfSURcIixcbiAgICAgIFwiQ0lfUkVQT19OQU1FXCIsXG4gICAgICBcIkNJX0JVSUxEX1VSTFwiLFxuICAgICAgXCJDSV9QUk9KRUNUX0lEXCIsXG4gICAgICBcIkNJX0JVSUxEX05VTUJFUlwiLFxuICAgICAgXCJDSV9QVUxMX1JFUVVFU1RcIixcbiAgICBdKSxcbiAgICAvLyBDb2Rlc2hpcFBybyBwcm92aWRlcyB2ZXJ5IGZldyBDSSB2YXJpYWJsZXNcbiAgICAvLyBodHRwczovL2RvY3VtZW50YXRpb24uY29kZXNoaXAuY29tL3Byby9idWlsZHMtYW5kLWNvbmZpZ3VyYXRpb24vZW52aXJvbm1lbnQtdmFyaWFibGVzL1xuICAgIGNvZGVzaGlwUHJvOiBleHRyYWN0KFtcIkNJX0JVSUxEX0lEXCIsIFwiQ0lfUkVQT19OQU1FXCIsIFwiQ0lfUFJPSkVDVF9JRFwiXSksXG4gICAgLy8gaHR0cHM6Ly9jb25jb3Vyc2UtY2kub3JnL2ltcGxlbWVudGluZy1yZXNvdXJjZS10eXBlcy5odG1sI3Jlc291cmNlLW1ldGFkYXRhXG4gICAgY29uY291cnNlOiBleHRyYWN0KFtcbiAgICAgIFwiQlVJTERfSURcIixcbiAgICAgIFwiQlVJTERfTkFNRVwiLFxuICAgICAgXCJCVUlMRF9KT0JfTkFNRVwiLFxuICAgICAgXCJCVUlMRF9QSVBFTElORV9OQU1FXCIsXG4gICAgICBcIkJVSUxEX1RFQU1fTkFNRVwiLFxuICAgICAgXCJBVENfRVhURVJOQUxfVVJMXCIsXG4gICAgXSksXG4gICAgLy8gaHR0cHM6Ly9jb2RlZnJlc2guaW8vZG9jcy9kb2NzL2NvZGVmcmVzaC15YW1sL3ZhcmlhYmxlcy9cbiAgICBjb2RlRnJlc2g6IGV4dHJhY3QoW1xuICAgICAgXCJDRl9CVUlMRF9JRFwiLFxuICAgICAgXCJDRl9CVUlMRF9VUkxcIixcbiAgICAgIFwiQ0ZfQ1VSUkVOVF9BVFRFTVBUXCIsXG4gICAgICBcIkNGX1NURVBfTkFNRVwiLFxuICAgICAgXCJDRl9QSVBFTElORV9OQU1FXCIsXG4gICAgICBcIkNGX1BJUEVMSU5FX1RSSUdHRVJfSURcIixcbiAgICAgIC8vIHZhcmlhYmxlcyBhZGRlZCBmb3IgcHVsbCByZXF1ZXN0c1xuICAgICAgXCJDRl9QVUxMX1JFUVVFU1RfSURcIixcbiAgICAgIFwiQ0ZfUFVMTF9SRVFVRVNUX0lTX0ZPUktcIixcbiAgICAgIFwiQ0ZfUFVMTF9SRVFVRVNUX05VTUJFUlwiLFxuICAgICAgXCJDRl9QVUxMX1JFUVVFU1RfVEFSR0VUXCIsXG4gICAgXSksXG4gICAgZHJvbmU6IGV4dHJhY3QoW1xuICAgICAgXCJEUk9ORV9KT0JfTlVNQkVSXCIsXG4gICAgICBcIkRST05FX0JVSUxEX0xJTktcIixcbiAgICAgIFwiRFJPTkVfQlVJTERfTlVNQkVSXCIsXG4gICAgICBcIkRST05FX1BVTExfUkVRVUVTVFwiLFxuICAgIF0pLFxuICAgIC8vIGh0dHBzOi8vaGVscC5naXRodWIuY29tL2VuL2FjdGlvbnMvYXV0b21hdGluZy15b3VyLXdvcmtmbG93LXdpdGgtZ2l0aHViLWFjdGlvbnMvdXNpbmctZW52aXJvbm1lbnQtdmFyaWFibGVzI2RlZmF1bHQtZW52aXJvbm1lbnQtdmFyaWFibGVzXG4gICAgZ2l0aHViQWN0aW9uczogZXh0cmFjdChbXG4gICAgICBcIkdJVEhVQl9XT1JLRkxPV1wiLFxuICAgICAgXCJHSVRIVUJfQUNUSU9OXCIsXG4gICAgICBcIkdJVEhVQl9FVkVOVF9OQU1FXCIsXG4gICAgICBcIkdJVEhVQl9SVU5fSURcIixcbiAgICAgIFwiR0lUSFVCX1JVTl9BVFRFTVBUXCIsXG4gICAgICBcIkdJVEhVQl9SRVBPU0lUT1JZXCIsXG4gICAgXSksXG4gICAgLy8gc2VlIGh0dHBzOi8vZG9jcy5naXRsYWIuY29tL2VlL2NpL3ZhcmlhYmxlcy9cbiAgICBnaXRsYWI6IGV4dHJhY3QoW1xuICAgICAgLy8gcGlwZWxpbmUgaXMgY29tbW9uIGFtb25nIGFsbCBqb2JzXG4gICAgICBcIkNJX1BJUEVMSU5FX0lEXCIsXG4gICAgICBcIkNJX1BJUEVMSU5FX1VSTFwiLFxuICAgICAgLy8gaW5kaXZpZHVhbCBqb2JzXG4gICAgICBcIkNJX0JVSUxEX0lEXCIsIC8vIGJ1aWxkIGlkIGFuZCBqb2IgaWQgYXJlIGFsaWFzZXNcbiAgICAgIFwiQ0lfSk9CX0lEXCIsXG4gICAgICBcIkNJX0pPQl9VUkxcIixcbiAgICAgIFwiQ0lfSk9CX05BTUVcIixcbiAgICAgIC8vIG90aGVyIGluZm9ybWF0aW9uXG4gICAgICBcIkdJVExBQl9IT1NUXCIsXG4gICAgICBcIkNJX1BST0pFQ1RfSURcIixcbiAgICAgIFwiQ0lfUFJPSkVDVF9VUkxcIixcbiAgICAgIFwiQ0lfUkVQT1NJVE9SWV9VUkxcIixcbiAgICAgIFwiQ0lfRU5WSVJPTk1FTlRfVVJMXCIsXG4gICAgICBcIkNJX0RFRkFVTFRfQlJBTkNIXCIsXG4gICAgICAvLyBmb3IgUFJzOiBodHRwczovL2dpdGxhYi5jb20vZ2l0bGFiLW9yZy9naXRsYWItY2UvaXNzdWVzLzIzOTAyXG4gICAgXSksXG4gICAgLy8gaHR0cHM6Ly9kb2NzLmdvY2Qub3JnL2N1cnJlbnQvZmFxL2Rldl91c2VfY3VycmVudF9yZXZpc2lvbl9pbl9idWlsZC5odG1sI3N0YW5kYXJkLWdvY2QtZW52aXJvbm1lbnQtdmFyaWFibGVzXG4gICAgZ29DRDogZXh0cmFjdChbXG4gICAgICBcIkdPX1NFUlZFUl9VUkxcIixcbiAgICAgIFwiR09fRU5WSVJPTk1FTlRfTkFNRVwiLFxuICAgICAgXCJHT19QSVBFTElORV9OQU1FXCIsXG4gICAgICBcIkdPX1BJUEVMSU5FX0NPVU5URVJcIixcbiAgICAgIFwiR09fUElQRUxJTkVfTEFCRUxcIixcbiAgICAgIFwiR09fU1RBR0VfTkFNRVwiLFxuICAgICAgXCJHT19TVEFHRV9DT1VOVEVSXCIsXG4gICAgICBcIkdPX0pPQl9OQU1FXCIsXG4gICAgICBcIkdPX1RSSUdHRVJfVVNFUlwiLFxuICAgICAgXCJHT19SRVZJU0lPTlwiLFxuICAgICAgXCJHT19UT19SRVZJU0lPTlwiLFxuICAgICAgXCJHT19GUk9NX1JFVklTSU9OXCIsXG4gICAgICBcIkdPX01BVEVSSUFMX0hBU19DSEFOR0VEXCIsXG4gICAgXSksXG4gICAgZ29vZ2xlQ2xvdWQ6IGV4dHJhY3QoW1xuICAgICAgLy8gaW5kaXZpZHVhbCBqb2JzXG4gICAgICBcIkJVSUxEX0lEXCIsXG4gICAgICBcIlBST0pFQ1RfSURcIixcbiAgICAgIC8vIG90aGVyIGluZm9ybWF0aW9uXG4gICAgICBcIlJFUE9fTkFNRVwiLFxuICAgICAgXCJCUkFOQ0hfTkFNRVwiLFxuICAgICAgXCJUQUdfTkFNRVwiLFxuICAgICAgXCJDT01NSVRfU0hBXCIsXG4gICAgICBcIlNIT1JUX1NIQVwiLFxuICAgICAgLy8gaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2Nsb3VkLWJ1aWxkL2RvY3MvYXBpL3JlZmVyZW5jZS9yZXN0L1NoYXJlZC5UeXBlcy9CdWlsZFxuICAgIF0pLFxuICAgIGplbmtpbnM6IGV4dHJhY3QoW1wiQlVJTERfSURcIiwgXCJCVUlMRF9VUkxcIiwgXCJCVUlMRF9OVU1CRVJcIiwgXCJnaHByYlB1bGxJZFwiXSksXG4gICAgLy8gaHR0cHM6Ly9zZW1hcGhvcmVjaS5jb20vZG9jcy9hdmFpbGFibGUtZW52aXJvbm1lbnQtdmFyaWFibGVzLmh0bWxcbiAgICAvLyBzb21lIGNvbWUgZnJvbSB2MSwgc29tZSBmcm9tIHYyIG9mIHNlbWFwaG9yZVxuICAgIHNlbWFwaG9yZTogZXh0cmFjdChbXG4gICAgICBcIlNFTUFQSE9SRV9CUkFOQ0hfSURcIixcbiAgICAgIFwiU0VNQVBIT1JFX0JVSUxEX05VTUJFUlwiLFxuICAgICAgXCJTRU1BUEhPUkVfQ1VSUkVOVF9KT0JcIixcbiAgICAgIFwiU0VNQVBIT1JFX0NVUlJFTlRfVEhSRUFEXCIsXG4gICAgICBcIlNFTUFQSE9SRV9FWEVDVVRBQkxFX1VVSURcIixcbiAgICAgIFwiU0VNQVBIT1JFX0dJVF9CUkFOQ0hcIixcbiAgICAgIFwiU0VNQVBIT1JFX0dJVF9ESVJcIixcbiAgICAgIFwiU0VNQVBIT1JFX0dJVF9SRUZcIixcbiAgICAgIFwiU0VNQVBIT1JFX0dJVF9SRUZfVFlQRVwiLFxuICAgICAgXCJTRU1BUEhPUkVfR0lUX1JFUE9fU0xVR1wiLFxuICAgICAgXCJTRU1BUEhPUkVfR0lUX1NIQVwiLFxuICAgICAgXCJTRU1BUEhPUkVfR0lUX1VSTFwiLFxuICAgICAgXCJTRU1BUEhPUkVfSk9CX0NPVU5UXCIsXG4gICAgICBcIlNFTUFQSE9SRV9KT0JfSURcIiwgLy8gdjJcbiAgICAgIFwiU0VNQVBIT1JFX0pPQl9OQU1FXCIsXG4gICAgICBcIlNFTUFQSE9SRV9KT0JfVVVJRFwiLCAvLyB2MVxuICAgICAgXCJTRU1BUEhPUkVfUElQRUxJTkVfSURcIixcbiAgICAgIFwiU0VNQVBIT1JFX1BMQVRGT1JNXCIsXG4gICAgICBcIlNFTUFQSE9SRV9QUk9KRUNUX0RJUlwiLFxuICAgICAgXCJTRU1BUEhPUkVfUFJPSkVDVF9IQVNIX0lEXCIsXG4gICAgICBcIlNFTUFQSE9SRV9QUk9KRUNUX0lEXCIsIC8vIHYyXG4gICAgICBcIlNFTUFQSE9SRV9QUk9KRUNUX05BTUVcIixcbiAgICAgIFwiU0VNQVBIT1JFX1BST0pFQ1RfVVVJRFwiLCAvLyB2MVxuICAgICAgXCJTRU1BUEhPUkVfUkVQT19TTFVHXCIsXG4gICAgICBcIlNFTUFQSE9SRV9UUklHR0VSX1NPVVJDRVwiLFxuICAgICAgXCJTRU1BUEhPUkVfV09SS0ZMT1dfSURcIixcbiAgICAgIFwiUFVMTF9SRVFVRVNUX05VTUJFUlwiLCAvLyBwdWxsIHJlcXVlc3RzIGZyb20gZm9ya3MgT05MWVxuICAgIF0pLFxuICAgIC8vIHNlZSBodHRwOi8vZG9jcy5zaGlwcGFibGUuY29tL2NpL2Vudi12YXJzL1xuICAgIHNoaXBwYWJsZTogZXh0cmFjdChbXG4gICAgICAvLyBidWlsZCB2YXJpYWJsZXNcbiAgICAgIFwiU0hJUFBBQkxFX0JVSUxEX0lEXCIsIC8vIFwiNWI5MzM1NGNhYmZhYmIwNzAwN2YwMWZkXCJcbiAgICAgIFwiU0hJUFBBQkxFX0JVSUxEX05VTUJFUlwiLCAvLyBcIjRcIlxuICAgICAgXCJTSElQUEFCTEVfQ09NTUlUX1JBTkdFXCIsIC8vIFwic2hhMS4uLnNoYTJcIlxuICAgICAgXCJTSElQUEFCTEVfQ09OVEFJTkVSX05BTUVcIiwgLy8gXCJjLmV4ZWMuY3lwcmVzcy1leGFtcGxlLWtpdGNoZW5zaW5rLjQuMVwiXG4gICAgICBcIlNISVBQQUJMRV9KT0JfSURcIiwgLy8gXCIxXCJcbiAgICAgIFwiU0hJUFBBQkxFX0pPQl9OVU1CRVJcIiwgLy8gXCIxXCJcbiAgICAgIFwiU0hJUFBBQkxFX1JFUE9fU0xVR1wiLCAvLyBcIjx1c2VybmFtZT4vPHJlcG8+XCJcbiAgICAgIC8vIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdGhhdCBTaGlwcGFibGUgcHJvdmlkZXNcbiAgICAgIFwiSVNfRk9SS1wiLCAvLyBcInRydWVcIlxuICAgICAgXCJJU19HSVRfVEFHXCIsIC8vIFwiZmFsc2VcIlxuICAgICAgXCJJU19QUkVSRUxFQVNFXCIsIC8vIFwiZmFsc2VcIlxuICAgICAgXCJJU19SRUxFQVNFXCIsIC8vIFwiZmFsc2VcIlxuICAgICAgXCJSRVBPU0lUT1JZX1VSTFwiLCAvLyBcImh0dHBzOi8vZ2l0aHViLmNvbS8uLi4uZ2l0XCJcbiAgICAgIFwiUkVQT19GVUxMX05BTUVcIiwgLy8gXCI8dXNlcm5hbWU+LzxyZXBvPlwiXG4gICAgICBcIlJFUE9fTkFNRVwiLCAvLyBcImN5cHJlc3MtZXhhbXBsZS1raXRjaGVuc2lua1wiXG4gICAgICBcIkJVSUxEX1VSTFwiLCAvLyBcImh0dHBzOi8vYXBwLnNoaXBwYWJsZS5jb20vZ2l0aHViLzx1c2VybmFtZT4vPHJlcG8+L3J1bnMvMVwiXG4gICAgICAvLyBQdWxsIHJlcXVlc3QgaW5mb3JtYXRpb25cbiAgICAgIFwiQkFTRV9CUkFOQ0hcIiwgLy8gTmFtZSBvZiB0aGUgdGFyZ2V0IGJyYW5jaCBpbnRvIHdoaWNoIHRoZSBwdWxsIHJlcXVlc3QgY2hhbmdlcyB3aWxsIGJlIG1lcmdlZC5cbiAgICAgIFwiSEVBRF9CUkFOQ0hcIiwgLy8gVGhpcyBpcyBvbmx5IHNldCBmb3IgcHVsbCByZXF1ZXN0cyBhbmQgaXMgdGhlIG5hbWUgb2YgdGhlIGJyYW5jaCB0aGUgcHVsbCByZXF1ZXN0IHdhcyBvcGVuZWQgZnJvbS5cbiAgICAgIFwiSVNfUFVMTF9SRVFVRVNUXCIsIC8vIFwiZmFsc2VcIiBvciBcInRydWVcIlxuICAgICAgXCJQVUxMX1JFUVVFU1RcIiwgLy8gUHVsbCByZXF1ZXN0IG51bWJlciBpZiB0aGUgam9iIGlzIGEgcHVsbCByZXF1ZXN0LiBJZiBub3QsIHRoaXMgd2lsbCBiZSBzZXQgdG8gZmFsc2UuXG4gICAgICBcIlBVTExfUkVRVUVTVF9CQVNFX0JSQU5DSFwiLCAvLyBOYW1lIG9mIHRoZSBicmFuY2ggdGhhdCB0aGUgcHVsbCByZXF1ZXN0IHdpbGwgYmUgbWVyZ2VkIGludG8uIEl0IHNob3VsZCBiZSB0aGUgc2FtZSBhcyBCQVNFX0JSQU5DSC5cbiAgICAgIFwiUFVMTF9SRVFVRVNUX1JFUE9fRlVMTF9OQU1FXCIsIC8vIEZ1bGwgbmFtZSBvZiB0aGUgcmVwb3NpdG9yeSBmcm9tIHdoZXJlIHRoZSBwdWxsIHJlcXVlc3Qgb3JpZ2luYXRlZC5cbiAgICBdKSxcbiAgICB0ZWFtY2l0eTogbnVsbCxcbiAgICB0ZWFtZm91bmRhdGlvbjogZXh0cmFjdChbXG4gICAgICBcIkJVSUxEX0JVSUxESURcIixcbiAgICAgIFwiQlVJTERfQlVJTEROVU1CRVJcIixcbiAgICAgIFwiQlVJTERfQ09OVEFJTkVSSURcIixcbiAgICBdKSxcbiAgICB0cmF2aXM6IGV4dHJhY3QoW1xuICAgICAgXCJUUkFWSVNfSk9CX0lEXCIsXG4gICAgICBcIlRSQVZJU19CVUlMRF9JRFwiLFxuICAgICAgXCJUUkFWSVNfQlVJTERfV0VCX1VSTFwiLFxuICAgICAgXCJUUkFWSVNfUkVQT19TTFVHXCIsXG4gICAgICBcIlRSQVZJU19KT0JfTlVNQkVSXCIsXG4gICAgICBcIlRSQVZJU19FVkVOVF9UWVBFXCIsXG4gICAgICBcIlRSQVZJU19DT01NSVRfUkFOR0VcIixcbiAgICAgIFwiVFJBVklTX0JVSUxEX05VTUJFUlwiLFxuICAgICAgXCJUUkFWSVNfUFVMTF9SRVFVRVNUXCIsXG4gICAgICBcIlRSQVZJU19QVUxMX1JFUVVFU1RfQlJBTkNIXCIsXG4gICAgICBcIlRSQVZJU19QVUxMX1JFUVVFU1RfU0hBXCIsXG4gICAgXSksXG4gICAgd2VyY2tlcjogbnVsbCxcbiAgICAvLyBodHRwczovL2RvY3MubmV0bGlmeS5jb20vY29uZmlndXJlLWJ1aWxkcy9lbnZpcm9ubWVudC12YXJpYWJsZXMvI2RlcGxveS11cmxzLWFuZC1tZXRhZGF0YVxuICAgIG5ldGxpZnk6IGV4dHJhY3QoW1xuICAgICAgXCJCVUlMRF9JRFwiLFxuICAgICAgXCJDT05URVhUXCIsXG4gICAgICBcIlVSTFwiLFxuICAgICAgXCJERVBMT1lfVVJMXCIsXG4gICAgICBcIkRFUExPWV9QUklNRV9VUkxcIixcbiAgICAgIFwiREVQTE9ZX0lEXCIsXG4gICAgXSksXG4gICAgLy8gaHR0cHM6Ly9sYXllcmNpLmNvbS9kb2NzL2xheWVyZmlsZS1yZWZlcmVuY2UvYnVpbGQtZW52XG4gICAgbGF5ZXJjaTogZXh0cmFjdChbXG4gICAgICBcIkxBWUVSQ0lfSk9CX0lEXCIsXG4gICAgICBcIkxBWUVSQ0lfUlVOTkVSX0lEXCIsXG4gICAgICBcIlJFVFJZX0lOREVYXCIsXG4gICAgICBcIkxBWUVSQ0lfUFVMTF9SRVFVRVNUXCIsXG4gICAgICBcIkxBWUVSQ0lfUkVQT19OQU1FXCIsXG4gICAgICBcIkxBWUVSQ0lfUkVQT19PV05FUlwiLFxuICAgICAgXCJMQVlFUkNJX0JSQU5DSFwiLFxuICAgICAgXCJHSVRfVEFHXCIsIC8vIHNob3J0IGhleCBmb3IgY29tbWl0c1xuICAgIF0pLFxuICB9O1xufTtcblxuLy8gdHJpZXMgdG8gZ3JhYiBjb21taXQgaW5mb3JtYXRpb24gZnJvbSBDSSBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbi8vIHZlcnkgdXNlZnVsIHRvIGZpbGwgbWlzc2luZyBpbmZvcm1hdGlvbiB3aGVuIEdpdCBjYW5ub3QgZ3JhYiBjb3JyZWN0IHZhbHVlc1xuY29uc3QgX3Byb3ZpZGVyQ29tbWl0UGFyYW1zID0gKCk6IFByb3ZpZGVyQ29tbWl0UGFyYW1zUmVzID0+IHtcbiAgY29uc3QgeyBlbnYgfSA9IHByb2Nlc3M7XG5cbiAgcmV0dXJuIHtcbiAgICBhcHB2ZXlvcjoge1xuICAgICAgc2hhOiBlbnYuQVBQVkVZT1JfUkVQT19DT01NSVQsXG4gICAgICAvLyBzaW5jZSBBUFBWRVlPUl9SRVBPX0JSQU5DSCB3aWxsIGJlIHRoZSB0YXJnZXQgYnJhbmNoIG9uIGEgUFJcbiAgICAgIC8vIHdlIG5lZWQgdG8gdXNlIFBVTExfUkVRVUVTVF9IRUFEX1JFUE9fQlJBTkNIIGlmIGl0IGV4aXN0cy5cbiAgICAgIC8vIGUuZy4gaWYgeW91IGhhdmUgYSBQUjogZGV2ZWxvcCA8LSBteS1mZWF0dXJlLWJyYW5jaFxuICAgICAgLy8gbXktZmVhdHVyZS1icmFuY2ggaXMgQVBQVkVZT1JfUFVMTF9SRVFVRVNUX0hFQURfUkVQT19CUkFOQ0hcbiAgICAgIC8vIGRldmVsb3AgICAgICAgICAgIGlzIEFQUFZFWU9SX1JFUE9fQlJBTkNIXG4gICAgICBicmFuY2g6XG4gICAgICAgIGVudi5BUFBWRVlPUl9QVUxMX1JFUVVFU1RfSEVBRF9SRVBPX0JSQU5DSCB8fCBlbnYuQVBQVkVZT1JfUkVQT19CUkFOQ0gsXG4gICAgICBtZXNzYWdlOiBqb2luKFxuICAgICAgICBcIlxcblwiLFxuICAgICAgICBlbnYuQVBQVkVZT1JfUkVQT19DT01NSVRfTUVTU0FHRSxcbiAgICAgICAgZW52LkFQUFZFWU9SX1JFUE9fQ09NTUlUX01FU1NBR0VfRVhURU5ERURcbiAgICAgICksXG4gICAgICBhdXRob3JOYW1lOiBlbnYuQVBQVkVZT1JfUkVQT19DT01NSVRfQVVUSE9SLFxuICAgICAgYXV0aG9yRW1haWw6IGVudi5BUFBWRVlPUl9SRVBPX0NPTU1JVF9BVVRIT1JfRU1BSUwsXG4gICAgICAvLyByZW1vdGVPcmlnaW46ID8/P1xuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICBhd3NDb2RlQnVpbGQ6IHtcbiAgICAgIHNoYTogZW52LkNPREVCVUlMRF9SRVNPTFZFRF9TT1VSQ0VfVkVSU0lPTixcbiAgICAgIC8vIGJyYW5jaDogPz8/LFxuICAgICAgLy8gbWVzc2FnZTogPz8/XG4gICAgICAvLyBhdXRob3JOYW1lOiA/Pz9cbiAgICAgIC8vIGF1dGhvckVtYWlsOiA/Pz9cbiAgICAgIHJlbW90ZU9yaWdpbjogZW52LkNPREVCVUlMRF9TT1VSQ0VfUkVQT19VUkwsXG4gICAgICAvLyBkZWZhdWx0QnJhbmNoOiA/Pz9cbiAgICB9LFxuICAgIGF6dXJlOiB7XG4gICAgICBzaGE6IGVudi5CVUlMRF9TT1VSQ0VWRVJTSU9OLFxuICAgICAgYnJhbmNoOiBlbnYuQlVJTERfU09VUkNFQlJBTkNITkFNRSxcbiAgICAgIG1lc3NhZ2U6IGVudi5CVUlMRF9TT1VSQ0VWRVJTSU9OTUVTU0FHRSxcbiAgICAgIGF1dGhvck5hbWU6IGVudi5CVUlMRF9TT1VSQ0VWRVJTSU9OQVVUSE9SLFxuICAgICAgYXV0aG9yRW1haWw6IGVudi5CVUlMRF9SRVFVRVNURURGT1JFTUFJTCxcbiAgICB9LFxuICAgIGJhbWJvbzoge1xuICAgICAgc2hhOiBlbnYuYmFtYm9vX3BsYW5SZXBvc2l0b3J5X3JldmlzaW9uLFxuICAgICAgYnJhbmNoOiBlbnYuYmFtYm9vX3BsYW5SZXBvc2l0b3J5X2JyYW5jaCxcbiAgICAgIC8vIG1lc3NhZ2U6ID8/P1xuICAgICAgYXV0aG9yTmFtZTogZW52LmJhbWJvb19wbGFuUmVwb3NpdG9yeV91c2VybmFtZSxcbiAgICAgIC8vIGF1dGhvckVtYWlsOiA/Pz9cbiAgICAgIHJlbW90ZU9yaWdpbjogZW52LmJhbWJvb19wbGFuUmVwb3NpdG9yeV9yZXBvc2l0b3J5VVJMLFxuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICBiaXRidWNrZXQ6IHtcbiAgICAgIHNoYTogZW52LkJJVEJVQ0tFVF9DT01NSVQsXG4gICAgICBicmFuY2g6IGVudi5CSVRCVUNLRVRfQlJBTkNILFxuICAgICAgLy8gbWVzc2FnZTogPz8/XG4gICAgICAvLyBhdXRob3JOYW1lOiA/Pz9cbiAgICAgIC8vIGF1dGhvckVtYWlsOiA/Pz9cbiAgICAgIC8vIHJlbW90ZU9yaWdpbjogPz8/XG4gICAgICAvLyBkZWZhdWx0QnJhbmNoOiA/Pz9cbiAgICB9LFxuICAgIGJ1aWxka2l0ZToge1xuICAgICAgc2hhOiBlbnYuQlVJTERLSVRFX0NPTU1JVCxcbiAgICAgIGJyYW5jaDogZW52LkJVSUxES0lURV9CUkFOQ0gsXG4gICAgICBtZXNzYWdlOiBlbnYuQlVJTERLSVRFX01FU1NBR0UsXG4gICAgICBhdXRob3JOYW1lOiBlbnYuQlVJTERLSVRFX0JVSUxEX0NSRUFUT1IsXG4gICAgICBhdXRob3JFbWFpbDogZW52LkJVSUxES0lURV9CVUlMRF9DUkVBVE9SX0VNQUlMLFxuICAgICAgcmVtb3RlT3JpZ2luOiBlbnYuQlVJTERLSVRFX1JFUE8sXG4gICAgICBkZWZhdWx0QnJhbmNoOiBlbnYuQlVJTERLSVRFX1BJUEVMSU5FX0RFRkFVTFRfQlJBTkNILFxuICAgIH0sXG4gICAgY2lyY2xlOiB7XG4gICAgICBzaGE6IGVudi5DSVJDTEVfU0hBMSxcbiAgICAgIGJyYW5jaDogZW52LkNJUkNMRV9CUkFOQ0gsXG4gICAgICAvLyBtZXNzYWdlOiA/Pz9cbiAgICAgIGF1dGhvck5hbWU6IGVudi5DSVJDTEVfVVNFUk5BTUUsXG4gICAgICAvLyBhdXRob3JFbWFpbDogPz8/XG4gICAgICByZW1vdGVPcmlnaW46IGVudi5DSVJDTEVfUkVQT1NJVE9SWV9VUkwsXG4gICAgICAvLyBkZWZhdWx0QnJhbmNoOiA/Pz9cbiAgICB9LFxuICAgIGNvZGVzaGlwQmFzaWM6IHtcbiAgICAgIHNoYTogZW52LkNJX0NPTU1JVF9JRCxcbiAgICAgIGJyYW5jaDogZW52LkNJX0JSQU5DSCxcbiAgICAgIG1lc3NhZ2U6IGVudi5DSV9DT01NSVRfTUVTU0FHRSxcbiAgICAgIGF1dGhvck5hbWU6IGVudi5DSV9DT01NSVRURVJfTkFNRSxcbiAgICAgIGF1dGhvckVtYWlsOiBlbnYuQ0lfQ09NTUlUVEVSX0VNQUlMLFxuICAgICAgLy8gcmVtb3RlT3JpZ2luOiA/Pz9cbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/P1xuICAgIH0sXG4gICAgY29kZXNoaXBQcm86IHtcbiAgICAgIHNoYTogZW52LkNJX0NPTU1JVF9JRCxcbiAgICAgIGJyYW5jaDogZW52LkNJX0JSQU5DSCxcbiAgICAgIG1lc3NhZ2U6IGVudi5DSV9DT01NSVRfTUVTU0FHRSxcbiAgICAgIGF1dGhvck5hbWU6IGVudi5DSV9DT01NSVRURVJfTkFNRSxcbiAgICAgIGF1dGhvckVtYWlsOiBlbnYuQ0lfQ09NTUlUVEVSX0VNQUlMLFxuICAgICAgLy8gcmVtb3RlT3JpZ2luOiA/Pz9cbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/P1xuICAgIH0sXG4gICAgY29kZUZyZXNoOiB7XG4gICAgICBzaGE6IGVudi5DRl9SRVZJU0lPTixcbiAgICAgIGJyYW5jaDogZW52LkNGX0JSQU5DSCxcbiAgICAgIG1lc3NhZ2U6IGVudi5DRl9DT01NSVRfTUVTU0FHRSxcbiAgICAgIGF1dGhvck5hbWU6IGVudi5DRl9DT01NSVRfQVVUSE9SLFxuICAgIH0sXG4gICAgZHJvbmU6IHtcbiAgICAgIHNoYTogZW52LkRST05FX0NPTU1JVF9TSEEsXG4gICAgICAvLyBodHRwczovL2RvY3MuZHJvbmUuaW8vcGlwZWxpbmUvZW52aXJvbm1lbnQvcmVmZXJlbmNlL2Ryb25lLXNvdXJjZS1icmFuY2gvXG4gICAgICBicmFuY2g6IGVudi5EUk9ORV9TT1VSQ0VfQlJBTkNILFxuICAgICAgbWVzc2FnZTogZW52LkRST05FX0NPTU1JVF9NRVNTQUdFLFxuICAgICAgYXV0aG9yTmFtZTogZW52LkRST05FX0NPTU1JVF9BVVRIT1IsXG4gICAgICBhdXRob3JFbWFpbDogZW52LkRST05FX0NPTU1JVF9BVVRIT1JfRU1BSUwsXG4gICAgICByZW1vdGVPcmlnaW46IGVudi5EUk9ORV9HSVRfSFRUUF9VUkwsXG4gICAgICBkZWZhdWx0QnJhbmNoOiBlbnYuRFJPTkVfUkVQT19CUkFOQ0gsXG4gICAgfSxcbiAgICBnaXRodWJBY3Rpb25zOiB7XG4gICAgICBzaGE6IGVudi5HSVRIVUJfU0hBLFxuICAgICAgYnJhbmNoOiBlbnYuR0hfQlJBTkNIIHx8IGVudi5HSVRIVUJfUkVGLFxuICAgICAgZGVmYXVsdEJyYW5jaDogZW52LkdJVEhVQl9CQVNFX1JFRixcbiAgICAgIHJlbW90ZUJyYW5jaDogZW52LkdJVEhVQl9IRUFEX1JFRixcbiAgICAgIHJ1bkF0dGVtcHQ6IGVudi5HSVRIVUJfUlVOX0FUVEVNUFQsXG4gICAgfSxcbiAgICBnaXRsYWI6IHtcbiAgICAgIHNoYTogZW52LkNJX0NPTU1JVF9TSEEsXG4gICAgICBicmFuY2g6IGVudi5DSV9DT01NSVRfUkVGX05BTUUsXG4gICAgICBtZXNzYWdlOiBlbnYuQ0lfQ09NTUlUX01FU1NBR0UsXG4gICAgICBhdXRob3JOYW1lOiBlbnYuR0lUTEFCX1VTRVJfTkFNRSxcbiAgICAgIGF1dGhvckVtYWlsOiBlbnYuR0lUTEFCX1VTRVJfRU1BSUwsXG4gICAgICByZW1vdGVPcmlnaW46IGVudi5DSV9SRVBPU0lUT1JZX1VSTCxcbiAgICAgIGRlZmF1bHRCcmFuY2g6IGVudi5DSV9ERUZBVUxUX0JSQU5DSCxcbiAgICB9LFxuICAgIGdvb2dsZUNsb3VkOiB7XG4gICAgICBzaGE6IGVudi5DT01NSVRfU0hBLFxuICAgICAgYnJhbmNoOiBlbnYuQlJBTkNIX05BTUUsXG4gICAgICAvLyBtZXNzYWdlOiA/P1xuICAgICAgLy8gYXV0aG9yTmFtZTogPz9cbiAgICAgIC8vIGF1dGhvckVtYWlsOiA/P1xuICAgICAgLy8gcmVtb3RlT3JpZ2luOiA/Pz9cbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/XG4gICAgfSxcbiAgICBqZW5raW5zOiB7XG4gICAgICBzaGE6IGVudi5HSVRfQ09NTUlULFxuICAgICAgYnJhbmNoOiBlbnYuR0lUX0JSQU5DSCxcbiAgICAgIC8vIG1lc3NhZ2U6ID8/P1xuICAgICAgLy8gYXV0aG9yTmFtZTogPz8/XG4gICAgICAvLyBhdXRob3JFbWFpbDogPz8/XG4gICAgICAvLyByZW1vdGVPcmlnaW46ID8/P1xuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICAvLyBPbmx5IGZyb20gZm9ya3M/IGh0dHBzOi8vc2VtYXBob3JlY2kuY29tL2RvY3MvYXZhaWxhYmxlLWVudmlyb25tZW50LXZhcmlhYmxlcy5odG1sXG4gICAgc2VtYXBob3JlOiB7XG4gICAgICBzaGE6IGVudi5TRU1BUEhPUkVfR0lUX1NIQSxcbiAgICAgIGJyYW5jaDogZW52LlNFTUFQSE9SRV9HSVRfQlJBTkNILFxuICAgICAgLy8gbWVzc2FnZTogPz8/XG4gICAgICAvLyBhdXRob3JOYW1lOiA/Pz9cbiAgICAgIC8vIGF1dGhvckVtYWlsOiA/Pz9cbiAgICAgIHJlbW90ZU9yaWdpbjogZW52LlNFTUFQSE9SRV9HSVRfUkVQT19TTFVHLFxuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICBzaGlwcGFibGU6IHtcbiAgICAgIHNoYTogZW52LkNPTU1JVCxcbiAgICAgIGJyYW5jaDogZW52LkJSQU5DSCxcbiAgICAgIG1lc3NhZ2U6IGVudi5DT01NSVRfTUVTU0FHRSxcbiAgICAgIGF1dGhvck5hbWU6IGVudi5DT01NSVRURVIsXG4gICAgICAvLyBhdXRob3JFbWFpbDogPz8/XG4gICAgICAvLyByZW1vdGVPcmlnaW46ID8/P1xuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICBzbmFwOiBudWxsLFxuICAgIHRlYW1jaXR5OiBudWxsLFxuICAgIHRlYW1mb3VuZGF0aW9uOiB7XG4gICAgICBzaGE6IGVudi5CVUlMRF9TT1VSQ0VWRVJTSU9OLFxuICAgICAgYnJhbmNoOiBlbnYuQlVJTERfU09VUkNFQlJBTkNITkFNRSxcbiAgICAgIG1lc3NhZ2U6IGVudi5CVUlMRF9TT1VSQ0VWRVJTSU9OTUVTU0FHRSxcbiAgICAgIGF1dGhvck5hbWU6IGVudi5CVUlMRF9TT1VSQ0VWRVJTSU9OQVVUSE9SLFxuICAgIH0sXG4gICAgdHJhdmlzOiB7XG4gICAgICBzaGE6IGVudi5UUkFWSVNfUFVMTF9SRVFVRVNUX1NIQSB8fCBlbnYuVFJBVklTX0NPTU1JVCxcbiAgICAgIC8vIGZvciBQUnMsIFRSQVZJU19CUkFOQ0ggaXMgdGhlIGJhc2UgYnJhbmNoIGJlaW5nIG1lcmdlZCBpbnRvXG4gICAgICBicmFuY2g6IGVudi5UUkFWSVNfUFVMTF9SRVFVRVNUX0JSQU5DSCB8fCBlbnYuVFJBVklTX0JSQU5DSCxcbiAgICAgIC8vIGF1dGhvck5hbWU6ID8/P1xuICAgICAgLy8gYXV0aG9yRW1haWw6ID8/P1xuICAgICAgbWVzc2FnZTogZW52LlRSQVZJU19DT01NSVRfTUVTU0FHRSxcbiAgICAgIC8vIHJlbW90ZU9yaWdpbjogPz8/XG4gICAgICAvLyBkZWZhdWx0QnJhbmNoOiA/Pz9cbiAgICB9LFxuICAgIHdlcmNrZXI6IG51bGwsXG4gICAgbmV0bGlmeToge1xuICAgICAgc2hhOiBlbnYuQ09NTUlUX1JFRixcbiAgICAgIGJyYW5jaDogZW52LkJSQU5DSCxcbiAgICAgIHJlbW90ZU9yaWdpbjogZW52LlJFUE9TSVRPUllfVVJMLFxuICAgIH0sXG4gICAgbGF5ZXJjaToge1xuICAgICAgc2hhOiBlbnYuR0lUX0NPTU1JVCxcbiAgICAgIGJyYW5jaDogZW52LkxBWUVSQ0lfQlJBTkNILFxuICAgICAgbWVzc2FnZTogZW52LkdJVF9DT01NSVRfVElUTEUsXG4gICAgfSxcbiAgfTtcbn07XG5cbnR5cGUgQ2lQcm92aWRlckRhdGEgPSB7XG4gIHNoYT86IHN0cmluZztcbiAgYnJhbmNoPzogc3RyaW5nO1xuICBtZXNzYWdlPzogc3RyaW5nO1xuICBhdXRob3JOYW1lPzogc3RyaW5nO1xuICBhdXRob3JFbWFpbD86IHN0cmluZztcbiAgcmVtb3RlT3JpZ2luPzogc3RyaW5nO1xuICBkZWZhdWx0QnJhbmNoPzogc3RyaW5nO1xuICByZW1vdGVCcmFuY2g/OiBzdHJpbmc7XG4gIHJ1bkF0dGVtcHQ/OiBzdHJpbmc7XG59O1xuXG5pbnRlcmZhY2UgUHJvdmlkZXJDb21taXRQYXJhbXNSZXMge1xuICBba2V5OiBzdHJpbmddOiBDaVByb3ZpZGVyRGF0YSB8IG51bGw7XG59XG5cbmludGVyZmFjZSBQcm92aWRlckNpUGFyYW1zUmVzIHtcbiAgW2tleTogc3RyaW5nXToge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgfSB8IG51bGw7XG59XG5cbmNvbnN0IF9nZXQgPSAoZm46ICgpID0+IFByb3ZpZGVyQ29tbWl0UGFyYW1zUmVzIHwgUHJvdmlkZXJDaVBhcmFtc1JlcykgPT4ge1xuICBjb25zdCBwcm92aWRlck5hbWUgPSBnZXRDaVByb3ZpZGVyKCk7XG4gIGlmICghcHJvdmlkZXJOYW1lKSByZXR1cm4ge307XG5cbiAgcmV0dXJuIF8uY2hhaW4oZm4oKSkuZ2V0KHByb3ZpZGVyTmFtZSkudmFsdWUoKTtcbn07XG5cbi8qKlxuICogSWYgdGhlcmUgaXMgbm8gYnVpbGQgSUQgc3BlY2lmaWNhbGx5IHByb3ZpZGVkIGJ5IHVzZXJcbiAqIENoZWNrIGlmIHdlIGNhbiBmZXRjaCBpdCBhdXRvbWF0aWNhbGx5IGZyb20gQ0kgdmFyaWFibGVzLlxuICogVGhlIHByb2Nlc3Mgd2lsbCBzdG9wIGlmIHdlIGNhbm5vdCBkbyBpdFxuICogaHR0cHM6Ly9kb2NzLmN5cHJlc3MuaW8vZ3VpZGVzL3JlZmVyZW5jZXMvZXJyb3ItbWVzc2FnZXMjV2UtY291bGQtbm90LWRldGVybWluZS1hLXVuaXF1ZS1DSS1idWlsZC1JRFxuICovXG5mdW5jdGlvbiBjaGVja0ZvckNpQnVpbGRGcm9tQ2koY2lQcm92aWRlcjogc3RyaW5nIHwgbnVsbCkge1xuICBpZiAoY2lQcm92aWRlciAmJiBkZXRlY3RhYmxlQ2lCdWlsZElkUHJvdmlkZXJzKCkuaW5jbHVkZXMoY2lQcm92aWRlcikpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcbiAgICBgQ291bGQgbm90IGRldGVybWluZSBDSSBidWlsZCBJRCBmcm9tIHRoZSBlbnZpcm9ubWVudC4gUGxlYXNlIHByb3ZpZGUgYSB1bmlxdWUgQ0kgYnVpbGQgSUQgdXNpbmcgdGhlIC0tY2ktYnVpbGQtaWQgQ0xJIGZsYWcgb3IgJ2NpQnVpbGRJZCcgcGFyYW1ldGVyIGZvciAncnVuJyBtZXRob2QuYFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlzdCgpIHtcbiAgcmV0dXJuIF8ua2V5cyhDSV9QUk9WSURFUlMpO1xufVxuXG4vLyBncmFiIGFsbCBkZXRlY3RhYmxlIHByb3ZpZGVyc1xuLy8gdGhhdCB3ZSBjYW4gZXh0cmFjdCBjaUJ1aWxkSWQgZnJvbVxuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdGFibGVDaUJ1aWxkSWRQcm92aWRlcnMoKSB7XG4gIHJldHVybiBfLmNoYWluKF9wcm92aWRlckNpUGFyYW1zKCkpLm9taXRCeShfLmlzTnVsbCkua2V5cygpLnZhbHVlKCk7XG59XG5cbmV4cG9ydCB0eXBlIENpUHJvdmlkZXIgPSBzdHJpbmcgfCBudWxsO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2lQcm92aWRlcigpOiBDaVByb3ZpZGVyIHtcbiAgcmV0dXJuIF9kZXRlY3RQcm92aWRlck5hbWUoKSB8fCBudWxsO1xufVxuXG5leHBvcnQgdHlwZSBDaVBhcmFtcyA9IHtcbiAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldENpUGFyYW1zKCkge1xuICByZXR1cm4gX2dldChfcHJvdmlkZXJDaVBhcmFtcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21taXRQYXJhbXMoKSB7XG4gIHJldHVybiBfZ2V0KF9wcm92aWRlckNvbW1pdFBhcmFtcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDSShjaUJ1aWxkSWQ/OiBzdHJpbmcpIHtcbiAgY29uc3QgcGFyYW1zID0gZ2V0Q2lQYXJhbXMoKTtcbiAgY29uc3QgcHJvdmlkZXIgPSBnZXRDaVByb3ZpZGVyKCk7XG4gIGlmICghY2lCdWlsZElkKSBjaGVja0ZvckNpQnVpbGRGcm9tQ2kocHJvdmlkZXIpO1xuXG4gIGRlYnVnKFwiZGV0ZWN0ZWQgQ0kgcHJvdmlkZXI6ICVzXCIsIHByb3ZpZGVyKTtcbiAgZGVidWcoXCJkZXRlY3RlZCBDSSBwYXJhbXM6ICVPXCIsIHBhcmFtcyk7XG4gIHJldHVybiB7XG4gICAgcGFyYW1zLFxuICAgIHByb3ZpZGVyLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tbWl0RGVmYXVsdHMoZXhpc3RpbmdJbmZvOiBDaVByb3ZpZGVyRGF0YSkge1xuICBkZWJ1ZyhcImdpdCBjb21taXQgZXhpc3RpbmcgaW5mb1wiKTtcbiAgZGVidWcoZXhpc3RpbmdJbmZvKTtcblxuICBjb25zdCBjb21taXRQYXJhbXNPYmogPSBnZXRDb21taXRQYXJhbXMoKTtcblxuICBkZWJ1ZyhcImNvbW1pdCBpbmZvIGZyb20gcHJvdmlkZXIgZW52aXJvbm1lbnQgdmFyaWFibGVzOiAlT1wiLCBjb21taXRQYXJhbXNPYmopO1xuXG4gIC8vIGJhc2VkIG9uIHRoZSBleGlzdGluZ0luZm8gcHJvcGVydGllc1xuICAvLyBtZXJnZSBpbiB0aGUgY29tbWl0UGFyYW1zIGlmIG51bGwgb3IgdW5kZWZpbmVkXG4gIC8vIGRlZmF1bHRpbmcgYmFjayB0byBudWxsIGlmIGFsbCBmYWlsc1xuICAvLyBOT1RFOiBvbmx5IHByb3BlcnRpZXMgZGVmaW5lZCBpbiBcImV4aXN0aW5nSW5mb1wiIHdpbGwgYmUgcmV0dXJuZWRcbiAgY29uc3QgY29tYmluZWQgPSBfLnRyYW5zZm9ybShcbiAgICBleGlzdGluZ0luZm8sXG4gICAgKFxuICAgICAgbWVtbzogeyBbbWVtb0tleTogc3RyaW5nXTogc3RyaW5nIHwgbnVsbCB9LFxuICAgICAgdmFsdWU6IHN0cmluZyxcbiAgICAgIGtleTogc3RyaW5nXG4gICAgKSA9PiB7XG4gICAgICByZXR1cm4gKG1lbW9ba2V5XSA9IF8uZGVmYXVsdFRvKHZhbHVlIHx8IGNvbW1pdFBhcmFtc09ialtrZXldLCBudWxsKSk7XG4gICAgfVxuICApO1xuXG4gIGRlYnVnKFwiY29tYmluZWQgZ2l0IGFuZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZnJvbSBwcm92aWRlclwiKTtcbiAgZGVidWcoY29tYmluZWQpO1xuXG4gIHJldHVybiBjb21iaW5lZDtcbn1cbiIsICJleHBvcnQgKiBmcm9tIFwiLi9jb25maWdcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3BhcmFtc1wiO1xuIiwgImltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgeyBEZXRlY3RlZEJyb3dzZXIsIFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycyB9IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuaW1wb3J0IHsgYm9vdEN5cHJlc3MgfSBmcm9tIFwiLi4vYm9vdHN0cmFwXCI7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSBcIi4uL2xvZ1wiO1xuaW1wb3J0IHsgcmVxdWlyZSB9IGZyb20gXCIuLi9yZXF1aXJlXCI7XG5pbXBvcnQgeyBnZXRSYW5kb21Qb3J0IH0gZnJvbSBcIi4uL3V0aWxzXCI7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpjb25maWdcIik7XG5cbmV4cG9ydCB0eXBlIEUyRUNvbmZpZyA9IHtcbiAgYmF0Y2hTaXplOiBudW1iZXI7XG59O1xuZXhwb3J0IHR5cGUgQ29tcG9uZW50Q29uZmlnID0ge1xuICBiYXRjaFNpemU6IG51bWJlcjtcbn07XG5leHBvcnQgdHlwZSBDdXJyZW50c0NvbmZpZyA9IHtcbiAgcHJvamVjdElkPzogc3RyaW5nO1xuICByZWNvcmRLZXk/OiBzdHJpbmc7XG4gIGNsb3VkU2VydmljZVVybDogc3RyaW5nO1xuICBlMmU6IEUyRUNvbmZpZztcbiAgY29tcG9uZW50OiBDb21wb25lbnRDb25maWc7XG59O1xuXG5sZXQgX2NvbmZpZzogQ3VycmVudHNDb25maWcgfCBudWxsID0gbnVsbDtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRzQ29uZmlnKHByb2plY3RSb290Pzogc3RyaW5nKTogQ3VycmVudHNDb25maWcge1xuICBpZiAoX2NvbmZpZykge1xuICAgIHJldHVybiBfY29uZmlnO1xuICB9XG4gIGNvbnN0IGRlZmF1bHRDb25maWc6IEN1cnJlbnRzQ29uZmlnID0ge1xuICAgIGUyZToge1xuICAgICAgYmF0Y2hTaXplOiAzLFxuICAgIH0sXG4gICAgY29tcG9uZW50OiB7XG4gICAgICBiYXRjaFNpemU6IDUsXG4gICAgfSxcbiAgICBjbG91ZFNlcnZpY2VVcmw6IFwiaHR0cHM6Ly9jeS5jdXJyZW50cy5kZXZcIixcbiAgfTtcblxuICBjb25zdCBjb25maWdGaWxlUGF0aCA9IGdldENvbmZpZ0ZpbGVQYXRoKHByb2plY3RSb290KTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNvbHZlZFBhdGggPSBwYXRoLnJlc29sdmUoLi4uY29uZmlnRmlsZVBhdGgpO1xuICAgIGRlYnVnKFwibG9hZGluZyBjdXJyZW50cyBjb25maWcgZmlsZSBmcm9tICclcydcIiwgcmVzb2x2ZWRQYXRoKTtcblxuICAgIGNvbnN0IGZzQ29uZmlnID0gcmVxdWlyZShyZXNvbHZlZFBhdGgpO1xuICAgIF9jb25maWcgPSB7XG4gICAgICAuLi5kZWZhdWx0Q29uZmlnLFxuICAgICAgLi4uZnNDb25maWcsXG4gICAgfSBhcyBDdXJyZW50c0NvbmZpZztcbiAgICByZXR1cm4gX2NvbmZpZztcbiAgfSBjYXRjaCAoZSkge1xuICAgIHdhcm4oXCJmYWlsZWQgdG8gbG9hZCBjb25maWcgZmlsZTogJXNcIiwgY29uZmlnRmlsZVBhdGgpO1xuICAgIGRlYnVnKFwiZmFpbHVyZSBkZXRhaWxzOiAlc1wiLCBlKTtcbiAgICBfY29uZmlnID0gZGVmYXVsdENvbmZpZztcbiAgICByZXR1cm4gX2NvbmZpZztcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBNZXJnZWRDb25maWcgPSBBd2FpdGVkPFJldHVyblR5cGU8dHlwZW9mIGdldE1lcmdlZENvbmZpZz4+O1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE1lcmdlZENvbmZpZyhwYXJhbXM6IFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycykge1xuICBkZWJ1ZyhcInJlc29sdmluZyBjeXByZXNzIGNvbmZpZ1wiKTtcbiAgY29uc3QgY3lwcmVzc1Jlc29sdmVkQ29uZmlnOlxuICAgIHwgKEN5cHJlc3MuUmVzb2x2ZWRDb25maWdPcHRpb25zICYge1xuICAgICAgICBwcm9qZWN0Um9vdDogc3RyaW5nO1xuICAgICAgICByYXdKc29uOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICAgICAgYnJvd3NlcnM6IERldGVjdGVkQnJvd3NlcltdO1xuICAgICAgfSlcbiAgICB8IHVuZGVmaW5lZCA9IGF3YWl0IGJvb3RDeXByZXNzKGdldFJhbmRvbVBvcnQoKSwgcGFyYW1zKTtcblxuICBkZWJ1ZyhcImN5cHJlc3MgcmVzb2x2ZWRDb25maWc6ICVPXCIsIGN5cHJlc3NSZXNvbHZlZENvbmZpZyk7XG5cbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCByYXdFMkVQYXR0ZXJuID0gY3lwcmVzc1Jlc29sdmVkQ29uZmlnLnJhd0pzb24/LmUyZT8uc3BlY1BhdHRlcm47XG4gIGxldCBhZGRpdGlvbmFsSWdub3JlUGF0dGVybjogc3RyaW5nW10gPSBbXTtcbiAgaWYgKHBhcmFtcy50ZXN0aW5nVHlwZSA9PT0gXCJjb21wb25lbnRcIiAmJiByYXdFMkVQYXR0ZXJuKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuID0gcmF3RTJFUGF0dGVybjtcbiAgfVxuXG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3lwcmVzcy1pby9jeXByZXNzL2Jsb2IvZWQwNjY4ZTI0YzJlZTY3NTNiYmQyNWFlNDY3Y2U5NGFlNTg1Nzc0MS9wYWNrYWdlcy9jb25maWcvc3JjL29wdGlvbnMudHMjTDQ1N1xuICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2N5cHJlc3MtaW8vY3lwcmVzcy9ibG9iL2RldmVsb3AvcGFja2FnZXMvY29uZmlnL3NyYy9wcm9qZWN0L3V0aWxzLnRzI0w0MTJcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHByb2plY3RSb290OiBjeXByZXNzUmVzb2x2ZWRDb25maWc/LnByb2plY3RSb290IHx8IHByb2Nlc3MuY3dkKCksXG4gICAgcHJvamVjdElkOiBwYXJhbXMucHJvamVjdElkLFxuICAgIHNwZWNQYXR0ZXJuOiBjeXByZXNzUmVzb2x2ZWRDb25maWc/LnNwZWNQYXR0ZXJuIHx8IFwiKiovKi4qXCIsXG4gICAgZXhjbHVkZVNwZWNQYXR0ZXJuOlxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY3lwcmVzc1Jlc29sdmVkQ29uZmlnPy5yZXNvbHZlZC5leGNsdWRlU3BlY1BhdHRlcm4udmFsdWUgPz8gW10sXG4gICAgYWRkaXRpb25hbElnbm9yZVBhdHRlcm4sXG4gICAgcmVzb2x2ZWQ6IGN5cHJlc3NSZXNvbHZlZENvbmZpZyxcbiAgfTtcbiAgZGVidWcoXCJtZXJnZWQgY29uZmlnOiAlT1wiLCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXRDb25maWdGaWxlUGF0aChwcm9qZWN0Um9vdDogc3RyaW5nIHwgbnVsbCA9IG51bGwpIHtcbiAgcmV0dXJuIFtwcm9qZWN0Um9vdCA/PyBwcm9jZXNzLmN3ZCgpLCBcImN1cnJlbnRzLmNvbmZpZy5qc1wiXTtcbn1cbiIsICJleHBvcnQgKiBmcm9tIFwiLi9ib290c3RyYXBcIjtcbiIsICJpbXBvcnQgeyBnZXRCaW5QYXRoIH0gZnJvbSBcImN5MlwiO1xuaW1wb3J0IHsgVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzIH0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBleGVjYSwgeyBFeGVjYUVycm9yIH0gZnJvbSBcImV4ZWNhXCI7XG5pbXBvcnQgZnMgZnJvbSBcImZzXCI7XG5pbXBvcnQgeyBWYWxpZGF0aW9uRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzXCI7XG5pbXBvcnQgeyBjcmVhdGVUZW1wRmlsZSB9IGZyb20gXCIuLi9mc1wiO1xuaW1wb3J0IHsgYm9sZCwgaW5mbyB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IHJlcXVpcmUgfSBmcm9tIFwiLi4vcmVxdWlyZVwiO1xuaW1wb3J0IHsgZ2V0Qm9vdHN0cmFwQXJncyB9IGZyb20gXCIuL3NlcmlhbGl6ZXJcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOmJvb3RcIik7XG5cbmV4cG9ydCBjb25zdCBib290Q3lwcmVzcyA9IGFzeW5jIChcbiAgcG9ydDogbnVtYmVyLFxuICBwYXJhbXM6IFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVyc1xuKSA9PiB7XG4gIGRlYnVnKFwiYm9vdGluZyBjeXByZXNzLi4uXCIpO1xuICBjb25zdCB0ZW1wRmlsZVBhdGggPSBhd2FpdCBjcmVhdGVUZW1wRmlsZSgpO1xuXG4gIGNvbnN0IGN5cHJlc3NCaW4gPSBhd2FpdCBnZXRCaW5QYXRoKHJlcXVpcmUucmVzb2x2ZShcImN5cHJlc3NcIikpO1xuICBkZWJ1ZyhcImN5cHJlc3MgZXhlY3V0YWJsZSBsb2NhdGlvbjogJXNcIiwgY3lwcmVzc0Jpbik7XG5cbiAgLy8gaXQgaXMgaW1wb3J0YW50IHRvIHBhc3MgdGhlIHNhbWUgYXJncyBpbiBvcmRlciB0byBnZXQgdGhlIHNhbWUgY29uZmlnIGFzIGZvciB0aGUgYWN0dWFsIHJ1blxuICBjb25zdCBhcmdzID0gZ2V0Qm9vdHN0cmFwQXJncyh7IHBvcnQsIHRlbXBGaWxlUGF0aCwgcGFyYW1zIH0pO1xuICBkZWJ1ZyhcImJvb3RpbmcgY3lwcmVzcyB3aXRoIGFyZ3M6ICVvXCIsIGFyZ3MpO1xuICBjb25zdCB7IHN0ZG91dCwgc3RkZXJyIH0gPSBhd2FpdCBleGVjQ3lwcmVzcyhjeXByZXNzQmluLCBhcmdzKTtcblxuICBpZiAoIWZzLmV4aXN0c1N5bmModGVtcEZpbGVQYXRoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW5ub3QgcmVzb2x2ZSBjeXByZXNzIGNvbmZpZ3VyYXRpb24gZnJvbSAke3RlbXBGaWxlUGF0aH0uIFBsZWFzZSByZXBvcnQgdGhlIGlzc3VlLmBcbiAgICApO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgZiA9IGZzLnJlYWRGaWxlU3luYyh0ZW1wRmlsZVBhdGgsIFwidXRmLThcIik7XG4gICAgaWYgKCFmKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJcyBjeXByZXNzLWNsb3VkL3BsdWdpbiBpbnN0YWxsZWQ/XCIpO1xuICAgIH1cbiAgICBkZWJ1ZyhcImN5cHJlc3MgY29uZmlnICclcyc6ICclcydcIiwgdGVtcEZpbGVQYXRoLCBmKTtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShmKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVidWcoXCJyZWFkIGNvbmZpZyB0ZW1wIGZpbGUgZmFpbGVkOiAlb1wiLCBlcnIpO1xuICAgIGluZm8oYm9sZChcIkN5cHJlc3Mgc3Rkb3V0OlxcblwiKSwgc3Rkb3V0KTtcbiAgICBpbmZvKGJvbGQoXCJDeXByZXNzIHN0ZGVycjpcXG5cIiksIHN0ZGVycik7XG5cbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBVbmFibGUgdG8gcmVzb2x2ZSBjeXByZXNzIGNvbmZpZ3VyYXRpb25cbi0gbWFrZSBzdXJlIHRoYXQgJ2N5cHJlc3MtY2xvdWQvcGx1Z2luJyBpcyBpbnN0YWxsZWRcbi0gcmVwb3J0IHRoZSBpc3N1ZSB0b2dldGhlciB3aXRoIGN5cHJlc3Mgc3Rkb3V0IGFuZCBzdGRlcnJcbmApO1xuICB9XG59O1xuXG5hc3luYyBmdW5jdGlvbiBleGVjQ3lwcmVzcyhjeXByZXNzQmluOiBzdHJpbmcsIGFyZ3M6IHJlYWRvbmx5IHN0cmluZ1tdKSB7XG4gIGxldCBzdGRvdXQgPSBcIlwiO1xuICBsZXQgc3RkZXJyID0gXCJcIjtcbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjYShjeXByZXNzQmluLCBbXCJydW5cIiwgLi4uYXJnc10sIHtcbiAgICAgIHN0ZGlvOiBcInBpcGVcIixcbiAgICAgIGVudjoge1xuICAgICAgICAuLi5wcm9jZXNzLmVudixcbiAgICAgICAgLy8gcHJldmVudCB3YXJuaW5ncyBhYm91dCByZWNvcmRpbmcgbW9kZVxuICAgICAgICBDWVBSRVNTX1JFQ09SRF9LRVk6IHVuZGVmaW5lZCxcbiAgICAgICAgQ1lQUkVTU19QUk9KRUNUX0lEOiB1bmRlZmluZWQsXG4gICAgICB9LFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWJ1ZyhcImV4ZWMgY3lwcmVzcyBmYWlsZWQgKGNlcnRhaW4gZmFpbHVyZXMgYXJlIGV4cGVjdGVkKTogJW9cIiwgZXJyKTtcbiAgICBzdGRvdXQgPSAoZXJyIGFzIEV4ZWNhRXJyb3IpLnN0ZG91dDtcbiAgICBzdGRlcnIgPSAoZXJyIGFzIEV4ZWNhRXJyb3IpLnN0ZGVycjtcbiAgfVxuICByZXR1cm4geyBzdGRvdXQsIHN0ZGVyciB9O1xufVxuIiwgImltcG9ydCB7IGZpbGUgfSBmcm9tIFwidG1wLXByb21pc2VcIjtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVRlbXBGaWxlID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCB7IHBhdGggfSA9IGF3YWl0IGZpbGUoKTtcbiAgcmV0dXJuIHBhdGg7XG59O1xuIiwgImltcG9ydCB7XG4gIEN1cnJlbnRzUnVuUGFyYW1ldGVycyxcbiAgQ3lwcmVzc1J1blBhcmFtZXRlcnMsXG59IGZyb20gXCJjeXByZXNzLWNsb3VkL3R5cGVzXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgeyBjdXN0b21BbHBoYWJldCB9IGZyb20gXCJuYW5vaWRcIjtcbmltcG9ydCB7IGdldEN5cHJlc3NSdW5BUElQYXJhbXMgfSBmcm9tIFwiLi4vY29uZmlnXCI7XG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6Ym9vdFwiKTtcblxuY29uc3QgZ2V0RHVtbXlTcGVjID0gY3VzdG9tQWxwaGFiZXQoXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLCAxMCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRCb290c3RyYXBBcmdzKHtcbiAgcGFyYW1zLFxuICBwb3J0LFxuICB0ZW1wRmlsZVBhdGgsXG59OiB7XG4gIHBhcmFtczogQ3VycmVudHNSdW5QYXJhbWV0ZXJzO1xuICBwb3J0OiBudW1iZXI7XG4gIHRlbXBGaWxlUGF0aDogc3RyaW5nO1xufSkge1xuICByZXR1cm4gXy5jaGFpbihnZXRDeXByZXNzQ0xJUGFyYW1zKHBhcmFtcykpXG4gICAgLnRocnUoKG9wdHMpID0+ICh7XG4gICAgICAuLi5vcHRzLFxuICAgICAgLy8gbWVyZ2UgdGhlIGVudiB3aXRoIHRoZSBjdXJyZW50cyBzcGVjaWZpYyBlbnYgdmFyaWFibGVzXG4gICAgICBlbnY6IHtcbiAgICAgICAgLi4uKG9wdHMuZW52ID8/IHt9KSxcbiAgICAgICAgY3VycmVudHNfdGVtcF9maWxlOiB0ZW1wRmlsZVBhdGgsXG4gICAgICAgIGN1cnJlbnRzX3BvcnQ6IHBvcnQsXG4gICAgICAgIGN1cnJlbnRzX2RlYnVnX2VuYWJsZWQ6IHByb2Nlc3MuZW52LkRFQlVHPy5pbmNsdWRlcyhcImN1cnJlbnRzOlwiKVxuICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgIDogZmFsc2UsXG4gICAgICB9LFxuICAgIH0pKVxuICAgIC50YXAoKG9wdHMpID0+IHtcbiAgICAgIGRlYnVnKFwiY3lwcmVzcyBib290c3RyYXAgcGFyYW1zOiAlb1wiLCBvcHRzKTtcbiAgICB9KVxuICAgIC50aHJ1KHNlcmlhbGl6ZU9wdGlvbnMpXG4gICAgLnRhcCgob3B0cykgPT4ge1xuICAgICAgZGVidWcoXCJjeXByZXNzIGJvb3RzdHJhcCBzZXJpYWxpemVkIHBhcmFtczogJW9cIiwgb3B0cyk7XG4gICAgfSlcbiAgICAudGhydSgoYXJncykgPT4ge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgLi4uYXJncyxcbiAgICAgICAgXCItLXNwZWNcIixcbiAgICAgICAgZ2V0RHVtbXlTcGVjKCksXG4gICAgICAgIHBhcmFtcy50ZXN0aW5nVHlwZSA9PT0gXCJjb21wb25lbnRcIiA/IFwiLS1jb21wb25lbnRcIiA6IFwiLS1lMmVcIixcbiAgICAgIF07XG4gICAgfSlcbiAgICAudmFsdWUoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBDdXJyZW50cyBvcHRpb25zIHRvIEN5cHJlc3MgQ0xJIHBhcmFtcy5cbiAqIEN5cHJlc3MgQ0xJIG9wdGlvbnMgYXJlIGRpZmZlcmVudCBmcm9tIEN5cHJlc3MgbW9kdWxlIEFQSSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBwYXJhbXMgQ3VycmVudHMgcGFyYW1cbiAqIEByZXR1cm5zIEN5cHJlc3MgQ0xJIHBhcmFtc1xuICogQHNlZSBodHRwczovL2RvY3MuY3lwcmVzcy5pby9ndWlkZXMvZ3VpZGVzL2NvbW1hbmQtbGluZSNjeXByZXNzLXJ1blxuICogQHNlZSBodHRwczovL2RvY3MuY3lwcmVzcy5pby9hcGkvbW9kdWxlLWFwaVxuICovXG5mdW5jdGlvbiBnZXRDeXByZXNzQ0xJUGFyYW1zKFxuICBwYXJhbXM6IEN1cnJlbnRzUnVuUGFyYW1ldGVyc1xuKTogQ3lwcmVzc1J1blBhcmFtZXRlcnMge1xuICBjb25zdCByZXN1bHQgPSBnZXRDeXByZXNzUnVuQVBJUGFyYW1zKHBhcmFtcyk7XG4gIGNvbnN0IHRlc3RpbmdUeXBlID1cbiAgICByZXN1bHQudGVzdGluZ1R5cGUgPT09IFwiY29tcG9uZW50XCJcbiAgICAgID8ge1xuICAgICAgICAgIGNvbXBvbmVudDogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgOiB7fTtcbiAgcmV0dXJuIHtcbiAgICAuLi5fLm9taXQocmVzdWx0LCBcInRlc3RpbmdUeXBlXCIpLFxuICAgIC4uLnRlc3RpbmdUeXBlLFxuICB9O1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVPcHRpb25zKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogc3RyaW5nW10ge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMob3B0aW9ucykuZmxhdE1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgX2tleSA9IGRhc2hlZChrZXkpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgPyBbYC0tJHtfa2V5fWBdIDogW2AtLSR7X2tleX1gLCBmYWxzZV07XG4gICAgfVxuXG4gICAgaWYgKF8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gW2AtLSR7X2tleX1gLCBzZXJpYWxpemVDb21wbGV4UGFyYW0odmFsdWUpXTtcbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIFtgLS0ke19rZXl9YCwgdmFsdWUudG9TdHJpbmcoKV07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVDb21wbGV4UGFyYW0ocGFyYW06IHt9KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJhbSk7XG59XG5cbmNvbnN0IGRhc2hlZCA9ICh2OiBzdHJpbmcpID0+IHYucmVwbGFjZSgvW0EtWl0vZywgKG0pID0+IFwiLVwiICsgbS50b0xvd2VyQ2FzZSgpKTtcbiIsICJpbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gdG9BcnJheSh2YWw/OiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICByZXR1cm4gdmFsID8gKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgPyBbdmFsXSA6IHZhbCkgOiBbXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvUG9zaXgoZmlsZTogc3RyaW5nLCBzZXA6IHN0cmluZyA9IHBhdGguc2VwKSB7XG4gIHJldHVybiBmaWxlLnNwbGl0KHNlcCkuam9pbihwYXRoLnBvc2l4LnNlcCk7XG59XG5cbmV4cG9ydCBjb25zdCBnZXRSYW5kb21Qb3J0ID0gKCkgPT4ge1xuICBjb25zdCBtaW4gPSAxMDI0O1xuICBjb25zdCBtYXggPSA2NTUzNTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XG59O1xuIiwgImltcG9ydCB7XG4gIEN1cnJlbnRzUnVuUGFyYW1ldGVycyxcbiAgQ3lwcmVzc1J1blBhcmFtZXRlcnMsXG4gIFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycyxcbn0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCB7IFZhbGlkYXRpb25FcnJvciB9IGZyb20gXCIuLi9lcnJvcnNcIjtcbmltcG9ydCB7IGVycm9yIH0gZnJvbSBcIi4uL2xvZ1wiO1xuaW1wb3J0IHsgZ2V0Q3VycmVudHNDb25maWcgfSBmcm9tIFwiLi9jb25maWdcIjtcbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czp2YWxpZGF0ZVBhcmFtc1wiKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVDdXJyZW50c1BhcmFtcyhcbiAgcGFyYW1zOiBDdXJyZW50c1J1blBhcmFtZXRlcnNcbik6IEN1cnJlbnRzUnVuUGFyYW1ldGVycyB7XG4gIGNvbnN0IGNvbmZpZ0Zyb21GaWxlID0gZ2V0Q3VycmVudHNDb25maWcocGFyYW1zLnByb2plY3QpO1xuXG4gIGNvbnN0IGNsb3VkU2VydmljZVVybCA9XG4gICAgcGFyYW1zLmNsb3VkU2VydmljZVVybCA/P1xuICAgIHByb2Nlc3MuZW52LkNVUlJFTlRTX0FQSV9VUkwgPz9cbiAgICBjb25maWdGcm9tRmlsZS5jbG91ZFNlcnZpY2VVcmw7XG5cbiAgY29uc3QgcmVjb3JkS2V5ID1cbiAgICBwYXJhbXMucmVjb3JkS2V5ID8/XG4gICAgcHJvY2Vzcy5lbnYuQ1VSUkVOVFNfUkVDT1JEX0tFWSA/P1xuICAgIGNvbmZpZ0Zyb21GaWxlLnJlY29yZEtleTtcblxuICBjb25zdCBwcm9qZWN0SWQgPVxuICAgIHBhcmFtcy5wcm9qZWN0SWQgPz9cbiAgICBwcm9jZXNzLmVudi5DVVJSRU5UU19QUk9KRUNUX0lEID8/XG4gICAgY29uZmlnRnJvbUZpbGUucHJvamVjdElkO1xuXG4gIGNvbnN0IHRlc3RpbmdUeXBlID0gcGFyYW1zLnRlc3RpbmdUeXBlID8/IFwiZTJlXCI7XG5cbiAgY29uc3QgYmF0Y2hTaXplID1cbiAgICB0ZXN0aW5nVHlwZSA9PT0gXCJlMmVcIlxuICAgICAgPyBjb25maWdGcm9tRmlsZS5lMmUuYmF0Y2hTaXplXG4gICAgICA6IGNvbmZpZ0Zyb21GaWxlLmNvbXBvbmVudC5iYXRjaFNpemU7XG5cbiAgLy8gYmF0Y2hTaXplIGFuZCBjbG91ZFNlcnZpY2VVcmwgZGVmYXVsdHMgYXJlIGluIGdldEN1cnJlbnRzQ29uZmlnKClcbiAgcmV0dXJuIHtcbiAgICAuLi5wYXJhbXMsXG4gICAgY2xvdWRTZXJ2aWNlVXJsLFxuICAgIHJlY29yZEtleSxcbiAgICBwcm9qZWN0SWQsXG4gICAgYmF0Y2hTaXplLFxuICAgIHRlc3RpbmdUeXBlLFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgcHJvamVjdElkRXJyb3IgPSBgQ2Fubm90IHJlc29sdmUgcHJvamVjdElkLiBQbGVhc2UgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuLSBwcm92aWRlIGl0IGFzIGEgXCJwcm9qZWN0SWRcIiBwcm9wZXJ0eSBmb3IgXCJydW5cIiBBUEkgbWV0aG9kXG4tIHNldCBDVVJSRU5UU19QUk9KRUNUX0lEIGVudmlyb25tZW50IHZhcmlhYmxlXG4tIHNldCBcInByb2plY3RJZFwiIGluIFwiY3VycmVudHMuY29uZmlnLmpzXCIgZmlsZWA7XG5cbmV4cG9ydCBjb25zdCBjbG91ZFNlcnZpY2VVcmxFcnJvciA9IGBDYW5ub3QgcmVzb2x2ZSBjbG91ZCBzZXJ2aWNlIFVSTC4gUGxlYXNlIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbi0gcHJvdmlkZSBpdCBhcyBhIFwiY2xvdWRTZXJ2aWNlVXJsXCIgcHJvcGVydHkgZm9yIFwicnVuXCIgQVBJIG1ldGhvZFxuLSBzZXQgQ1VSUkVOVFNfQVBJX1VSTCBlbnZpcm9ubWVudCB2YXJpYWJsZVxuLSBzZXQgXCJjbG91ZFNlcnZpY2VVcmxcIiBpbiBcImN1cnJlbnRzLmNvbmZpZy5qc1wiIGZpbGVgO1xuXG5leHBvcnQgY29uc3QgY2xvdWRTZXJ2aWNlSW52YWxpZFVybEVycm9yID0gYEludmFsaWQgY2xvdWQgc2VydmljZSBVUkwgcHJvdmlkZWRgO1xuXG5leHBvcnQgY29uc3QgcmVjb3JkS2V5RXJyb3IgPSBgQ2Fubm90IHJlc29sdmUgcmVjb3JkIGtleS4gUGxlYXNlIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcblxuLSBwYXNzIGl0IGFzIGEgQ0xJIGZsYWcgJy1rLCAtLWtleSA8cmVjb3JkLWtleT4nXG4tIHByb3ZpZGUgaXQgYXMgYSBcInJlY29yZEtleVwiIHByb3BlcnR5IGZvciBcInJ1blwiIEFQSSBtZXRob2Rcbi0gc2V0IENVUlJFTlRTX1JFQ09SRF9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGVcbi0gc2V0IFwicmVjb3JkS2V5XCIgaW4gXCJjdXJyZW50cy5jb25maWcuanNcIiBmaWxlXG5gO1xuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVQYXJhbXMoXG4gIF9wYXJhbXM6IEN1cnJlbnRzUnVuUGFyYW1ldGVyc1xuKTogVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzIHtcbiAgY29uc3QgcGFyYW1zID0gcmVzb2x2ZUN1cnJlbnRzUGFyYW1zKF9wYXJhbXMpO1xuXG4gIGlmICghcGFyYW1zLmNsb3VkU2VydmljZVVybCkge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoY2xvdWRTZXJ2aWNlVXJsRXJyb3IpO1xuICB9XG4gIGlmICghcGFyYW1zLnByb2plY3RJZCkge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IocHJvamVjdElkRXJyb3IpO1xuICB9XG4gIGlmICghcGFyYW1zLnJlY29yZEtleSkge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IocmVjb3JkS2V5RXJyb3IpO1xuICB9XG5cbiAgdmFsaWRhdGVVUkwocGFyYW1zLmNsb3VkU2VydmljZVVybCk7XG5cbiAgY29uc3QgcmVxdWlyZWRQYXJhbWV0ZXJzOiBBcnJheTxrZXlvZiBDdXJyZW50c1J1blBhcmFtZXRlcnM+ID0gW1xuICAgIFwidGVzdGluZ1R5cGVcIixcbiAgICBcImJhdGNoU2l6ZVwiLFxuICAgIFwicHJvamVjdElkXCIsXG4gIF07XG4gIHJlcXVpcmVkUGFyYW1ldGVycy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAodHlwZW9mIHBhcmFtc1trZXldID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBlcnJvcignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgXCIlc1wiJywga2V5KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyXCIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcGFyYW1zLnRhZyA9IHBhcnNlVGFncyhwYXJhbXMudGFnKTtcbiAgcGFyYW1zLmF1dG9DYW5jZWxBZnRlckZhaWx1cmVzID0gZ2V0QXV0b0NhbmNlbFZhbHVlKFxuICAgIHBhcmFtcy5hdXRvQ2FuY2VsQWZ0ZXJGYWlsdXJlc1xuICApO1xuXG4gIGRlYnVnKFwidmFsaWRhdGVkIGN1cnJlbnRzIHBhcmFtczogJW9cIiwgcGFyYW1zKTtcblxuICAvLyBUT0RPOiByZW1vdmUgdGhpcyBjYXN0IGFmdGVyIGZpbmRpbmcgYSB3YXkgdG8gcHJvcGVybHkgcmVzb2x2ZSBwYXJhbXMgdHlwZSBhZnRlciB2YWxpZGF0aW9uc1xuICByZXR1cm4gcGFyYW1zIGFzIFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycztcbn1cblxuZnVuY3Rpb24gZ2V0QXV0b0NhbmNlbFZhbHVlKHZhbHVlOiB1bmtub3duKTogbnVtYmVyIHwgZmFsc2UgfCB1bmRlZmluZWQge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiB2YWx1ZSA/IDEgOiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUgPiAwKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcbiAgICBgYXV0b0NhbmNlbEFmdGVyRmFpbHVyZXM6IHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgXCJmYWxzZVwiLiBHb3Q6IFwiJHt2YWx1ZX1cImBcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT2ZmbGluZShwYXJhbXM6IEN1cnJlbnRzUnVuUGFyYW1ldGVycykge1xuICByZXR1cm4gcGFyYW1zLnJlY29yZCA9PT0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVGFncyh0YWdTdHJpbmc6IEN1cnJlbnRzUnVuUGFyYW1ldGVyc1tcInRhZ1wiXSk6IHN0cmluZ1tdIHtcbiAgaWYgKCF0YWdTdHJpbmcpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFnU3RyaW5nKSkge1xuICAgIHJldHVybiB0YWdTdHJpbmcuZmlsdGVyKEJvb2xlYW4pO1xuICB9XG4gIHJldHVybiB0YWdTdHJpbmdcbiAgICAuc3BsaXQoXCIsXCIpXG4gICAgLm1hcCgodGFnKSA9PiB0YWcudHJpbSgpKVxuICAgIC5maWx0ZXIoQm9vbGVhbik7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVVJMKHVybDogc3RyaW5nKTogdm9pZCB7XG4gIHRyeSB7XG4gICAgbmV3IFVSTCh1cmwpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGAke2Nsb3VkU2VydmljZUludmFsaWRVcmxFcnJvcn06IFwiJHt1cmx9XCJgKTtcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJucyBDeXByZXNzIG9wdGlvbnMgd2l0aG91dCBpdGVtcyB0aGF0IGFmZmVjdCByZWNvcmRpbmcgbW9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3lwcmVzc1J1bkFQSVBhcmFtcyhcbiAgcGFyYW1zOiBDdXJyZW50c1J1blBhcmFtZXRlcnNcbik6IEN5cHJlc3NSdW5QYXJhbWV0ZXJzIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5fLnBpY2tCeShcbiAgICAgIF8ub21pdChwYXJhbXMsIFtcbiAgICAgICAgXCJhdXRvQ2FuY2VsQWZ0ZXJGYWlsdXJlc1wiLFxuICAgICAgICBcImNsb3VkU2VydmljZVVybFwiLFxuICAgICAgICBcImJhdGNoU2l6ZVwiLFxuICAgICAgICBcInByb2plY3RJZFwiLFxuICAgICAgICBcImtleVwiLFxuICAgICAgICBcInJlY29yZEtleVwiLFxuICAgICAgICBcInJlY29yZFwiLFxuICAgICAgICBcImdyb3VwXCIsXG4gICAgICAgIFwicGFyYWxsZWxcIixcbiAgICAgICAgXCJ0YWdcIixcbiAgICAgICAgXCJjaUJ1aWxkSWRcIixcbiAgICAgICAgXCJzcGVjXCIsXG4gICAgICAgIFwiZXhpdFwiLFxuICAgICAgICBcImhlYWRlZFwiLFxuICAgICAgICBcImhlYWRsZXNzXCIsXG4gICAgICBdKSxcbiAgICAgIEJvb2xlYW5cbiAgICApLFxuICAgIHJlY29yZDogZmFsc2UsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwcm9jZXNzUGFyYW1zKFxuICBwYXJhbXM6IEN1cnJlbnRzUnVuUGFyYW1ldGVyc1xuKTogQ3VycmVudHNSdW5QYXJhbWV0ZXJzIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5wYXJhbXMsXG4gICAgc3BlYzogcHJvY2Vzc1NwZWNQYXJhbShwYXJhbXMuc3BlYyksXG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NTcGVjUGFyYW0oXG4gIHNwZWM6IEN1cnJlbnRzUnVuUGFyYW1ldGVyc1tcInNwZWNcIl1cbik6IHN0cmluZ1tdIHwgdW5kZWZpbmVkIHtcbiAgaWYgKCFzcGVjKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHNwZWMpKSB7XG4gICAgcmV0dXJuIF8uZmxhdHRlbihzcGVjLm1hcCgoaSkgPT4gaS5zcGxpdChcIixcIikpKTtcbiAgfVxuXG4gIHJldHVybiBzcGVjLnNwbGl0KFwiLFwiKTtcbn1cbiIsICJleHBvcnQgKiBmcm9tIFwiLi9jeXByZXNzXCI7XG4iLCAiaW1wb3J0IGN5cHJlc3MgZnJvbSBcImN5cHJlc3NcIjtcbmltcG9ydCB7XG4gIEN1cnJlbnRzUnVuUGFyYW1ldGVycyxcbiAgQ3lwcmVzc1Jlc3VsdCxcbiAgVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzLFxufSBmcm9tIFwiY3lwcmVzcy1jbG91ZC90eXBlc1wiO1xuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHsgZ2V0Q3lwcmVzc1J1bkFQSVBhcmFtcyB9IGZyb20gXCIuLi9jb25maWdcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOmN5cHJlc3NcIik7XG5pbnRlcmZhY2UgUnVuQ3lwcmVzc1NwZWNGaWxlIHtcbiAgc3BlYzogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcnVuQmFyZUN5cHJlc3MocGFyYW1zOiBDdXJyZW50c1J1blBhcmFtZXRlcnMgPSB7fSkge1xuICAvLyByZXZlcnQgY3VycmVudHMgcGFyYW1zIHRvIGN5cHJlc3MgcGFyYW1zXG4gIC8vIGV4Y2x1ZGUgcmVjb3JkIG1vZGUgcGFyYW1zXG4gIGNvbnN0IHAgPSB7XG4gICAgLi4ucGFyYW1zLFxuICAgIGNpQnVpbGRJZDogdW5kZWZpbmVkLFxuICAgIHRhZzogdW5kZWZpbmVkLFxuICAgIHBhcmFsbGVsOiB1bmRlZmluZWQsXG4gICAgcmVjb3JkOiBmYWxzZSxcbiAgICBncm91cDogdW5kZWZpbmVkLFxuICAgIHNwZWM6IF8uZmxhdHRlbihwYXJhbXMuc3BlYykuam9pbihcIixcIiksXG4gIH07XG4gIGRlYnVnKFwiUnVubmluZyBiYXJlIEN5cHJlc3Mgd2l0aCBwYXJhbXMgJW9cIiwgcCk7XG4gIHJldHVybiBjeXByZXNzLnJ1bihwKTtcbn1cblxuLyoqXG4gKiBSdW4gQ3lwcmVzcyB0ZXN0cywgd2UgbmVlZCB0byBwYXNzIGRvd24gdGhlIHN0cmlwcGVkIG9wdGlvbnMgYXMgaWYgd2UndmUgcmVjZWl2ZWQgdGhlbSBmcm9tIHRoZSBDTElcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJ1blNwZWNGaWxlKFxuICB7IHNwZWMgfTogUnVuQ3lwcmVzc1NwZWNGaWxlLFxuICBjeXByZXNzUnVuT3B0aW9uczogVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzXG4pIHtcbiAgY29uc3QgcnVuQVBJT3B0aW9ucyA9IGdldEN5cHJlc3NSdW5BUElQYXJhbXMoY3lwcmVzc1J1bk9wdGlvbnMpO1xuXG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgLi4ucnVuQVBJT3B0aW9ucyxcbiAgICBjb25maWc6IHtcbiAgICAgIC4uLnJ1bkFQSU9wdGlvbnMuY29uZmlnLFxuICAgICAgdHJhc2hBc3NldHNCZWZvcmVSdW5zOiBmYWxzZSxcbiAgICB9LFxuICAgIGVudjoge1xuICAgICAgLi4ucnVuQVBJT3B0aW9ucy5lbnYsXG4gICAgICBjdXJyZW50c193czogdHJ1ZSxcbiAgICB9LFxuICAgIHNwZWMsXG4gIH07XG4gIGRlYnVnKFwicnVubmluZyBjeXByZXNzIHdpdGggb3B0aW9ucyAlb1wiLCBvcHRpb25zKTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3lwcmVzcy5ydW4ob3B0aW9ucyk7XG5cbiAgZGVidWcoXCJjeXByZXNzIHJ1biByZXN1bHQgJW9cIiwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGNvbnN0IHJ1blNwZWNGaWxlU2FmZSA9IGFzeW5jIChcbiAgeyBzcGVjIH06IFJ1bkN5cHJlc3NTcGVjRmlsZSxcbiAgY3lwcmVzc1J1bk9wdGlvbnM6IFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVyc1xuKTogUHJvbWlzZTxDeXByZXNzUmVzdWx0PiA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IHJ1blNwZWNGaWxlKHsgc3BlYyB9LCBjeXByZXNzUnVuT3B0aW9ucyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZGVidWcoXCJjeXByZXNzIHJ1biBleGNlcHRpb24gJW9cIiwgZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IFwiZmFpbGVkXCIsXG4gICAgICBmYWlsdXJlczogMSxcbiAgICAgIG1lc3NhZ2U6IGBDeXByZXNzIHByb2Nlc3MgY3Jhc2hlZCB3aXRoIGFuIGVycm9yOlxcbiR7XG4gICAgICAgIChlcnJvciBhcyBFcnJvcikubWVzc2FnZVxuICAgICAgfVxcbiR7KGVycm9yIGFzIEVycm9yKS5zdGFja319YCxcbiAgICB9O1xuICB9XG59O1xuIiwgIi8vIEB0cy1pZ25vcmVcbmltcG9ydCBnaXQgZnJvbSBcIkBjeXByZXNzL2NvbW1pdC1pbmZvXCI7XG5pbXBvcnQgeyBnZXRDb21taXREZWZhdWx0cyB9IGZyb20gXCIuL2NpUHJvdmlkZXJcIjtcblxuZXhwb3J0IGNvbnN0IGdldEdpdEluZm8gPSBhc3luYyAocHJvamVjdFJvb3Q6IHN0cmluZykgPT4ge1xuICBjb25zdCBjb21taXRJbmZvID0gYXdhaXQgZ2l0LmNvbW1pdEluZm8ocHJvamVjdFJvb3QpO1xuICByZXR1cm4gZ2V0Q29tbWl0RGVmYXVsdHMoe1xuICAgIGJyYW5jaDogY29tbWl0SW5mby5icmFuY2gsXG4gICAgcmVtb3RlT3JpZ2luOiBjb21taXRJbmZvLnJlbW90ZSxcbiAgICBhdXRob3JFbWFpbDogY29tbWl0SW5mby5lbWFpbCxcbiAgICBhdXRob3JOYW1lOiBjb21taXRJbmZvLmF1dGhvcixcbiAgICBtZXNzYWdlOiBjb21taXRJbmZvLm1lc3NhZ2UsXG4gICAgc2hhOiBjb21taXRJbmZvLnNoYSxcbiAgfSk7XG59O1xuIiwgImltcG9ydCB7IE1lcmdlZENvbmZpZyB9IGZyb20gXCIuLi9jb25maWdcIjtcbmltcG9ydCB7IGd1ZXNzQnJvd3NlciB9IGZyb20gXCIuL2Jyb3dzZXJcIjtcbmltcG9ydCB7IGdldFBsYXRmb3JtSW5mbyB9IGZyb20gXCIuL3BsYXRmb3JtXCI7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQbGF0Zm9ybSh7XG4gIGJyb3dzZXIsXG4gIGNvbmZpZyxcbn06IHtcbiAgYnJvd3Nlcj86IHN0cmluZztcbiAgY29uZmlnOiBNZXJnZWRDb25maWc7XG59KSB7XG4gIHJldHVybiB7XG4gICAgLi4uKGF3YWl0IGdldFBsYXRmb3JtSW5mbygpKSxcbiAgICAuLi5ndWVzc0Jyb3dzZXIoYnJvd3NlciA/PyBcImVsZWN0cm9uXCIsIGNvbmZpZy5yZXNvbHZlZD8uYnJvd3NlcnMpLFxuICB9O1xufVxuIiwgImltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7IERldGVjdGVkQnJvd3NlciwgUGxhdGZvcm0gfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcbmltcG9ydCB7IHdhcm4gfSBmcm9tIFwiLi4vbG9nXCI7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpicm93c2VyXCIpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ3Vlc3NCcm93c2VyKFxuICBicm93c2VyOiBzdHJpbmcsXG4gIGF2YWlsYWJsZUJyb3dzZXJzOiBEZXRlY3RlZEJyb3dzZXJbXSA9IFtdXG4pOiBQaWNrPFBsYXRmb3JtLCBcImJyb3dzZXJOYW1lXCIgfCBcImJyb3dzZXJWZXJzaW9uXCI+IHtcbiAgZGVidWcoXG4gICAgXCJndWVzc2luZyBicm93c2VyIGZyb20gJyVzJywgYXZhaWxhYmxlIGJyb3dzZXJzOiAlb1wiLFxuICAgIGJyb3dzZXIsXG4gICAgYXZhaWxhYmxlQnJvd3NlcnNcbiAgKTtcbiAgLy8gdHJ5IGlkZW50aWZ5aW5nIHRoZSBicm93c2VyIGJ5IG5hbWUgZmlyc3RcbiAgbGV0IHJlc3VsdCA9IGF2YWlsYWJsZUJyb3dzZXJzLmZpbmQoKGIpID0+IGIubmFtZSA9PT0gYnJvd3Nlcik7XG5cbiAgaWYgKHJlc3VsdCkge1xuICAgIGRlYnVnKFwiaWRlbnRpZmllZCBicm93c2VyIGJ5IG5hbWU6ICVvXCIsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJyb3dzZXJOYW1lOiByZXN1bHQuZGlzcGxheU5hbWUsXG4gICAgICBicm93c2VyVmVyc2lvbjogcmVzdWx0LnZlcnNpb24sXG4gICAgfTtcbiAgfVxuXG4gIC8vIG90aGVyd2lzZSwgdHJ5IGlkZW50aWZ5aW5nIGJ5IHRoZSBwYXRoXG4gIHJlc3VsdCA9IGF2YWlsYWJsZUJyb3dzZXJzLmZpbmQoKGIpID0+IGIucGF0aCA9PT0gYnJvd3Nlcik7XG4gIGlmIChyZXN1bHQpIHtcbiAgICBkZWJ1ZyhcImlkZW50aWZpZWQgYnJvd3NlciBieSBwYXRoOiAlb1wiLCByZXN1bHQpO1xuICAgIHJldHVybiB7XG4gICAgICBicm93c2VyTmFtZTogcmVzdWx0LmRpc3BsYXlOYW1lID8/IHJlc3VsdC5uYW1lLFxuICAgICAgYnJvd3NlclZlcnNpb246IHJlc3VsdC52ZXJzaW9uLFxuICAgIH07XG4gIH1cblxuICB3YXJuKFwiVW5hYmxlIHRvIGlkZW50aWZ5IGJyb3dzZXIgbmFtZSBhbmQgdmVyc2lvblwiKTtcblxuICAvLyBvdGhlcndpc2UsIHJldHVybiBkdW1teSBicm93c2VyXG4gIHJldHVybiB7XG4gICAgYnJvd3Nlck5hbWU6IFwidW5rbm93blwiLFxuICAgIGJyb3dzZXJWZXJzaW9uOiBcInVua25vd25cIixcbiAgfTtcbn1cbiIsICJpbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgZ2V0b3MgZnJvbSBcImdldG9zXCI7XG5pbXBvcnQgeyBjcHVzLCBmcmVlbWVtLCBwbGF0Zm9ybSwgcmVsZWFzZSwgdG90YWxtZW0gfSBmcm9tIFwib3NcIjtcbmltcG9ydCB7IHByb21pc2lmeSB9IGZyb20gXCJ1dGlsXCI7XG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6cGxhdGZvcm1cIik7XG5cbmNvbnN0IGdldE9zVmVyc2lvbiA9IGFzeW5jICgpID0+IHtcbiAgaWYgKHBsYXRmb3JtKCkgPT09IFwibGludXhcIikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBsaW51eE9zID0gYXdhaXQgcHJvbWlzaWZ5KGdldG9zKSgpO1xuICAgICAgaWYgKFwiZGlzdFwiIGluIGxpbnV4T3MgJiYgXCJyZWxlYXNlXCIgaW4gbGludXhPcykge1xuICAgICAgICByZXR1cm4gW2xpbnV4T3MuZGlzdCwgbGludXhPcy5yZWxlYXNlXS5qb2luKFwiIC0gXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlbGVhc2UoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiByZWxlYXNlKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWxlYXNlKCk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0UGxhdGZvcm1JbmZvID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCBvc1ZlcnNpb24gPSBhd2FpdCBnZXRPc1ZlcnNpb24oKTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIG9zTmFtZTogcGxhdGZvcm0oKSxcbiAgICBvc1ZlcnNpb24sXG4gICAgb3NDcHVzOiBjcHVzKCksXG4gICAgb3NNZW1vcnk6IHtcbiAgICAgIGZyZWU6IGZyZWVtZW0oKSxcbiAgICAgIHRvdGFsOiB0b3RhbG1lbSgpLFxuICAgIH0sXG4gIH07XG4gIGRlYnVnKFwicGxhdGZvcm0gaW5mbzogJW9cIiwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCAiZXhwb3J0ICogZnJvbSBcIi4vcmVzdWx0c1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vdGFibGVcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3VwbG9hZFJlc3VsdHNcIjtcbiIsICJpbXBvcnQgeyBDeXByZXNzUmVzdWx0LCBTY3JlZW5zaG90QXJ0aWZhY3QgfSBmcm9tIFwiY3lwcmVzcy1jbG91ZC90eXBlc1wiO1xuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHsgbmFub2lkIH0gZnJvbSBcIm5hbm9pZFwiO1xuaW1wb3J0IHtcbiAgU2V0SW5zdGFuY2VUZXN0c1BheWxvYWQsXG4gIFRlc3RTdGF0ZSxcbiAgVXBkYXRlSW5zdGFuY2VSZXN1bHRzUGF5bG9hZCxcbn0gZnJvbSBcIi4uL2FwaVwiO1xuaW1wb3J0IHsgTWVyZ2VkQ29uZmlnIH0gZnJvbSBcIi4uL2NvbmZpZy9jb25maWdcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOnJlc3VsdHNcIik7XG5cbmV4cG9ydCBjb25zdCBpc1N1Y2Nlc3NSZXN1bHQgPSAoXG4gIHJlc3VsdDogQ3lwcmVzc1Jlc3VsdFxuKTogcmVzdWx0IGlzIEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0ID0+IHtcbiAgcmV0dXJuIHJlc3VsdC5zdGF0dXMgPT09IFwiZmluaXNoZWRcIjtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRTY3JlZW5zaG90c1N1bW1hcnkgPSAoXG4gIHRlc3RzOiBDeXByZXNzQ29tbWFuZExpbmUuVGVzdFJlc3VsdFtdID0gW11cbik6IFNjcmVlbnNob3RBcnRpZmFjdFtdID0+IHtcbiAgcmV0dXJuIHRlc3RzLmZsYXRNYXAoKHRlc3QsIGkpID0+XG4gICAgdGVzdC5hdHRlbXB0cy5mbGF0TWFwKChhLCBhaSkgPT5cbiAgICAgIGEuc2NyZWVuc2hvdHMuZmxhdE1hcCgocykgPT4gKHtcbiAgICAgICAgLi4ucyxcbiAgICAgICAgdGVzdElkOiBgciR7aX1gLFxuICAgICAgICB0ZXN0QXR0ZW1wdEluZGV4OiBhaSxcbiAgICAgICAgc2NyZWVuc2hvdElkOiBuYW5vaWQoKSxcbiAgICAgIH0pKVxuICAgIClcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRTdGF0cyA9IChzdGF0czogQ3lwcmVzc0NvbW1hbmRMaW5lLlJ1blJlc3VsdFtcInN0YXRzXCJdKSA9PiB7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdHMsXG4gICAgd2FsbENsb2NrRHVyYXRpb246IHN0YXRzLmR1cmF0aW9uLFxuICAgIHdhbGxDbG9ja1N0YXJ0ZWRBdDogc3RhdHMuc3RhcnRlZEF0LFxuICAgIHdhbGxDbG9ja0VuZGVkQXQ6IHN0YXRzLmVuZGVkQXQsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0VGVzdEF0dGVtcHQgPSAoYXR0ZW1wdDogQ3lwcmVzc0NvbW1hbmRMaW5lLkF0dGVtcHRSZXN1bHQpID0+IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5hdHRlbXB0LFxuICAgIHN0YXRlOiBhdHRlbXB0LnN0YXRlIGFzIFRlc3RTdGF0ZSxcbiAgICB3YWxsQ2xvY2tEdXJhdGlvbjogYXR0ZW1wdC5kdXJhdGlvbixcbiAgICB3YWxsQ2xvY2tTdGFydGVkQXQ6IGF0dGVtcHQuc3RhcnRlZEF0LFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEluc3RhbmNlUmVzdWx0UGF5bG9hZCA9IChcbiAgcnVuUmVzdWx0OiBDeXByZXNzQ29tbWFuZExpbmUuUnVuUmVzdWx0XG4pOiBVcGRhdGVJbnN0YW5jZVJlc3VsdHNQYXlsb2FkID0+IHtcbiAgY29uc3QgYWx0VGVzdHMgPSBbXTtcbiAgaWYgKHJ1blJlc3VsdC5lcnJvciAmJiAhcnVuUmVzdWx0LnRlc3RzPy5sZW5ndGgpIHtcbiAgICBhbHRUZXN0cy5wdXNoKGdldEZha2VUZXN0RnJvbUV4Y2VwdGlvbihydW5SZXN1bHQuZXJyb3IsIHJ1blJlc3VsdC5zdGF0cykpO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RhdHM6IGdldFN0YXRzKHJ1blJlc3VsdC5zdGF0cyksXG4gICAgcmVwb3J0ZXJTdGF0czogcnVuUmVzdWx0LnJlcG9ydGVyU3RhdHMsXG4gICAgZXhjZXB0aW9uOiBydW5SZXN1bHQuZXJyb3IgPz8gbnVsbCxcbiAgICB2aWRlbzogISFydW5SZXN1bHQudmlkZW8sIC8vIERpZCB0aGUgaW5zdGFuY2UgZ2VuZXJhdGUgYSB2aWRlbz9cbiAgICBzY3JlZW5zaG90czogZ2V0U2NyZWVuc2hvdHNTdW1tYXJ5KHJ1blJlc3VsdC50ZXN0cyA/PyBbXSksXG4gICAgdGVzdHM6XG4gICAgICBydW5SZXN1bHQudGVzdHM/Lm1hcCgodGVzdCwgaSkgPT4gKHtcbiAgICAgICAgZGlzcGxheUVycm9yOiB0ZXN0LmRpc3BsYXlFcnJvcixcbiAgICAgICAgc3RhdGU6IHRlc3Quc3RhdGUgYXMgVGVzdFN0YXRlLFxuICAgICAgICBob29rczogcnVuUmVzdWx0Lmhvb2tzLFxuICAgICAgICBhdHRlbXB0czogdGVzdC5hdHRlbXB0cz8ubWFwKGdldFRlc3RBdHRlbXB0KSA/PyBbXSxcbiAgICAgICAgY2xpZW50SWQ6IGByJHtpfWAsXG4gICAgICB9KSkgPz8gYWx0VGVzdHMsXG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRGYWtlVGVzdEZyb21FeGNlcHRpb24oXG4gIGVycm9yOiBzdHJpbmcsXG4gIHN0YXRzOiBDeXByZXNzQ29tbWFuZExpbmUuUnVuUmVzdWx0W1wic3RhdHNcIl1cbikge1xuICByZXR1cm4ge1xuICAgIHRpdGxlOiBbXCJVbmtub3duXCJdLFxuICAgIGJvZHk6IFwiXCIsXG4gICAgZGlzcGxheUVycm9yOiBlcnJvci5zcGxpdChcIlxcblwiKVswXSxcbiAgICBzdGF0ZTogXCJmYWlsZWRcIixcbiAgICBob29rczogW10sXG4gICAgYXR0ZW1wdHM6IFtcbiAgICAgIGdldFRlc3RBdHRlbXB0KHtcbiAgICAgICAgc3RhdGU6IFwiZmFpbGVkXCIsXG4gICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICBlcnJvcjoge1xuICAgICAgICAgIG5hbWU6IFwiRXJyb3JcIixcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvci5zcGxpdChcIlxcblwiKVswXSxcbiAgICAgICAgICBzdGFjazogZXJyb3IsXG4gICAgICAgIH0sXG4gICAgICAgIHNjcmVlbnNob3RzOiBbXSxcbiAgICAgICAgc3RhcnRlZEF0OiBzdGF0cy5zdGFydGVkQXQsXG4gICAgICAgIHZpZGVvVGltZXN0YW1wOiAwLFxuICAgICAgfSksXG4gICAgXSxcbiAgICBjbGllbnRJZDogXCJyMFwiLFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgZ2V0SW5zdGFuY2VUZXN0c1BheWxvYWQgPSAoXG4gIHJ1blJlc3VsdDogQ3lwcmVzc0NvbW1hbmRMaW5lLlJ1blJlc3VsdCxcbiAgY29uZmlnOiBDeXByZXNzLlJlc29sdmVkQ29uZmlnT3B0aW9uc1xuKTogU2V0SW5zdGFuY2VUZXN0c1BheWxvYWQgPT4ge1xuICBjb25zdCBhbHRUZXN0cyA9IFtdO1xuICBpZiAocnVuUmVzdWx0LmVycm9yICYmICFydW5SZXN1bHQudGVzdHM/Lmxlbmd0aCkge1xuICAgIGFsdFRlc3RzLnB1c2goZ2V0RmFrZVRlc3RGcm9tRXhjZXB0aW9uKHJ1blJlc3VsdC5lcnJvciwgcnVuUmVzdWx0LnN0YXRzKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb25maWcsXG4gICAgdGVzdHM6XG4gICAgICBydW5SZXN1bHQudGVzdHM/Lm1hcCgodGVzdCwgaSkgPT4gKHtcbiAgICAgICAgdGl0bGU6IHRlc3QudGl0bGUsXG4gICAgICAgIGNvbmZpZzogbnVsbCxcbiAgICAgICAgYm9keTogdGVzdC5ib2R5LFxuICAgICAgICBjbGllbnRJZDogYHIke2l9YCxcbiAgICAgICAgaG9va0lkczogW10sXG4gICAgICB9KSkgPz8gYWx0VGVzdHMsXG4gICAgaG9va3M6IHJ1blJlc3VsdC5ob29rcyxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBzdW1tYXJpemVUZXN0UmVzdWx0cyA9IChcbiAgaW5wdXQ6IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0W10sXG4gIGNvbmZpZzogTWVyZ2VkQ29uZmlnXG4pOiBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdCA9PiB7XG4gIGlmICghaW5wdXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGdldEVtcHR5Q3lwcmVzc1Jlc3VsdHMoY29uZmlnKTtcbiAgfVxuXG4gIGNvbnN0IG92ZXJhbGwgPSBpbnB1dC5yZWR1Y2UoXG4gICAgKFxuICAgICAgYWNjLFxuICAgICAge1xuICAgICAgICB0b3RhbER1cmF0aW9uLFxuICAgICAgICB0b3RhbEZhaWxlZCxcbiAgICAgICAgdG90YWxQYXNzZWQsXG4gICAgICAgIHRvdGFsUGVuZGluZyxcbiAgICAgICAgdG90YWxTa2lwcGVkLFxuICAgICAgICB0b3RhbFRlc3RzLFxuICAgICAgICB0b3RhbFN1aXRlcyxcbiAgICAgIH1cbiAgICApID0+ICh7XG4gICAgICB0b3RhbER1cmF0aW9uOiBhY2MudG90YWxEdXJhdGlvbiArIHRvdGFsRHVyYXRpb24sXG4gICAgICB0b3RhbFN1aXRlczogYWNjLnRvdGFsU3VpdGVzICsgdG90YWxTdWl0ZXMsXG4gICAgICB0b3RhbFBlbmRpbmc6IGFjYy50b3RhbFBlbmRpbmcgKyB0b3RhbFBlbmRpbmcsXG4gICAgICB0b3RhbEZhaWxlZDogYWNjLnRvdGFsRmFpbGVkICsgdG90YWxGYWlsZWQsXG4gICAgICB0b3RhbFNraXBwZWQ6IGFjYy50b3RhbFNraXBwZWQgKyB0b3RhbFNraXBwZWQsXG4gICAgICB0b3RhbFBhc3NlZDogYWNjLnRvdGFsUGFzc2VkICsgdG90YWxQYXNzZWQsXG4gICAgICB0b3RhbFRlc3RzOiBhY2MudG90YWxUZXN0cyArIHRvdGFsVGVzdHMsXG4gICAgfSksXG4gICAgZW1wdHlTdGF0c1xuICApO1xuICBjb25zdCBmaXJzdFJlc3VsdCA9IGlucHV0WzBdO1xuICBjb25zdCBzdGFydEl0ZW1zID0gaW5wdXQubWFwKChpKSA9PiBpLnN0YXJ0ZWRUZXN0c0F0KS5zb3J0KCk7XG4gIGNvbnN0IGVuZEl0ZW1zID0gaW5wdXQubWFwKChpKSA9PiBpLmVuZGVkVGVzdHNBdCkuc29ydCgpO1xuICBjb25zdCBydW5zID0gaW5wdXQubWFwKChpKSA9PiBpLnJ1bnMpLmZsYXQoKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5vdmVyYWxsLFxuICAgIHJ1bnMsXG4gICAgc3RhcnRlZFRlc3RzQXQ6IF8uZmlyc3Qoc3RhcnRJdGVtcykgYXMgc3RyaW5nLFxuICAgIGVuZGVkVGVzdHNBdDogXy5sYXN0KGVuZEl0ZW1zKSBhcyBzdHJpbmcsXG4gICAgLi4uXy5waWNrKFxuICAgICAgZmlyc3RSZXN1bHQsXG4gICAgICBcImJyb3dzZXJOYW1lXCIsXG4gICAgICBcImJyb3dzZXJWZXJzaW9uXCIsXG4gICAgICBcImJyb3dzZXJQYXRoXCIsXG4gICAgICBcIm9zTmFtZVwiLFxuICAgICAgXCJvc1ZlcnNpb25cIixcbiAgICAgIFwiY3lwcmVzc1ZlcnNpb25cIixcbiAgICAgIFwiY29uZmlnXCJcbiAgICApLFxuICAgIHN0YXR1czogXCJmaW5pc2hlZFwiLFxuICB9O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVtcHR5Q3lwcmVzc1Jlc3VsdHMoXG4gIGNvbmZpZzogTWVyZ2VkQ29uZmlnXG4pOiBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdCB7XG4gIHJldHVybiB7XG4gICAgLi4uZW1wdHlTdGF0cyxcbiAgICBzdGF0dXM6IFwiZmluaXNoZWRcIixcbiAgICBzdGFydGVkVGVzdHNBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIGVuZGVkVGVzdHNBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHJ1bnM6IFtdLFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25maWcsXG4gIH07XG59XG5jb25zdCBlbXB0eVN0YXRzID0ge1xuICB0b3RhbER1cmF0aW9uOiAwLFxuICB0b3RhbFN1aXRlczogMCxcbiAgdG90YWxQZW5kaW5nOiAwLFxuICB0b3RhbEZhaWxlZDogMCxcbiAgdG90YWxTa2lwcGVkOiAwLFxuICB0b3RhbFBhc3NlZDogMCxcbiAgdG90YWxUZXN0czogMCxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGYWlsZWREdW1teVJlc3VsdCh7XG4gIHNwZWNzLFxuICBlcnJvcixcbiAgY29uZmlnLFxufToge1xuICBzcGVjczogc3RyaW5nW107XG4gIGVycm9yOiBzdHJpbmc7XG4gIGNvbmZpZzogYW55OyAvLyBUT0RPIHRpZ2h0ZW4gdGhpcyB1cFxufSk6IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0IHtcbiAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gIGNvbnN0IGVuZCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgcmV0dXJuIHtcbiAgICBjb25maWcsXG4gICAgc3RhdHVzOiBcImZpbmlzaGVkXCIsXG4gICAgc3RhcnRlZFRlc3RzQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBlbmRlZFRlc3RzQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB0b3RhbER1cmF0aW9uOiAwLFxuICAgIHRvdGFsU3VpdGVzOiAxLFxuICAgIHRvdGFsRmFpbGVkOiAxLFxuICAgIHRvdGFsUGFzc2VkOiAwLFxuICAgIHRvdGFsUGVuZGluZzogMCxcbiAgICB0b3RhbFNraXBwZWQ6IDAsXG4gICAgdG90YWxUZXN0czogMSxcbiAgICBicm93c2VyTmFtZTogXCJ1bmtub3duXCIsXG4gICAgYnJvd3NlclZlcnNpb246IFwidW5rbm93blwiLFxuICAgIGJyb3dzZXJQYXRoOiBcInVua25vd25cIixcbiAgICBvc05hbWU6IFwidW5rbm93blwiLFxuICAgIG9zVmVyc2lvbjogXCJ1bmtub3duXCIsXG4gICAgY3lwcmVzc1ZlcnNpb246IFwidW5rbm93blwiLFxuICAgIHJ1bnM6IHNwZWNzLm1hcCgocykgPT4gKHtcbiAgICAgIHN0YXRzOiB7XG4gICAgICAgIHN1aXRlczogMSxcbiAgICAgICAgdGVzdHM6IDEsXG4gICAgICAgIHBhc3NlczogMCxcbiAgICAgICAgcGVuZGluZzogMCxcbiAgICAgICAgc2tpcHBlZDogMCxcbiAgICAgICAgZmFpbHVyZXM6IDEsXG4gICAgICAgIHN0YXJ0ZWRBdDogc3RhcnQsXG4gICAgICAgIGVuZGVkQXQ6IGVuZCxcbiAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICB9LFxuICAgICAgcmVwb3J0ZXI6IFwic3BlY1wiLFxuICAgICAgcmVwb3J0ZXJTdGF0czoge30sXG4gICAgICBob29rczogW10sXG4gICAgICBlcnJvcixcbiAgICAgIHZpZGVvOiBudWxsLFxuICAgICAgc3BlYzoge1xuICAgICAgICBuYW1lOiBzLFxuICAgICAgICByZWxhdGl2ZTogXCJcIixcbiAgICAgICAgYWJzb2x1dGU6IFwiXCIsXG4gICAgICAgIHJlbGF0aXZlVG9Db21tb25Sb290OiBcIlwiLFxuICAgICAgfSxcbiAgICAgIHRlc3RzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0aXRsZTogW1wiVW5rbm93blwiXSxcbiAgICAgICAgICBzdGF0ZTogXCJmYWlsZWRcIixcbiAgICAgICAgICBib2R5OiBcIi8vIFRoaXMgdGVzdCBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBkdWUgdG8gZXhlY3V0aW9uIGZhaWx1cmVcIixcbiAgICAgICAgICBkaXNwbGF5RXJyb3I6IGVycm9yLFxuICAgICAgICAgIGF0dGVtcHRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN0YXRlOiBcImZhaWxlZFwiLFxuICAgICAgICAgICAgICBzdGFydGVkQXQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgICAgdmlkZW9UaW1lc3RhbXA6IDAsXG4gICAgICAgICAgICAgIHNjcmVlbnNob3RzOiBbXSxcbiAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkNsb3VkRXhlY3V0aW9uRXJyb3JcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvcixcbiAgICAgICAgICAgICAgICBzdGFjazogXCJcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBzaG91bGRVcGxvYWRWaWRlbzogZmFsc2UsXG4gICAgICBza2lwcGVkU3BlYzogZmFsc2UsXG4gICAgfSkpLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUmF3UmVzdWx0KFxuICByYXdSZXN1bHQ6IEN5cHJlc3NSZXN1bHQsXG4gIHNwZWNzOiBzdHJpbmdbXSxcbiAgY29uZmlnOiBNZXJnZWRDb25maWdcbik6IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0IHtcbiAgaWYgKCFpc1N1Y2Nlc3NSZXN1bHQocmF3UmVzdWx0KSkge1xuICAgIHJldHVybiBnZXRGYWlsZWREdW1teVJlc3VsdCh7XG4gICAgICBzcGVjcyxcbiAgICAgIGVycm9yOiByYXdSZXN1bHQubWVzc2FnZSxcbiAgICAgIGNvbmZpZyxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmF3UmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3VtbWFyeUZvclNwZWMoXG4gIHNwZWM6IHN0cmluZyxcbiAgcnVuUmVzdWx0OiBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdFxuKSB7XG4gIGNvbnN0IHJ1biA9IHJ1blJlc3VsdC5ydW5zLmZpbmQoKHIpID0+IHIuc3BlYy5yZWxhdGl2ZSA9PT0gc3BlYyk7XG4gIGlmICghcnVuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHN0YXRzID0gZ2V0U3RhdHMocnVuLnN0YXRzKTtcbiAgLy8gYWRqdXN0IHRoZSByZXN1bHQgZm9yIHNpbmdlIHNwZWNcbiAgcmV0dXJuIHtcbiAgICAuLi5ydW5SZXN1bHQsXG4gICAgcnVuczogW3J1bl0sXG4gICAgdG90YWxTdWl0ZXM6IDEsXG4gICAgdG90YWxEdXJhdGlvbjogc3RhdHMud2FsbENsb2NrRHVyYXRpb24sXG4gICAgdG90YWxUZXN0czogc3RhdHMudGVzdHMsXG4gICAgdG90YWxGYWlsZWQ6IHN0YXRzLmZhaWx1cmVzLFxuICAgIHRvdGFsUGFzc2VkOiBzdGF0cy5wYXNzZXMsXG4gICAgdG90YWxQZW5kaW5nOiBzdGF0cy5wZW5kaW5nLFxuICAgIHRvdGFsU2tpcHBlZDogc3RhdHMuc2tpcHBlZCxcbiAgICBzdGFydGVkVGVzdHNBdDogc3RhdHMud2FsbENsb2NrU3RhcnRlZEF0LFxuICAgIGVuZGVkVGVzdHNBdDogc3RhdHMud2FsbENsb2NrRW5kZWRBdCxcbiAgfTtcbn1cbiIsICJpbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgcHJldHR5TVMgZnJvbSBcInByZXR0eS1tc1wiO1xuaW1wb3J0IHsgdGFibGUgfSBmcm9tIFwidGFibGVcIjtcbmltcG9ydCB7IGN5YW4sIGdyYXksIGdyZWVuLCByZWQsIHdoaXRlIH0gZnJvbSBcIi4uL2xvZ1wiO1xuXG5jb25zdCBmYWlsdXJlSWNvbiA9IHJlZChcIlx1MjcxNlwiKTtcbmNvbnN0IHN1Y2Nlc3NJY29uID0gZ3JlZW4oXCJcdTI3MTRcIik7XG5cbmV4cG9ydCBjb25zdCBzdW1tYXJ5VGFibGUgPSAocjogQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHQpID0+IHtcbiAgY29uc3Qgb3ZlcmFsbFNwZWNDb3VudCA9IHIucnVucy5sZW5ndGg7XG4gIGNvbnN0IGZhaWxlZFNwZWNzQ291bnQgPSBfLnN1bShcbiAgICByLnJ1bnMuZmlsdGVyKCh2KSA9PiB2LnN0YXRzLmZhaWx1cmVzICsgdi5zdGF0cy5za2lwcGVkID4gMCkubWFwKCgpID0+IDEpXG4gICk7XG4gIGNvbnN0IGhhc0ZhaWxlZCA9IGZhaWxlZFNwZWNzQ291bnQgPiAwO1xuXG4gIGNvbnN0IHZlcmRpY3QgPSBoYXNGYWlsZWRcbiAgICA/IHJlZChgJHtmYWlsZWRTcGVjc0NvdW50fSBvZiAke292ZXJhbGxTcGVjQ291bnR9IGZhaWxlZGApXG4gICAgOiBvdmVyYWxsU3BlY0NvdW50ID4gMFxuICAgID8gXCJBbGwgc3BlY3MgcGFzc2VkIVwiXG4gICAgOiBcIk5vIHNwZWNzIGV4ZWN1dGVkXCI7XG5cbiAgY29uc3QgZGF0YSA9IHIucnVucy5tYXAoKHIpID0+IFtcbiAgICByLnN0YXRzLmZhaWx1cmVzICsgci5zdGF0cy5za2lwcGVkID4gMCA/IGZhaWx1cmVJY29uIDogc3VjY2Vzc0ljb24sXG4gICAgci5zcGVjLnJlbGF0aXZlVG9Db21tb25Sb290LFxuICAgIGdyYXkocHJldHR5TVMoci5zdGF0cy5kdXJhdGlvbikpLFxuICAgIHdoaXRlKHIuc3RhdHMudGVzdHMgPz8gMCksXG4gICAgci5zdGF0cy5wYXNzZXMgPyBncmVlbihyLnN0YXRzLnBhc3NlcykgOiBncmF5KFwiLVwiKSxcbiAgICByLnN0YXRzLmZhaWx1cmVzID8gcmVkKHIuc3RhdHMuZmFpbHVyZXMpIDogZ3JheShcIi1cIiksXG4gICAgci5zdGF0cy5wZW5kaW5nID8gY3lhbihyLnN0YXRzLnBlbmRpbmcpIDogZ3JheShcIi1cIiksXG4gICAgci5zdGF0cy5za2lwcGVkID8gcmVkKHIuc3RhdHMuc2tpcHBlZCkgOiBncmF5KFwiLVwiKSxcbiAgXSk7XG5cbiAgcmV0dXJuIHRhYmxlKFxuICAgIFtcbiAgICAgIFtcbiAgICAgICAgXCJcIiwgLy8gbWFya2VyXG4gICAgICAgIGdyYXkoXCJTcGVjXCIpLFxuICAgICAgICBcIlwiLFxuICAgICAgICBncmF5KFwiVGVzdHNcIiksXG4gICAgICAgIGdyYXkoXCJQYXNzaW5nXCIpLFxuICAgICAgICBncmF5KFwiRmFpbGluZ1wiKSxcbiAgICAgICAgZ3JheShcIlBlbmRpbmdcIiksXG4gICAgICAgIGdyYXkoXCJTa2lwcGVkXCIpLFxuICAgICAgXSxcbiAgICAgIC4uLmRhdGEsXG4gICAgICBbXG4gICAgICAgIGhhc0ZhaWxlZCA/IGZhaWx1cmVJY29uIDogc3VjY2Vzc0ljb24sIC8vIG1hcmtlclxuICAgICAgICB2ZXJkaWN0LFxuICAgICAgICBncmF5KHByZXR0eU1TKHIudG90YWxEdXJhdGlvbiA/PyAwKSksXG4gICAgICAgIG92ZXJhbGxTcGVjQ291bnQgPiAwID8gd2hpdGUoci50b3RhbFRlc3RzID8/IDApIDogZ3JheShcIi1cIiksXG4gICAgICAgIHIudG90YWxQYXNzZWQgPyBncmVlbihyLnRvdGFsUGFzc2VkKSA6IGdyYXkoXCItXCIpLFxuICAgICAgICByLnRvdGFsRmFpbGVkID8gcmVkKHIudG90YWxGYWlsZWQpIDogZ3JheShcIi1cIiksXG4gICAgICAgIHIudG90YWxQZW5kaW5nID8gY3lhbihyLnRvdGFsUGVuZGluZykgOiBncmF5KFwiLVwiKSxcbiAgICAgICAgci50b3RhbFNraXBwZWQgPyByZWQoci50b3RhbFNraXBwZWQpIDogZ3JheShcIi1cIiksXG4gICAgICBdLFxuICAgIF0sXG4gICAge1xuICAgICAgYm9yZGVyLFxuICAgICAgY29sdW1uRGVmYXVsdDoge1xuICAgICAgICB3aWR0aDogOCxcbiAgICAgIH0sXG4gICAgICBjb2x1bW5zOiBbXG4gICAgICAgIHsgYWxpZ25tZW50OiBcImxlZnRcIiwgd2lkdGg6IDIgfSxcbiAgICAgICAgeyBhbGlnbm1lbnQ6IFwibGVmdFwiLCB3aWR0aDogMzAgfSxcbiAgICAgICAgeyBhbGlnbm1lbnQ6IFwicmlnaHRcIiB9LFxuICAgICAgICB7IGFsaWdubWVudDogXCJyaWdodFwiIH0sXG4gICAgICAgIHsgYWxpZ25tZW50OiBcInJpZ2h0XCIgfSxcbiAgICAgICAgeyBhbGlnbm1lbnQ6IFwicmlnaHRcIiB9LFxuICAgICAgICB7IGFsaWdubWVudDogXCJyaWdodFwiIH0sXG4gICAgICAgIHsgYWxpZ25tZW50OiBcInJpZ2h0XCIgfSxcbiAgICAgIF0sXG4gICAgICAvLyBzaW5nbGVMaW5lOiB0cnVlLFxuICAgICAgZHJhd0hvcml6b250YWxMaW5lOiAobGluZUluZGV4LCByb3dDb3VudCkgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGxpbmVJbmRleCA9PT0gMSB8fFxuICAgICAgICAgIGxpbmVJbmRleCA9PT0gMCB8fFxuICAgICAgICAgIGxpbmVJbmRleCA9PT0gcm93Q291bnQgLSAxIHx8XG4gICAgICAgICAgbGluZUluZGV4ID09PSByb3dDb3VudFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIGRyYXdWZXJ0aWNhbExpbmU6IChsaW5lSW5kZXgsIHJvd0NvdW50KSA9PiB7XG4gICAgICAgIHJldHVybiBsaW5lSW5kZXggPT09IDAgfHwgcm93Q291bnQgPT09IGxpbmVJbmRleDtcbiAgICAgIH0sXG4gICAgfVxuICApO1xufTtcblxuY29uc3QgYm9yZGVyID0gXy5tYXBWYWx1ZXMoXG4gIHtcbiAgICB0b3BCb2R5OiBgXHUyNTAwYCxcbiAgICB0b3BKb2luOiBgXHUyNTJDYCxcbiAgICB0b3BMZWZ0OiBgICBcdTI1MENgLFxuICAgIHRvcFJpZ2h0OiBgXHUyNTEwYCxcblxuICAgIGJvdHRvbUJvZHk6IGBcdTI1MDBgLFxuICAgIGJvdHRvbUpvaW46IGBcdTI1MzRgLFxuICAgIGJvdHRvbUxlZnQ6IGAgIFx1MjUxNGAsXG4gICAgYm90dG9tUmlnaHQ6IGBcdTI1MThgLFxuXG4gICAgYm9keUxlZnQ6IGAgIFx1MjUwMmAsXG4gICAgYm9keVJpZ2h0OiBgXHUyNTAyYCxcbiAgICBib2R5Sm9pbjogYFx1MjUwMmAsXG5cbiAgICBqb2luQm9keTogYFx1MjUwMGAsXG4gICAgam9pbkxlZnQ6IGAgIFx1MjUxQ2AsXG4gICAgam9pblJpZ2h0OiBgXHUyNTI0YCxcbiAgICBqb2luSm9pbjogYFx1MjUzQ2AsXG4gIH0sXG4gICh2KSA9PiBncmF5KHYpXG4pO1xuIiwgImltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7XG4gIHJlcG9ydEluc3RhbmNlUmVzdWx0c01lcmdlZCxcbiAgc2V0SW5zdGFuY2VUZXN0cyxcbiAgU2V0SW5zdGFuY2VUZXN0c1BheWxvYWQsXG4gIHVwZGF0ZUluc3RhbmNlUmVzdWx0cyxcbiAgVXBkYXRlSW5zdGFuY2VSZXN1bHRzUGF5bG9hZCxcbn0gZnJvbSBcIi4uL2FwaVwiO1xuaW1wb3J0IHsgdXBsb2FkQXJ0aWZhY3RzLCB1cGxvYWRTdGRvdXRTYWZlIH0gZnJvbSBcIi4uL2FydGlmYWN0c1wiO1xuaW1wb3J0IHsgZ2V0SW5pdGlhbE91dHB1dCB9IGZyb20gXCIuLi9jYXB0dXJlXCI7XG5pbXBvcnQgeyBpc0N1cnJlbnRzIH0gZnJvbSBcIi4uL2VudlwiO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IHNldENhbmNlbGxhdGlvblJlYXNvbiB9IGZyb20gXCIuLi9zdGF0ZVwiO1xuaW1wb3J0IHsgZ2V0SW5zdGFuY2VSZXN1bHRQYXlsb2FkLCBnZXRJbnN0YW5jZVRlc3RzUGF5bG9hZCB9IGZyb20gXCIuL3Jlc3VsdHNcIjtcbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpyZXN1bHRzXCIpO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VXBsb2FkUmVzdWx0c1Rhc2soe1xuICBpbnN0YW5jZUlkLFxuICBzcGVjLFxuICBydW5SZXN1bHQsXG4gIG91dHB1dCxcbn06IHtcbiAgaW5zdGFuY2VJZDogc3RyaW5nO1xuICBzcGVjOiBzdHJpbmc7XG4gIHJ1blJlc3VsdDogQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHQ7XG4gIG91dHB1dDogc3RyaW5nO1xufSkge1xuICBjb25zdCBydW4gPSBydW5SZXN1bHQucnVucy5maW5kKChyKSA9PiByLnNwZWMucmVsYXRpdmUgPT09IHNwZWMpO1xuICBpZiAoIXJ1bikge1xuICAgIHdhcm4oJ0Nhbm5vdCBkZXRlcm1pbmUgcnVuIHJlc3VsdCBmb3Igc3BlYyBcIiVzXCInLCBzcGVjKTtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIHByb2Nlc3NDeXByZXNzUmVzdWx0cyhcbiAgICBpbnN0YW5jZUlkLFxuICAgIHtcbiAgICAgIC8vIHJlcGxhY2UgdGhlIHJ1bnMgd2l0aCB0aGUgcnVuIGZvciB0aGUgc3BlY2lmaWVkIHNwZWNcbiAgICAgIC4uLnJ1blJlc3VsdCxcbiAgICAgIHJ1bnM6IFtydW5dLFxuICAgIH0sXG4gICAgb3V0cHV0XG4gICk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzQ3lwcmVzc1Jlc3VsdHMoXG4gIGluc3RhbmNlSWQ6IHN0cmluZyxcbiAgcmVzdWx0czogQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHQsXG4gIHN0ZG91dDogc3RyaW5nXG4pIHtcbiAgY29uc3QgcnVuID0gcmVzdWx0cy5ydW5zWzBdO1xuICBpZiAoIXJ1bikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJ1biBmb3VuZCBpbiBDeXByZXNzIHJlc3VsdHNcIik7XG4gIH1cbiAgY29uc3QgaW5zdGFuY2VSZXN1bHRzID0gZ2V0SW5zdGFuY2VSZXN1bHRQYXlsb2FkKHJ1bik7XG4gIGNvbnN0IGluc3RhbmNlVGVzdHMgPSBnZXRJbnN0YW5jZVRlc3RzUGF5bG9hZChydW4sIHJlc3VsdHMuY29uZmlnKTtcblxuICBjb25zdCB7IHZpZGVvVXBsb2FkVXJsLCBzY3JlZW5zaG90VXBsb2FkVXJscywgY2xvdWQgfSA9IGF3YWl0IHJlcG9ydFJlc3VsdHMoXG4gICAgaW5zdGFuY2VJZCxcbiAgICBpbnN0YW5jZVRlc3RzLFxuICAgIGluc3RhbmNlUmVzdWx0c1xuICApO1xuXG4gIGlmIChjbG91ZD8uc2hvdWxkQ2FuY2VsKSB7XG4gICAgZGVidWcoXCJpbnN0YW5jZSAlcyBzaG91bGQgY2FuY2VsXCIsIGluc3RhbmNlSWQpO1xuICAgIHNldENhbmNlbGxhdGlvblJlYXNvbihjbG91ZC5zaG91bGRDYW5jZWwpO1xuICB9XG4gIGRlYnVnKFwiaW5zdGFuY2UgJXMgYXJ0aWZhY3QgdXBsb2FkIGluc3RydWN0aW9ucyAlb1wiLCBpbnN0YW5jZUlkLCB7XG4gICAgdmlkZW9VcGxvYWRVcmwsXG4gICAgc2NyZWVuc2hvdFVwbG9hZFVybHMsXG4gIH0pO1xuXG4gIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgdXBsb2FkQXJ0aWZhY3RzKHtcbiAgICAgIHZpZGVvVXBsb2FkVXJsLFxuICAgICAgdmlkZW9QYXRoOiBydW4udmlkZW8sXG4gICAgICBzY3JlZW5zaG90VXBsb2FkVXJscyxcbiAgICAgIHNjcmVlbnNob3RzOiBpbnN0YW5jZVJlc3VsdHMuc2NyZWVuc2hvdHMsXG4gICAgfSksXG4gICAgdXBsb2FkU3Rkb3V0U2FmZShpbnN0YW5jZUlkLCBnZXRJbml0aWFsT3V0cHV0KCkgKyBzdGRvdXQpLFxuICBdKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVwb3J0UmVzdWx0cyhcbiAgaW5zdGFuY2VJZDogc3RyaW5nLFxuICBpbnN0YW5jZVRlc3RzOiBTZXRJbnN0YW5jZVRlc3RzUGF5bG9hZCxcbiAgaW5zdGFuY2VSZXN1bHRzOiBVcGRhdGVJbnN0YW5jZVJlc3VsdHNQYXlsb2FkXG4pIHtcbiAgZGVidWcoXCJyZXBvcnRpbmcgaW5zdGFuY2UgJXMgcmVzdWx0cy4uLlwiLCBpbnN0YW5jZUlkKTtcbiAgaWYgKGlzQ3VycmVudHMoKSkge1xuICAgIHJldHVybiByZXBvcnRJbnN0YW5jZVJlc3VsdHNNZXJnZWQoaW5zdGFuY2VJZCwge1xuICAgICAgdGVzdHM6IGluc3RhbmNlVGVzdHMsXG4gICAgICByZXN1bHRzOiBpbnN0YW5jZVJlc3VsdHMsXG4gICAgfSk7XG4gIH1cblxuICAvLyBydW4gb25lIGFmdGVyIGFub3RoZXJcbiAgYXdhaXQgc2V0SW5zdGFuY2VUZXN0cyhpbnN0YW5jZUlkLCBpbnN0YW5jZVRlc3RzKTtcbiAgcmV0dXJuIHVwZGF0ZUluc3RhbmNlUmVzdWx0cyhpbnN0YW5jZUlkLCBpbnN0YW5jZVJlc3VsdHMpO1xufVxuIiwgImltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7IFNjcmVlbnNob3RBcnRpZmFjdCwgU2NyZWVuc2hvdFVwbG9hZEluc3RydWN0aW9uIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgeyB1cGRhdGVJbnN0YW5jZVN0ZG91dCB9IGZyb20gXCIuL2FwaVwiO1xuaW1wb3J0IHsgc2FmZSB9IGZyb20gXCIuL2xhbmdcIjtcbmltcG9ydCB7IHdhcm4gfSBmcm9tIFwiLi9sb2dcIjtcbmltcG9ydCB7IHVwbG9hZEltYWdlLCB1cGxvYWRWaWRlbyB9IGZyb20gXCIuL3VwbG9hZFwiO1xuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOmFydGlmYWN0c1wiKTtcbmludGVyZmFjZSBVcGxvYWRBcnRpZmFjdHMge1xuICB2aWRlb1BhdGg6IHN0cmluZyB8IG51bGw7XG4gIHZpZGVvVXBsb2FkVXJsPzogc3RyaW5nIHwgbnVsbDtcbiAgc2NyZWVuc2hvdHM6IFNjcmVlbnNob3RBcnRpZmFjdFtdO1xuICBzY3JlZW5zaG90VXBsb2FkVXJsczogU2NyZWVuc2hvdFVwbG9hZEluc3RydWN0aW9uW107XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBsb2FkQXJ0aWZhY3RzKHtcbiAgdmlkZW9QYXRoLFxuICB2aWRlb1VwbG9hZFVybCxcbiAgc2NyZWVuc2hvdHMsXG4gIHNjcmVlbnNob3RVcGxvYWRVcmxzLFxufTogVXBsb2FkQXJ0aWZhY3RzKSB7XG4gIC8vIHRpdGxlKFwiYmx1ZVwiLCBcIlVwbG9hZGluZyAgUmVzdWx0c1wiKTtcblxuICBkZWJ1ZyhcInVwbG9hZGluZyBhcnRpZmFjdHM6ICVvXCIsIHtcbiAgICB2aWRlb1BhdGgsXG4gICAgdmlkZW9VcGxvYWRVcmwsXG4gICAgc2NyZWVuc2hvdHMsXG4gICAgc2NyZWVuc2hvdFVwbG9hZFVybHMsXG4gIH0pO1xuXG4gIGNvbnN0IHRvdGFsVXBsb2FkcyA9ICh2aWRlb1BhdGggPyAxIDogMCkgKyBzY3JlZW5zaG90cy5sZW5ndGg7XG4gIGlmICh0b3RhbFVwbG9hZHMgPT09IDApIHtcbiAgICAvLyBpbmZvKFwiTm90aGluZyB0byB1cGxvYWRcIik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gdXBsb2FkIHZpZGVvXG4gIGlmICh2aWRlb1VwbG9hZFVybCAmJiB2aWRlb1BhdGgpIHtcbiAgICBhd2FpdCBzYWZlKFxuICAgICAgdXBsb2FkVmlkZW8sXG4gICAgICAoZSkgPT4gZGVidWcoXCJmYWlsZWQgdXBsb2FkaW5nIHZpZGVvICVzLiBFcnJvcjogJW9cIiwgdmlkZW9QYXRoLCBlKSxcbiAgICAgICgpID0+IGRlYnVnKFwic3VjY2VzcyB1cGxvYWRpbmdcIiwgdmlkZW9QYXRoKVxuICAgICkodmlkZW9QYXRoLCB2aWRlb1VwbG9hZFVybCk7XG4gIH1cbiAgLy8gdXBsb2FkIHNjcmVlbnNob3RzXG4gIGlmIChzY3JlZW5zaG90VXBsb2FkVXJscyAmJiBzY3JlZW5zaG90VXBsb2FkVXJscy5sZW5ndGgpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHNjcmVlbnNob3RzLm1hcCgoc2NyZWVuc2hvdCkgPT4ge1xuICAgICAgICBjb25zdCB1cmwgPSBzY3JlZW5zaG90VXBsb2FkVXJscy5maW5kKFxuICAgICAgICAgICh1cmxzKSA9PiB1cmxzLnNjcmVlbnNob3RJZCA9PT0gc2NyZWVuc2hvdC5zY3JlZW5zaG90SWRcbiAgICAgICAgKT8udXBsb2FkVXJsO1xuICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgIGRlYnVnKFxuICAgICAgICAgICAgXCJObyB1cGxvYWQgdXJsIGZvciBzY3JlZW5zaG90ICVvLCBzY3JlZW5zaG90VXBsb2FkVXJsczogJW9cIixcbiAgICAgICAgICAgIHNjcmVlbnNob3QsXG4gICAgICAgICAgICBzY3JlZW5zaG90VXBsb2FkVXJsc1xuICAgICAgICAgICk7XG4gICAgICAgICAgd2FybihcIkNhbm5vdCBmaW5kIHVwbG9hZCB1cmwgZm9yIHNjcmVlbnNob3Q6ICVzXCIsIHNjcmVlbnNob3QucGF0aCk7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzYWZlKFxuICAgICAgICAgIHVwbG9hZEltYWdlLFxuICAgICAgICAgIChlKSA9PlxuICAgICAgICAgICAgZGVidWcoXG4gICAgICAgICAgICAgIFwiZmFpbGVkIHVwbG9hZGluZyBzY3JlZW5zaG90ICVzLiBFcnJvcjogJW9cIixcbiAgICAgICAgICAgICAgc2NyZWVuc2hvdC5wYXRoLFxuICAgICAgICAgICAgICBlXG4gICAgICAgICAgICApLFxuICAgICAgICAgICgpID0+IGRlYnVnKFwic3VjY2VzcyB1cGxvYWRpbmdcIiwgc2NyZWVuc2hvdC5wYXRoKVxuICAgICAgICApKHNjcmVlbnNob3QucGF0aCwgdXJsKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdXBsb2FkU3Rkb3V0U2FmZSA9IHNhZmUoXG4gIHVwZGF0ZUluc3RhbmNlU3Rkb3V0LFxuICAoKSA9PiB7fSxcbiAgKCkgPT4ge31cbik7XG4iLCAiaW1wb3J0IGJsdWViaXJkIGZyb20gXCJibHVlYmlyZFwiO1xuXG5ibHVlYmlyZC5Qcm9taXNlLmNvbmZpZyh7XG4gIGNhbmNlbGxhdGlvbjogdHJ1ZSxcbn0pO1xuZXhwb3J0IGNvbnN0IEJQcm9taXNlID0gYmx1ZWJpcmQuUHJvbWlzZTtcblxuZXhwb3J0IGNvbnN0IHNhZmUgPVxuICA8VCBleHRlbmRzIGFueVtdLCBSIGV4dGVuZHMgYW55PihcbiAgICBmbjogKC4uLmFyZ3M6IFQpID0+IFByb21pc2U8Uj4sXG4gICAgaWZGYWxlZDogKGU6IHVua25vd24pID0+IGFueSxcbiAgICBpZlN1Y2NlZWQ6ICgpID0+IGFueVxuICApID0+XG4gIGFzeW5jICguLi5hcmdzOiBUKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHIgPSBhd2FpdCBmbiguLi5hcmdzKTtcbiAgICAgIGlmU3VjY2VlZCgpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWZGYWxlZChlKTtcbiAgICB9XG4gIH07XG4iLCAiaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IGZzIGZyb20gXCJmc1wiO1xuaW1wb3J0IHsgbWFrZVJlcXVlc3QgfSBmcm9tIFwiLi9odHRwQ2xpZW50XCI7XG5jb25zdCByZWFkRmlsZSA9IGZzLnByb21pc2VzLnJlYWRGaWxlO1xuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOnVwbG9hZFwiKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVwbG9hZFZpZGVvKGZpbGU6IHN0cmluZywgdXJsOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHVwbG9hZEZpbGUoZmlsZSwgdXJsLCBcInZpZGVvL21wNFwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwbG9hZEltYWdlKGZpbGU6IHN0cmluZywgdXJsOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHVwbG9hZEZpbGUoZmlsZSwgdXJsLCBcImltYWdlL3BuZ1wiKTtcbn1cblxudHlwZSBVcGxvYWRUeXBlcyA9IFwidmlkZW8vbXA0XCIgfCBcImltYWdlL3BuZ1wiIHwgXCJwbGFpbi90ZXh0XCI7XG5hc3luYyBmdW5jdGlvbiB1cGxvYWRGaWxlKGZpbGU6IHN0cmluZywgdXJsOiBzdHJpbmcsIHR5cGU6IFVwbG9hZFR5cGVzKSB7XG4gIGRlYnVnKCd1cGxvYWRpbmcgZmlsZSBcIiVzXCIgdG8gXCIlc1wiJywgZmlsZSwgdXJsKTtcbiAgY29uc3QgZiA9IGF3YWl0IHJlYWRGaWxlKGZpbGUpO1xuICBhd2FpdCBtYWtlUmVxdWVzdCh7XG4gICAgdXJsLFxuICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICBkYXRhOiBmLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IHR5cGUsXG4gICAgfSxcbiAgfSk7XG59XG4iLCAiaW1wb3J0IHsgZ2V0QVBJQmFzZVVybCB9IGZyb20gXCIuL2h0dHBDbGllbnQvY29uZmlnXCI7XG5cbmV4cG9ydCBjb25zdCBpc0N1cnJlbnRzID0gKCkgPT5cbiAgISFwcm9jZXNzLmVudi5DVVJSRU5UU19FTkZPUkNFX0lTX0NVUlJFTlRTIHx8XG4gIGdldEFQSUJhc2VVcmwoKSA9PT0gXCJodHRwczovL2N5LmN1cnJlbnRzLmRldlwiO1xuIiwgImltcG9ydCB7IEV2ZW50LCBwdWJzdWIgfSBmcm9tIFwiLi9wdWJzdWJcIjtcblxuaW50ZXJmYWNlIEV4ZWN1dGlvblN0YXRlIHtcbiAgY2FuY2VsbGF0aW9uUmVhc29uOiBzdHJpbmcgfCBudWxsO1xufVxuY29uc3Qgc3RhdGU6IEV4ZWN1dGlvblN0YXRlID0ge1xuICBjYW5jZWxsYXRpb25SZWFzb246IG51bGwsXG59O1xuXG5leHBvcnQgY29uc3Qgc2V0Q2FuY2VsbGF0aW9uUmVhc29uID0gKHJlYXNvbjogc3RyaW5nKSA9PiB7XG4gIGlmIChzdGF0ZS5jYW5jZWxsYXRpb25SZWFzb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc3RhdGUuY2FuY2VsbGF0aW9uUmVhc29uID0gcmVhc29uO1xuICBwdWJzdWIuZW1pdChFdmVudC5SVU5fQ0FOQ0VMTEVELCByZWFzb24pO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldENhbmNlbGxhdGlvblJlYXNvbiA9ICgpID0+IHN0YXRlLmNhbmNlbGxhdGlvblJlYXNvbjtcbiIsICJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJldmVudHNcIjtcbmV4cG9ydCBlbnVtIEV2ZW50IHtcbiAgUlVOX0NBTkNFTExFRCA9IFwicnVuQ2FuY2VsbGVkXCIsXG59XG5leHBvcnQgY29uc3QgcHVic3ViID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuIiwgImV4cG9ydCAqIGZyb20gXCIuL2NhbmNlbGxhYmxlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zdGF0ZVwiO1xuIiwgImltcG9ydCB7IEJQcm9taXNlIH0gZnJvbSBcIi4uL2xhbmdcIjtcbmltcG9ydCB7IHdhcm4gfSBmcm9tIFwiLi4vbG9nXCI7XG5pbXBvcnQgeyBFdmVudCwgcHVic3ViIH0gZnJvbSBcIi4uL3B1YnN1YlwiO1xuaW1wb3J0IHsgcnVuVGlsbERvbmUgfSBmcm9tIFwiLi9ydW5uZXJcIjtcbmltcG9ydCB7IHN1bW1hcnkgfSBmcm9tIFwiLi9zdGF0ZVwiO1xuXG5sZXQgY2FuY2VsbGFibGU6IHtcbiAgY2FuY2VsOiAoKSA9PiB2b2lkO1xufSB8IG51bGwgPSBudWxsO1xuXG5mdW5jdGlvbiBvblJ1bkNhbmNlbGxlZChyZWFzb246IHN0cmluZykge1xuICB3YXJuKFxuICAgIGBSdW4gY2FuY2VsbGVkOiAlcy4gV2FpdGluZyBmb3IgdXBsb2FkcyB0byBjb21wbGV0ZSBhbmQgc3RvcHBpbmcgZXhlY3V0aW9uLi4uYCxcbiAgICByZWFzb25cbiAgKTtcbiAgY2FuY2VsbGFibGU/LmNhbmNlbCgpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJ1blRpbGxEb25lT3JDYW5jZWxsZWQoXG4gIC4uLmFyZ3M6IFBhcmFtZXRlcnM8dHlwZW9mIHJ1blRpbGxEb25lPlxuKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIF9yZWplY3QpID0+IHtcbiAgICBjYW5jZWxsYWJsZSA9IG5ldyBCUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0LCBvbkNhbmNlbCkgPT4ge1xuICAgICAgaWYgKCFvbkNhbmNlbCkge1xuICAgICAgICBfcmVqZWN0KG5ldyBFcnJvcihcIkJsdWVCaXJkIGlzIG1pc2NvbmZpZ3VyZWQ6IG9uQ2FuY2VsIGlzIHVuZGVmaW5lZFwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9uQ2FuY2VsKCgpID0+IF9yZXNvbHZlKHN1bW1hcnkpKTtcbiAgICAgIHJ1blRpbGxEb25lKC4uLmFyZ3MpLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgX3Jlc29sdmUoc3VtbWFyeSk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgIF9yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcHVic3ViLmFkZExpc3RlbmVyKEV2ZW50LlJVTl9DQU5DRUxMRUQsIG9uUnVuQ2FuY2VsbGVkKTtcbiAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgcHVic3ViLnJlbW92ZUxpc3RlbmVyKEV2ZW50LlJVTl9DQU5DRUxMRUQsIG9uUnVuQ2FuY2VsbGVkKTtcbiAgfSk7XG59XG4iLCAiaW1wb3J0IHtcbiAgU3BlY1dpdGhSZWxhdGl2ZVJvb3QsXG4gIFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycyxcbn0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcbmltcG9ydCB7IGdldENhcHR1cmVkT3V0cHV0LCByZXNldENhcHR1cmUgfSBmcm9tIFwiLi4vY2FwdHVyZVwiO1xuaW1wb3J0IHsgTWVyZ2VkQ29uZmlnIH0gZnJvbSBcIi4uL2NvbmZpZ1wiO1xuXG5pbXBvcnQge1xuICBnZXRTdW1tYXJ5Rm9yU3BlYyxcbiAgZ2V0VXBsb2FkUmVzdWx0c1Rhc2ssXG4gIG5vcm1hbGl6ZVJhd1Jlc3VsdCxcbn0gZnJvbSBcIi4uL3Jlc3VsdHNcIjtcblxuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHtcbiAgY3JlYXRlQmF0Y2hlZEluc3RhbmNlcyxcbiAgY3JlYXRlSW5zdGFuY2UsXG4gIENyZWF0ZUluc3RhbmNlUGF5bG9hZCxcbiAgSW5zdGFuY2VSZXNwb25zZVNwZWNEZXRhaWxzLFxufSBmcm9tIFwiLi4vYXBpXCI7XG5cbmltcG9ydCB7IHJ1blNwZWNGaWxlU2FmZSB9IGZyb20gXCIuLi9jeXByZXNzXCI7XG5pbXBvcnQgeyBpc0N1cnJlbnRzIH0gZnJvbSBcIi4uL2VudlwiO1xuaW1wb3J0IHsgZGl2aWRlciwgZXJyb3IsIGluZm8sIHRpdGxlLCB3YXJuIH0gZnJvbSBcIi4uL2xvZ1wiO1xuaW1wb3J0IHsgc3VtbWFyeSwgdXBsb2FkVGFza3MgfSBmcm9tIFwiLi9zdGF0ZVwiO1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6cnVubmVyXCIpO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcnVuVGlsbERvbmUoXG4gIHtcbiAgICBydW5JZCxcbiAgICBncm91cElkLFxuICAgIG1hY2hpbmVJZCxcbiAgICBwbGF0Zm9ybSxcbiAgICBjb25maWcsXG4gICAgc3BlY3M6IGFsbFNwZWNzLFxuICB9OiBDcmVhdGVJbnN0YW5jZVBheWxvYWQgJiB7XG4gICAgY29uZmlnOiBNZXJnZWRDb25maWc7XG4gICAgc3BlY3M6IFNwZWNXaXRoUmVsYXRpdmVSb290W107XG4gIH0sXG4gIHBhcmFtczogVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzXG4pIHtcbiAgbGV0IGhhc01vcmUgPSB0cnVlO1xuXG4gIHdoaWxlIChoYXNNb3JlKSB7XG4gICAgY29uc3QgbmV3VGFza3MgPSBhd2FpdCBydW5CYXRjaCh7XG4gICAgICBydW5NZXRhOiB7XG4gICAgICAgIHJ1bklkLFxuICAgICAgICBncm91cElkLFxuICAgICAgICBtYWNoaW5lSWQsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgfSxcbiAgICAgIGFsbFNwZWNzLFxuICAgICAgcGFyYW1zLFxuICAgICAgY29uZmlnLFxuICAgIH0pO1xuICAgIGlmICghbmV3VGFza3MubGVuZ3RoKSB7XG4gICAgICBkZWJ1ZyhcIk5vIG1vcmUgdGFza3MgdG8gcnVuLiBVcGxvYWRzIHF1ZXVlOiAlZFwiLCB1cGxvYWRUYXNrcy5sZW5ndGgpO1xuICAgICAgaGFzTW9yZSA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG5ld1Rhc2tzLmZvckVhY2goKHRhc2spID0+IHtcbiAgICAgIGlmICh0YXNrLnN1bW1hcnkuc3BlY1N1bW1hcnkpIHtcbiAgICAgICAgc3VtbWFyeVt0YXNrLnN1bW1hcnkuc3BlY10gPSB0YXNrLnN1bW1hcnkuc3BlY1N1bW1hcnk7XG4gICAgICB9XG4gICAgICB1cGxvYWRUYXNrcy5wdXNoKHRhc2sudXBsb2FkVGFza3MpO1xuICAgIH0pO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJ1bkJhdGNoKHtcbiAgcnVuTWV0YSxcbiAgY29uZmlnLFxuICBwYXJhbXMsXG4gIGFsbFNwZWNzLFxufToge1xuICBydW5NZXRhOiB7XG4gICAgcnVuSWQ6IHN0cmluZztcbiAgICBncm91cElkOiBzdHJpbmc7XG4gICAgbWFjaGluZUlkOiBzdHJpbmc7XG4gICAgcGxhdGZvcm06IENyZWF0ZUluc3RhbmNlUGF5bG9hZFtcInBsYXRmb3JtXCJdO1xuICB9O1xuICBhbGxTcGVjczogU3BlY1dpdGhSZWxhdGl2ZVJvb3RbXTtcbiAgY29uZmlnOiBNZXJnZWRDb25maWc7XG4gIHBhcmFtczogVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzO1xufSkge1xuICBsZXQgYmF0Y2ggPSB7XG4gICAgc3BlY3M6IFtdIGFzIEluc3RhbmNlUmVzcG9uc2VTcGVjRGV0YWlsc1tdLFxuICAgIGNsYWltZWRJbnN0YW5jZXM6IDAsXG4gICAgdG90YWxJbnN0YW5jZXM6IDAsXG4gIH07XG5cbiAgaWYgKGlzQ3VycmVudHMoKSkge1xuICAgIGRlYnVnKFwiR2V0dGluZyBiYXRjaGVkIHRhc2tzOiAlZFwiLCBwYXJhbXMuYmF0Y2hTaXplKTtcbiAgICBiYXRjaCA9IGF3YWl0IGNyZWF0ZUJhdGNoZWRJbnN0YW5jZXMoe1xuICAgICAgLi4ucnVuTWV0YSxcbiAgICAgIGJhdGNoU2l6ZTogcGFyYW1zLmJhdGNoU2l6ZSxcbiAgICB9KTtcbiAgICBkZWJ1ZyhcIkdvdCBiYXRjaGVkIHRhc2tzOiAlb1wiLCBiYXRjaCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVJbnN0YW5jZShydW5NZXRhKTtcblxuICAgIGlmIChyZXNwb25zZS5zcGVjICE9PSBudWxsICYmIHJlc3BvbnNlLmluc3RhbmNlSWQgIT09IG51bGwpIHtcbiAgICAgIGJhdGNoLnNwZWNzLnB1c2goe1xuICAgICAgICBzcGVjOiByZXNwb25zZS5zcGVjLFxuICAgICAgICBpbnN0YW5jZUlkOiByZXNwb25zZS5pbnN0YW5jZUlkLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGJhdGNoLmNsYWltZWRJbnN0YW5jZXMgPSByZXNwb25zZS5jbGFpbWVkSW5zdGFuY2VzO1xuICAgIGJhdGNoLnRvdGFsSW5zdGFuY2VzID0gcmVzcG9uc2UudG90YWxJbnN0YW5jZXM7XG4gIH1cblxuICBpZiAoYmF0Y2guc3BlY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgZGl2aWRlcigpO1xuICBpbmZvKFxuICAgIFwiUnVubmluZzogJXMgKCVkLyVkKVwiLFxuICAgIGJhdGNoLnNwZWNzLm1hcCgocykgPT4gcy5zcGVjKS5qb2luKFwiLCBcIiksXG4gICAgYmF0Y2guY2xhaW1lZEluc3RhbmNlcyxcbiAgICBiYXRjaC50b3RhbEluc3RhbmNlc1xuICApO1xuXG4gIGNvbnN0IHJhd1Jlc3VsdCA9IGF3YWl0IHJ1blNwZWNGaWxlU2FmZShcbiAgICB7XG4gICAgICAvLyB1c2UgYWJzb2x1dGUgcGF0aHMgLSAgdXNlciBjYW4gcnVuIHRoZSBwcm9ncmFtIGZyb20gYSBkaWZmZXJlbnQgZGlyZWN0b3J5LCBlLmcuIG54IG9yIGEgbW9ub3JlcG8gd29ya3NwYWNlXG4gICAgICAvLyBjeXByZXNzIHN0aWxsIHJlcG9ydHMgdGhlIHBhdGggcmVsYXRpdmUgdG8gdGhlIHByb2plY3Qgcm9vdFxuICAgICAgc3BlYzogYmF0Y2guc3BlY3NcbiAgICAgICAgLm1hcCgoYnMpID0+IGdldFNwZWNBYnNvbHV0ZVBhdGgoYWxsU3BlY3MsIGJzLnNwZWMpKVxuICAgICAgICAuam9pbihcIixcIiksXG4gICAgfSxcbiAgICBwYXJhbXNcbiAgKTtcbiAgY29uc3Qgbm9ybWFsaXplZFJlc3VsdCA9IG5vcm1hbGl6ZVJhd1Jlc3VsdChcbiAgICByYXdSZXN1bHQsXG4gICAgYmF0Y2guc3BlY3MubWFwKChzKSA9PiBzLnNwZWMpLFxuICAgIGNvbmZpZ1xuICApO1xuXG4gIHRpdGxlKFwiYmx1ZVwiLCBcIlJlcG9ydGluZyByZXN1bHRzIGFuZCBhcnRpZmFjdHMgaW4gYmFja2dyb3VuZC4uLlwiKTtcblxuICBjb25zdCBvdXRwdXQgPSBnZXRDYXB0dXJlZE91dHB1dCgpO1xuICByZXNldENhcHR1cmUoKTtcblxuICBjb25zdCBiYXRjaFJlc3VsdCA9IGJhdGNoLnNwZWNzLm1hcCgoc3BlYykgPT4ge1xuICAgIGNvbnN0IHNwZWNTdW1tYXJ5ID0gZ2V0U3VtbWFyeUZvclNwZWMoc3BlYy5zcGVjLCBub3JtYWxpemVkUmVzdWx0KTtcbiAgICBpZiAoIXNwZWNTdW1tYXJ5KSB7XG4gICAgICB3YXJuKCdDYW5ub3QgZmluZCBydW4gcmVzdWx0IGZvciBzcGVjIFwiJXNcIicsIHNwZWMuc3BlYyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1bW1hcnk6IHtcbiAgICAgICAgc3BlYzogc3BlYy5zcGVjLFxuICAgICAgICBzcGVjU3VtbWFyeSxcbiAgICAgIH0sXG4gICAgICB1cGxvYWRUYXNrczogZ2V0VXBsb2FkUmVzdWx0c1Rhc2soe1xuICAgICAgICAuLi5zcGVjLFxuICAgICAgICBydW5SZXN1bHQ6IG5vcm1hbGl6ZWRSZXN1bHQsXG4gICAgICAgIG91dHB1dCxcbiAgICAgIH0pLmNhdGNoKGVycm9yKSxcbiAgICB9O1xuICB9KTtcblxuICByZXR1cm4gYmF0Y2hSZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldFNwZWNBYnNvbHV0ZVBhdGgoXG4gIGFsbFNwZWNzOiBTcGVjV2l0aFJlbGF0aXZlUm9vdFtdLFxuICByZWxhdGl2ZTogc3RyaW5nXG4pIHtcbiAgY29uc3QgYWJzb2x1dGVQYXRoID0gYWxsU3BlY3MuZmluZCgoaSkgPT4gaS5yZWxhdGl2ZSA9PT0gcmVsYXRpdmUpPy5hYnNvbHV0ZTtcbiAgaWYgKCFhYnNvbHV0ZVBhdGgpIHtcbiAgICB3YXJuKFxuICAgICAgJ0Nhbm5vdCBmaW5kIGFic29sdXRlIHBhdGggZm9yIHNwZWMuIFNwZWM6IFwiJXNcIiwgY2FuZGlkYXRlczogJW8nLFxuICAgICAgcmVsYXRpdmUsXG4gICAgICBhbGxTcGVjc1xuICAgICk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBhYnNvbHV0ZSBwYXRoIGZvciBzcGVjYCk7XG4gIH1cbiAgcmV0dXJuIGFic29sdXRlUGF0aDtcbn1cbiIsICJpbXBvcnQgeyBTdW1tYXJ5UmVzdWx0IH0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcblxuZXhwb3J0IGNvbnN0IHN1bW1hcnk6IFN1bW1hcnlSZXN1bHQgPSB7fTtcbmV4cG9ydCBjb25zdCB1cGxvYWRUYXNrczogUHJvbWlzZTxhbnk+W10gPSBbXTtcbiIsICJleHBvcnQgKiBmcm9tIFwiLi9nZXRTcGVjRmlsZXNcIjtcbiIsICJpbXBvcnQge1xuICBDdXJyZW50c1J1blBhcmFtZXRlcnMsXG4gIFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycyxcbn0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcbmltcG9ydCB7IE1lcmdlZENvbmZpZyB9IGZyb20gXCIuLi9jb25maWcvY29uZmlnXCI7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSBcIi4uL2xvZ1wiO1xuaW1wb3J0IHsgZmluZFNwZWNzIH0gZnJvbSBcIi4vc3BlY01hdGNoZXJcIjtcblxuZXhwb3J0IGNvbnN0IGdldFNwZWNGaWxlcyA9IGFzeW5jICh7XG4gIGNvbmZpZyxcbiAgcGFyYW1zLFxufToge1xuICBjb25maWc6IE1lcmdlZENvbmZpZztcbiAgcGFyYW1zOiBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnM7XG59KSA9PiB7XG4gIGNvbnN0IHNwZWNQYXR0ZXJuID0gZ2V0U3BlY1BhdHRlcm4oY29uZmlnLnNwZWNQYXR0ZXJuLCBwYXJhbXMuc3BlYyk7XG4gIC8vIGZpbmQgdGhlIHNwZWMgZmlsZXMgYWNjb3JkaW5nIHRvIHRoZSByZXNvbHZlZCBjb25maWd1cmF0aW9uXG4gIGNvbnN0IHNwZWNzID0gYXdhaXQgZmluZFNwZWNzKHtcbiAgICAvLyBodHRwczovL2RvY3MuY3lwcmVzcy5pby9ndWlkZXMvZ3VpZGVzL2NvbW1hbmQtbGluZSNjeXByZXNzLXJ1bi1zcGVjLWx0LXNwZWMtZ3RcbiAgICBwcm9qZWN0Um9vdDogcGFyYW1zLnByb2plY3QgPz8gY29uZmlnLnByb2plY3RSb290LFxuICAgIHRlc3RpbmdUeXBlOiBwYXJhbXMudGVzdGluZ1R5cGUsXG4gICAgc3BlY1BhdHRlcm4sXG4gICAgY29uZmlnU3BlY1BhdHRlcm46IGNvbmZpZy5zcGVjUGF0dGVybixcbiAgICBleGNsdWRlU3BlY1BhdHRlcm46IGNvbmZpZy5leGNsdWRlU3BlY1BhdHRlcm4sXG4gICAgYWRkaXRpb25hbElnbm9yZVBhdHRlcm46IGNvbmZpZy5hZGRpdGlvbmFsSWdub3JlUGF0dGVybixcbiAgfSk7XG4gIGlmIChzcGVjcy5sZW5ndGggPT09IDApIHtcbiAgICB3YXJuKFxuICAgICAgXCJGb3VuZCBubyBzcGVjIGZpbGVzLiBXYXMgbG9va2luZyBmb3Igc3BlYyBmaWxlcyB0aGF0IG1hdGNoIGJvdGggY29uZmlnU3BlY1BhdHRlcm4gYW5kIHNwZWNQYXR0ZXJuIHJlbGF0aXZlIHRvIHByb2plY3RSb290LiBDb25maWd1cmF0aW9uOiAlT1wiLFxuICAgICAge1xuICAgICAgICBwcm9qZWN0Um9vdDogY29uZmlnLnByb2plY3RSb290LFxuICAgICAgICBzcGVjUGF0dGVybixcbiAgICAgICAgY29uZmlnU3BlY1BhdHRlcm46IGNvbmZpZy5zcGVjUGF0dGVybixcbiAgICAgICAgZXhjbHVkZVNwZWNQYXR0ZXJuOiBbXG4gICAgICAgICAgY29uZmlnLmV4Y2x1ZGVTcGVjUGF0dGVybixcbiAgICAgICAgICBjb25maWcuYWRkaXRpb25hbElnbm9yZVBhdHRlcm4sXG4gICAgICAgIF0uZmxhdCgyKSxcbiAgICAgICAgdGVzdGluZ1R5cGU6IHBhcmFtcy50ZXN0aW5nVHlwZSxcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIHJldHVybiB7IHNwZWNzLCBzcGVjUGF0dGVybiB9O1xufTtcblxuZnVuY3Rpb24gZ2V0U3BlY1BhdHRlcm4oXG4gIGNvbmZpZ1BhdHRlcm46IE1lcmdlZENvbmZpZ1tcInNwZWNQYXR0ZXJuXCJdLFxuICBleHBsaWNpdD86IEN1cnJlbnRzUnVuUGFyYW1ldGVyc1tcInNwZWNcIl1cbikge1xuICByZXR1cm4gZXhwbGljaXQgfHwgY29uZmlnUGF0dGVybjtcbn1cbiIsICJpbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiO1xuXG5pbXBvcnQgY29tbW9uUGF0aFByZWZpeCBmcm9tIFwiY29tbW9uLXBhdGgtcHJlZml4XCI7XG5pbXBvcnQgZ2xvYmJ5LCB7IEdsb2JieU9wdGlvbnMgfSBmcm9tIFwiZ2xvYmJ5XCI7XG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgb3MgZnJvbSBcIm9zXCI7XG5pbXBvcnQge1xuICBGaW5kU3BlY3MsXG4gIFNwZWNUeXBlLFxuICBTcGVjV2l0aFJlbGF0aXZlUm9vdCxcbiAgVGVzdGluZ1R5cGUsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuaW1wb3J0IHsgdG9BcnJheSwgdG9Qb3NpeCB9IGZyb20gXCIuLi91dGlsc1wiO1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6c3BlY3NcIik7XG5cbnR5cGUgR2xvYlBhdHRlcm4gPSBzdHJpbmcgfCBzdHJpbmdbXTtcblxuLyoqXG4gKiBSZXBsaWNhdGUgaG93IGN5cHJlc3MgaXMgZGlzY292ZXJpbmcgc3BlYyBmaWxlc1xuICogaHR0cHM6Ly9naXRodWIuY29tL2N5cHJlc3MtaW8vY3lwcmVzcy9ibG9iL2JjOWVkYjQ0NTIzZDYyY2E5MzQ4MjdiOGU4NzBmMzhmODY2MzRjYTQvcGFja2FnZXMvZGF0YS1jb250ZXh0L3NyYy9zb3VyY2VzL1Byb2plY3REYXRhU291cmNlLnRzI0wyNTBcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXByZXNzLWlvL2N5cHJlc3MvYmxvYi9iYzllZGI0NDUyM2Q2MmNhOTM0ODI3YjhlODcwZjM4Zjg2NjM0Y2E0L3BhY2thZ2VzL2RhdGEtY29udGV4dC9zcmMvYWN0aW9ucy9Qcm9qZWN0QWN0aW9ucy50cyNMNDE3XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmaW5kU3BlY3Moe1xuICBwcm9qZWN0Um9vdCxcbiAgdGVzdGluZ1R5cGUsXG4gIHNwZWNQYXR0ZXJuLFxuICBjb25maWdTcGVjUGF0dGVybixcbiAgZXhjbHVkZVNwZWNQYXR0ZXJuLFxuICBhZGRpdGlvbmFsSWdub3JlUGF0dGVybixcbn06IEZpbmRTcGVjczxzdHJpbmdbXSB8IHN0cmluZz4pOiBQcm9taXNlPFNwZWNXaXRoUmVsYXRpdmVSb290W10+IHtcbiAgY29uZmlnU3BlY1BhdHRlcm4gPSB0b0FycmF5KGNvbmZpZ1NwZWNQYXR0ZXJuKTtcbiAgc3BlY1BhdHRlcm4gPSB0b0FycmF5KHNwZWNQYXR0ZXJuKTtcbiAgZXhjbHVkZVNwZWNQYXR0ZXJuID0gdG9BcnJheShleGNsdWRlU3BlY1BhdHRlcm4pIHx8IFtdO1xuXG4gIC8vIGV4Y2x1ZGUgYWxsIHNwZWNzIG1hdGNoaW5nIGUyZSBpZiBpbiBjb21wb25lbnQgdGVzdGluZ1xuICBhZGRpdGlvbmFsSWdub3JlUGF0dGVybiA9IHRvQXJyYXkoYWRkaXRpb25hbElnbm9yZVBhdHRlcm4pIHx8IFtdO1xuXG4gIGRlYnVnKFwiZXhwbG9yaW5nIHNwZWMgZmlsZXMgZm9yIGV4ZWN1dGlvbiAlT1wiLCB7XG4gICAgdGVzdGluZ1R5cGUsXG4gICAgcHJvamVjdFJvb3QsXG4gICAgc3BlY1BhdHRlcm4sXG4gICAgY29uZmlnU3BlY1BhdHRlcm4sXG4gICAgZXhjbHVkZVNwZWNQYXR0ZXJuLFxuICAgIGFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuLFxuICB9KTtcblxuICBpZiAoIXNwZWNQYXR0ZXJuIHx8ICFjb25maWdTcGVjUGF0dGVybikge1xuICAgIHRocm93IEVycm9yKFwiQ291bGQgbm90IGZpbmQgZ2xvYiBwYXR0ZXJucyBmb3IgZXhwbG9yaW5nIHNwZWNzXCIpO1xuICB9XG5cbiAgbGV0IHNwZWNBYnNvbHV0ZVBhdGhzID0gYXdhaXQgZ2V0RmlsZXNCeUdsb2IocHJvamVjdFJvb3QsIHNwZWNQYXR0ZXJuLCB7XG4gICAgYWJzb2x1dGU6IHRydWUsXG4gICAgaWdub3JlOiBbLi4uZXhjbHVkZVNwZWNQYXR0ZXJuLCAuLi5hZGRpdGlvbmFsSWdub3JlUGF0dGVybl0sXG4gIH0pO1xuXG4gIC8vIElmIHRoZSBzcGVjUGF0dGVybiBhbmQgY29uZmlnU3BlY1BhdHRlcm4gYXJlIGRpZmZlcmVudCxcbiAgLy8gaXQgbWVhbnMgdGhlIHVzZXIgcGFzc2VkIHNvbWV0aGluZyBub24tZGVmYXVsdCB2aWEgLS1zcGVjIChydW4gbW9kZSBvbmx5KVxuICAvLyBpbiB0aGlzIHNjZW5hcmlvLCB3ZSB3YW50IHRvIGdyYWIgZXZlcnl0aGluZyB0aGF0IG1hdGNoZXMgYC0tc3BlY2BcbiAgLy8gdGhhdCBmYWxscyB3aXRoaW4gdGhlaXIgZGVmYXVsdCBzcGVjUGF0dGVybi4gVGhlIHJlYXNvbiBpcyBzbyB3ZSBhdm9pZFxuICAvLyBhdHRlbXB0aW5nIHRvIHJ1biB0aGluZ3MgdGhhdCBhcmUgbm90IHNwZWNzLCBlZyBzb3VyY2UgY29kZSwgdmlkZW9zLCBldGMuXG4gIC8vXG4gIC8vIEV4YW1wbGU6IGRldmVsb3BlciB3YW50cyB0byBydW4gdGVzdHMgYXNzb2NpYXRlZCB3aXRoIHRpbWVycyBpbiBwYWNrYWdlcy9kcml2ZXJcbiAgLy8gU28gdGhleSBydW4geWFybiBjeXByZXNzOnJ1biAtLXNwZWMgKiovdGltZXJzKlxuICAvLyB3ZSBkbyAqKm5vdCoqIHdhbnQgdG8gY2FwdHVyZSBgdGltZXJzLnRzYCAoc291cmNlIGNvZGUpIG9yIGEgdmlkZW8gaW5cbiAgLy8gY3lwcmVzcy92aWRlb3MvdGltZXJzLmN5LnRzLm1wNCwgc28gd2UgdGFrZSB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gc3BlY1BhdHRlcm5cbiAgLy8gYW5kIC0tc3BlYy5cbiAgaWYgKCFfLmlzRXF1YWwoc3BlY1BhdHRlcm4sIGNvbmZpZ1NwZWNQYXR0ZXJuKSkge1xuICAgIGNvbnN0IGRlZmF1bHRTcGVjQWJzb2x1dGVQYXRocyA9IGF3YWl0IGdldEZpbGVzQnlHbG9iKFxuICAgICAgcHJvamVjdFJvb3QsXG4gICAgICBjb25maWdTcGVjUGF0dGVybixcbiAgICAgIHtcbiAgICAgICAgYWJzb2x1dGU6IHRydWUsXG4gICAgICAgIGlnbm9yZTogWy4uLmV4Y2x1ZGVTcGVjUGF0dGVybiwgLi4uYWRkaXRpb25hbElnbm9yZVBhdHRlcm5dLFxuICAgICAgfVxuICAgICk7XG5cbiAgICBzcGVjQWJzb2x1dGVQYXRocyA9IF8uaW50ZXJzZWN0aW9uKFxuICAgICAgc3BlY0Fic29sdXRlUGF0aHMsXG4gICAgICBkZWZhdWx0U3BlY0Fic29sdXRlUGF0aHNcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZWRTcGVjcyh7XG4gICAgcHJvamVjdFJvb3QsXG4gICAgdGVzdGluZ1R5cGUsXG4gICAgc3BlY0Fic29sdXRlUGF0aHMsXG4gICAgc3BlY1BhdHRlcm4sXG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRGaWxlc0J5R2xvYihcbiAgcHJvamVjdFJvb3Q6IHN0cmluZyxcbiAgZ2xvYjogR2xvYlBhdHRlcm4sXG4gIGdsb2JPcHRpb25zOiBHbG9iYnlPcHRpb25zXG4pIHtcbiAgY29uc3Qgd29ya2luZ0RpcmVjdG9yeVByZWZpeCA9IHBhdGguam9pbihwcm9qZWN0Um9vdCwgcGF0aC5zZXApO1xuICBjb25zdCBnbG9icyA9IChbXSBhcyBzdHJpbmdbXSlcbiAgICAuY29uY2F0KGdsb2IpXG4gICAgLm1hcCgoZ2xvYlBhdHRlcm4pID0+XG4gICAgICBnbG9iUGF0dGVybi5zdGFydHNXaXRoKFwiLi9cIikgPyBnbG9iUGF0dGVybi5yZXBsYWNlKFwiLi9cIiwgXCJcIikgOiBnbG9iUGF0dGVyblxuICAgIClcbiAgICAubWFwKChnbG9iUGF0dGVybikgPT4ge1xuICAgICAgLy8gSWYgdGhlIHBhdHRlcm4gaW5jbHVkZXMgdGhlIHdvcmtpbmcgZGlyZWN0b3J5LCB3ZSBzdHJpcCBpdCBmcm9tIHRoZSBwYXR0ZXJuLlxuICAgICAgLy8gVGhlIHdvcmtpbmcgZGlyZWN0b3J5IHBhdGggbWF5IGluY2x1ZGUgY2hhcmFjdGVycyB0aGF0IGNvbmZsaWN0IHdpdGggZ2xvYlxuICAgICAgLy8gc3ludGF4IChicmFja2V0cywgcGFyZW50aGVzZXMsIGV0Yy4pIGFuZCBjYXVzZSBvdXIgc2VhcmNoZXMgdG8gaW5hZHZlcnRlbnRseSBmYWlsLlxuICAgICAgLy8gV2Ugc2NvcGUgb3VyIHNlYXJjaCB0byB0aGUgd29ya2luZyBkaXJlY3RvcnkgdXNpbmcgdGhlIGBjd2RgIGdsb2JieSBvcHRpb24uXG4gICAgICBpZiAoZ2xvYlBhdHRlcm4uc3RhcnRzV2l0aCh3b3JraW5nRGlyZWN0b3J5UHJlZml4KSkge1xuICAgICAgICByZXR1cm4gZ2xvYlBhdHRlcm4ucmVwbGFjZSh3b3JraW5nRGlyZWN0b3J5UHJlZml4LCBcIlwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdsb2JQYXR0ZXJuO1xuICAgIH0pO1xuXG4gIGlmIChvcy5wbGF0Zm9ybSgpID09PSBcIndpbjMyXCIpIHtcbiAgICAvLyBnbG9iYnkgY2FuJ3Qgd29yayB3aXRoIGJhY2t3YXJkcyBzbGFzaGVzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9nbG9iYnkvaXNzdWVzLzE3OVxuICAgIGRlYnVnKFwidXBkYXRpbmcgZ2xvYiBwYXR0ZXJucyB0byBQT1NJWFwiKTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gZ2xvYnMpIHtcbiAgICAgIGNvbnN0IGN1ciA9IGdsb2JzW2ldO1xuXG4gICAgICBpZiAoIWN1cikgdGhyb3cgbmV3IEVycm9yKFwidW5kZWZpbmVkIGdsb2IgcmVjZWl2ZWRcIik7XG5cbiAgICAgIGdsb2JzW2ldID0gdG9Qb3NpeChjdXIpO1xuICAgIH1cbiAgfVxuXG4gIHRyeSB7XG4gICAgZGVidWcoXCJnbG9iYmluZyBwYXR0ZXJuKHMpOiAlb1wiLCBnbG9icyk7XG4gICAgZGVidWcoXCJ3aXRoaW4gZGlyZWN0b3J5OiAlc1wiLCBwcm9qZWN0Um9vdCk7XG5cbiAgICByZXR1cm4gbWF0Y2hHbG9icyhnbG9icywge1xuICAgICAgb25seUZpbGVzOiB0cnVlLFxuICAgICAgYWJzb2x1dGU6IHRydWUsXG4gICAgICBjd2Q6IHByb2plY3RSb290LFxuICAgICAgLi4uZ2xvYk9wdGlvbnMsXG4gICAgICBpZ25vcmU6IChnbG9iT3B0aW9ucz8uaWdub3JlID8/IFtdKS5jb25jYXQoXCIqKi9ub2RlX21vZHVsZXMvKipcIiksXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZyhcImVycm9yIGluIGdldEZpbGVzQnlHbG9iICVvXCIsIGUpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG5jb25zdCBtYXRjaEdsb2JzID0gYXN5bmMgKGdsb2JzOiBHbG9iUGF0dGVybiwgZ2xvYmJ5T3B0aW9uczogR2xvYmJ5T3B0aW9ucykgPT4ge1xuICByZXR1cm4gYXdhaXQgZ2xvYmJ5KGdsb2JzLCBnbG9iYnlPcHRpb25zKTtcbn07XG5cbmludGVyZmFjZSBNYXRjaGVkU3BlY3Mge1xuICBwcm9qZWN0Um9vdDogc3RyaW5nO1xuICB0ZXN0aW5nVHlwZTogVGVzdGluZ1R5cGU7XG4gIHNwZWNBYnNvbHV0ZVBhdGhzOiBzdHJpbmdbXTtcbiAgc3BlY1BhdHRlcm46IHN0cmluZyB8IHN0cmluZ1tdO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVkU3BlY3Moe1xuICBwcm9qZWN0Um9vdCxcbiAgdGVzdGluZ1R5cGUsXG4gIHNwZWNBYnNvbHV0ZVBhdGhzLFxufTogTWF0Y2hlZFNwZWNzKSB7XG4gIGRlYnVnKFwiZm91bmQgc3BlY3MgJW9cIiwgc3BlY0Fic29sdXRlUGF0aHMpO1xuXG4gIGxldCBjb21tb25Sb290ID0gXCJcIjtcblxuICBpZiAoc3BlY0Fic29sdXRlUGF0aHMubGVuZ3RoID09PSAxKSB7XG4gICAgY29tbW9uUm9vdCA9IHBhdGguZGlybmFtZShzcGVjQWJzb2x1dGVQYXRoc1swXSk7XG4gIH0gZWxzZSB7XG4gICAgY29tbW9uUm9vdCA9IGNvbW1vblBhdGhQcmVmaXgoc3BlY0Fic29sdXRlUGF0aHMpO1xuICB9XG5cbiAgcmV0dXJuIHNwZWNBYnNvbHV0ZVBhdGhzLm1hcCgoYWJzb2x1dGUpID0+XG4gICAgdHJhbnNmb3JtU3BlYyh7XG4gICAgICBwcm9qZWN0Um9vdCxcbiAgICAgIGFic29sdXRlLFxuICAgICAgdGVzdGluZ1R5cGUsXG4gICAgICBjb21tb25Sb290LFxuICAgICAgcGxhdGZvcm06IG9zLnBsYXRmb3JtKCksXG4gICAgICBzZXA6IHBhdGguc2VwLFxuICAgIH0pXG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNmb3JtU3BlYyB7XG4gIHByb2plY3RSb290OiBzdHJpbmc7XG4gIGFic29sdXRlOiBzdHJpbmc7XG4gIHRlc3RpbmdUeXBlOiBUZXN0aW5nVHlwZTtcbiAgY29tbW9uUm9vdDogc3RyaW5nO1xuICBwbGF0Zm9ybTogTm9kZUpTLlBsYXRmb3JtO1xuICBzZXA6IHN0cmluZztcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU3BlYyh7XG4gIHByb2plY3RSb290LFxuICBhYnNvbHV0ZSxcbiAgdGVzdGluZ1R5cGUsXG4gIGNvbW1vblJvb3QsXG4gIHBsYXRmb3JtLFxuICBzZXAsXG59OiBUcmFuc2Zvcm1TcGVjKSB7XG4gIGlmIChwbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgYWJzb2x1dGUgPSB0b1Bvc2l4KGFic29sdXRlLCBzZXApO1xuICAgIHByb2plY3RSb290ID0gdG9Qb3NpeChwcm9qZWN0Um9vdCwgc2VwKTtcbiAgfVxuXG4gIGNvbnN0IHJlbGF0aXZlID0gcGF0aC5yZWxhdGl2ZShwcm9qZWN0Um9vdCwgYWJzb2x1dGUpO1xuICBjb25zdCBwYXJzZWRGaWxlID0gcGF0aC5wYXJzZShhYnNvbHV0ZSk7XG4gIGNvbnN0IGZpbGVFeHRlbnNpb24gPSBwYXRoLmV4dG5hbWUoYWJzb2x1dGUpO1xuXG4gIGNvbnN0IHNwZWNGaWxlRXh0ZW5zaW9uID1cbiAgICBbXCIuc3BlY1wiLCBcIi50ZXN0XCIsIFwiLXNwZWNcIiwgXCItdGVzdFwiLCBcIi5jeVwiXVxuICAgICAgLm1hcCgoZXh0KSA9PiBleHQgKyBmaWxlRXh0ZW5zaW9uKVxuICAgICAgLmZpbmQoKGV4dCkgPT4gYWJzb2x1dGUuZW5kc1dpdGgoZXh0KSkgfHwgZmlsZUV4dGVuc2lvbjtcblxuICBjb25zdCBwYXJ0cyA9IGFic29sdXRlLnNwbGl0KHByb2plY3RSb290KTtcbiAgbGV0IG5hbWUgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSB8fCBcIlwiO1xuXG4gIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgbmFtZSA9IG5hbWUuc2xpY2UoMSk7XG4gIH1cblxuICBjb25zdCBMRUFESU5HX1NMQVNIID0gL15cXC98L2c7XG4gIGNvbnN0IHJlbGF0aXZlVG9Db21tb25Sb290ID0gYWJzb2x1dGVcbiAgICAucmVwbGFjZShjb21tb25Sb290LCBcIlwiKVxuICAgIC5yZXBsYWNlKExFQURJTkdfU0xBU0gsIFwiXCIpO1xuXG4gIHJldHVybiB7XG4gICAgZmlsZUV4dGVuc2lvbixcbiAgICBiYXNlTmFtZTogcGFyc2VkRmlsZS5iYXNlLFxuICAgIGZpbGVOYW1lOiBwYXJzZWRGaWxlLmJhc2UucmVwbGFjZShzcGVjRmlsZUV4dGVuc2lvbiwgXCJcIiksXG4gICAgc3BlY0ZpbGVFeHRlbnNpb24sXG4gICAgcmVsYXRpdmVUb0NvbW1vblJvb3QsXG4gICAgc3BlY1R5cGU6ICh0ZXN0aW5nVHlwZSA9PT0gXCJjb21wb25lbnRcIlxuICAgICAgPyBcImNvbXBvbmVudFwiXG4gICAgICA6IFwiaW50ZWdyYXRpb25cIikgYXMgU3BlY1R5cGUsXG4gICAgbmFtZSxcbiAgICByZWxhdGl2ZSxcbiAgICBhYnNvbHV0ZSxcbiAgfTtcbn1cbiIsICJleHBvcnQgKiBmcm9tIFwiLi9jbGlcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3Byb2dyYW1cIjtcbiIsICJpbXBvcnQgeyBDdXJyZW50c1J1blBhcmFtZXRlcnMsIFRlc3RpbmdUeXBlIH0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7IHNhbml0aXplQW5kQ29udmVydE5lc3RlZEFyZ3MgfSBmcm9tIFwiLi9wYXJzZXJcIjtcbmltcG9ydCB7IHByb2dyYW0gfSBmcm9tIFwiLi9wcm9ncmFtXCI7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpjbGlcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNMSU9wdGlvbnMoXG4gIF9wcm9ncmFtOiB0eXBlb2YgcHJvZ3JhbSA9IHByb2dyYW0sXG4gIC4uLmFyZ3M6IFBhcmFtZXRlcnM8dHlwZW9mIHByb2dyYW0ucGFyc2U+XG4pIHtcbiAgX3Byb2dyYW0ucGFyc2UoLi4uYXJncyk7XG4gIGRlYnVnKFwicGFyc2VkIENMSSBmbGFncyAlb1wiLCBfcHJvZ3JhbS5vcHRzKCkpO1xuXG4gIGNvbnN0IHsgZTJlLCBjb21wb25lbnQgfSA9IF9wcm9ncmFtLm9wdHMoKTtcbiAgaWYgKGUyZSAmJiBjb21wb25lbnQpIHtcbiAgICBfcHJvZ3JhbS5lcnJvcihcIkNhbm5vdCB1c2UgYm90aCBlMmUgYW5kIGNvbXBvbmVudCBvcHRpb25zXCIpO1xuICB9XG5cbiAgcmV0dXJuIGdldFJ1blBhcmFtZXRlcnNGcm9tQ0xJKF9wcm9ncmFtLm9wdHMoKSk7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgQ0xJIG9wdGlvbnMgaW50byB0aGUgZm9ybWF0IHRoYXQgdGhlIGBydW5gIEFQSSBleHBlY3RzXG4gKlxuICogQHBhcmFtIGNsaU9wdGlvbnNcbiAqIEByZXR1cm5zIEN1cnJlbnRzIHJ1biBwYXJhbWV0ZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSdW5QYXJhbWV0ZXJzRnJvbUNMSShcbiAgY2xpT3B0aW9uczogUmV0dXJuVHlwZTx0eXBlb2YgcHJvZ3JhbS5vcHRzPlxuKTogQ3VycmVudHNSdW5QYXJhbWV0ZXJzIHtcbiAgY29uc3QgeyBjb21wb25lbnQsIGUyZSwgLi4ucmVzdE9wdGlvbnMgfSA9IGNsaU9wdGlvbnM7XG4gIGNvbnN0IHRlc3RpbmdUeXBlOiBUZXN0aW5nVHlwZSA9IGNvbXBvbmVudCA/IFwiY29tcG9uZW50XCIgOiBcImUyZVwiO1xuXG4gIGNvbnN0IHJlc3VsdDogUGFydGlhbDxDdXJyZW50c1J1blBhcmFtZXRlcnM+ID0ge1xuICAgIC4uLnJlc3RPcHRpb25zLFxuICAgIGNvbmZpZzogc2FuaXRpemVBbmRDb252ZXJ0TmVzdGVkQXJncyhjbGlPcHRpb25zLmNvbmZpZywgXCJjb25maWdcIiksXG4gICAgZW52OiBzYW5pdGl6ZUFuZENvbnZlcnROZXN0ZWRBcmdzKGNsaU9wdGlvbnMuZW52LCBcImVudlwiKSxcbiAgICByZXBvcnRlck9wdGlvbnM6IHNhbml0aXplQW5kQ29udmVydE5lc3RlZEFyZ3MoXG4gICAgICBjbGlPcHRpb25zLnJlcG9ydGVyT3B0aW9ucyxcbiAgICAgIFwicmVwb3J0ZXJPcHRpb25zXCJcbiAgICApLFxuICAgIHRlc3RpbmdUeXBlLFxuICAgIHJlY29yZEtleTogY2xpT3B0aW9ucy5rZXksXG4gIH07XG5cbiAgZGVidWcoXCJwYXJzZWQgcnVuIHBhcmFtczogJW9cIiwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsICJpbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgYXNzZXJ0IGZyb20gXCJub2RlOmFzc2VydFwiO1xuaW1wb3J0IHsgZXJyb3IgfSBmcm9tIFwiLi4vLi4vbGliL2xvZ1wiO1xuXG5jb25zdCBuZXN0ZWRPYmplY3RzSW5DdXJseUJyYWNlc1JlID0gL1xceyguKz8pXFx9L2c7XG5jb25zdCBuZXN0ZWRBcnJheXNJblNxdWFyZUJyYWNrZXRzUmUgPSAvXFxbKC4rPylcXF0vZztcbmNvbnN0IGV2ZXJ5dGhpbmdBZnRlckZpcnN0RXF1YWxSZSA9IC89KC4qKS87XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXByZXNzLWlvL2N5cHJlc3MvYmxvYi9hZmI2NmFiYzcwMjNjZTcxZTI4OTNjYjZkZTY3ZDI0NzA2ZmY3YTFmL3BhY2thZ2VzL3NlcnZlci9saWIvdXRpbC9hcmdzLmpzI0wxNjJcbmV4cG9ydCBjb25zdCBzYW5pdGl6ZUFuZENvbnZlcnROZXN0ZWRBcmdzID0gPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oXG4gIHN0cjogdW5rbm93bixcbiAgYXJnTmFtZTogdW5rbm93blxuKTogVCB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICghc3RyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFzc2VydChfLmlzU3RyaW5nKGFyZ05hbWUpICYmIGFyZ05hbWUudHJpbSgpICE9PSBcIlwiKTtcblxuICB0cnkge1xuICAgIGlmICh0eXBlb2Ygc3RyID09PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gc3RyIGFzIFQ7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhpcyBpcyB2YWxpZCBKU09OIHRoZW4ganVzdFxuICAgIC8vIHBhcnNlIGl0IGFuZCBjYWxsIGl0IGEgZGF5XG4gICAgY29uc3QgcGFyc2VkID0gdHJ5SlNPTlBhcnNlKHN0ciBhcyBzdHJpbmcpO1xuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG5cbiAgICAvLyBpbnZhbGlkIEpTT04sIHNvIGFzc3VtZSBtaXhlZCB1c2FnZVxuICAgIC8vIGZpcnN0IGZpbmQgZm9vPXthOmIsYjpjfSBhbmQgYmFyPVsxLDIsM11cbiAgICAvLyBzeW50YXggYW5kIHR1cm4gdGhvc2UgaW50b1xuICAgIC8vIGZvbzogYTpifGI6Y1xuICAgIC8vIGJhcjogMXwyfDNcblxuICAgIHJldHVybiBfLmNoYWluKHN0cilcbiAgICAgIC5yZXBsYWNlKG5lc3RlZE9iamVjdHNJbkN1cmx5QnJhY2VzUmUsIGNvbW1hc1RvUGlwZXMpXG4gICAgICAucmVwbGFjZShuZXN0ZWRBcnJheXNJblNxdWFyZUJyYWNrZXRzUmUsIGNvbW1hc1RvUGlwZXMpXG4gICAgICAuc3BsaXQoXCIsXCIpXG4gICAgICAubWFwKChwYWlyKSA9PiB7XG4gICAgICAgIHJldHVybiBwYWlyLnNwbGl0KGV2ZXJ5dGhpbmdBZnRlckZpcnN0RXF1YWxSZSk7XG4gICAgICB9KVxuICAgICAgLmZyb21QYWlycygpXG4gICAgICAubWFwVmFsdWVzKEpTT05PckNvZXJjZSlcbiAgICAgIC52YWx1ZSgpIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+IGFzIFQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9yKFwiY291bGQgbm90IHBhcnNlIENMSSBvcHRpb24gJyVzJyB2YWx1ZTogJXNcIiwgYXJnTmFtZSwgc3RyKTtcbiAgICBlcnJvcihcImVycm9yICVvXCIsIGVycik7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufTtcblxuY29uc3QgdHJ5SlNPTlBhcnNlID0gKHN0cjogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKSA9PT0gSW5maW5pdHkgPyBudWxsIDogSlNPTi5wYXJzZShzdHIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuY29uc3QgY29tbWFzVG9QaXBlcyA9IChtYXRjaDogc3RyaW5nKSA9PiB7XG4gIHJldHVybiBtYXRjaC5zcGxpdChcIixcIikuam9pbihcInxcIik7XG59O1xuXG4vLyBmb289YmFyLHZlcnNpb249MS4yLjNcbmNvbnN0IHBpcGVzVG9Db21tYXMgPSAoc3RyOiBzdHJpbmcpID0+IHtcbiAgcmV0dXJuIHN0ci5zcGxpdChcInxcIikuam9pbihcIixcIik7XG59O1xuXG5jb25zdCBKU09OT3JDb2VyY2UgPSAoc3RyOiBzdHJpbmcpID0+IHtcbiAgLy8gdmFsaWQgSlNPTj8gaG9ycmF5XG4gIGNvbnN0IHBhcnNlZCA9IHRyeUpTT05QYXJzZShzdHIpO1xuXG4gIGlmIChwYXJzZWQpIHtcbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLy8gY29udmVydCBiYXJzIGJhY2sgdG8gY29tbWFzXG4gIHN0ciA9IHBpcGVzVG9Db21tYXMoc3RyKTtcblxuICAvLyB0cnkgdG8gcGFyc2UgYWdhaW4/XG4gIGNvbnN0IHBhcnNlZDIgPSB0cnlKU09OUGFyc2Uoc3RyKTtcblxuICBpZiAocGFyc2VkMikge1xuICAgIHJldHVybiBwYXJzZWQyO1xuICB9XG5cbiAgLy8gbnVwZSA6LShcbiAgcmV0dXJuIGNvZXJjZShzdHIpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvZXJjZSA9ICh2YWx1ZTogYW55KSA9PiB7XG4gIGNvbnN0IG51bSA9IF8udG9OdW1iZXIodmFsdWUpO1xuXG4gIGlmIChfLmludm9rZShudW0sIFwidG9TdHJpbmdcIikgPT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIG51bTtcbiAgfVxuXG4gIGNvbnN0IGJvb2wgPSB0b0Jvb2xlYW4odmFsdWUpO1xuXG4gIGlmIChfLmludm9rZShib29sLCBcInRvU3RyaW5nXCIpID09PSB2YWx1ZSkge1xuICAgIHJldHVybiBib29sO1xuICB9XG5cbiAgY29uc3Qgb2JqID0gdHJ5SlNPTlBhcnNlKHZhbHVlKTtcblxuICBpZiAob2JqICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgY29uc3QgYXJyID0gXy50b0FycmF5KHZhbHVlKTtcblxuICBpZiAoXy5pbnZva2UoYXJyLCBcInRvU3RyaW5nXCIpID09PSB2YWx1ZSkge1xuICAgIHJldHVybiBhcnI7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5jb25zdCB0b0Jvb2xlYW4gPSAodmFsdWU6IHN0cmluZykgPT4ge1xuICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgY2FzZSBcInRydWVcIjpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgXCJmYWxzZVwiOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07XG4iLCAiLy8gaHR0cHM6Ly9naXRodWIuY29tL2N1cnJlbnRzLWRldi9jeXByZXNzLWNsb3VkL2lzc3Vlcy83MVxuLy8ga2VlcCB0aGUgbG9jYWwgY29weSB0byBwcmV2ZW50IGZyb20gaW1wb3J0aW5nXG4vLyBjb21tYW5kZXIuanMgZnJvbSB0aGUgZ2xvYmFsIG5vZGVfbW9kdWxlc1xuaW1wb3J0IHsgQ29tbWFuZCwgT3B0aW9uIH0gZnJvbSBcIi4vQGNvbW1hbmRlci1qcy9leHRyYS10eXBpbmdzXCI7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQcm9ncmFtID0gKGNvbW1hbmQ6IENvbW1hbmQgPSBuZXcgQ29tbWFuZCgpKSA9PlxuICBjb21tYW5kXG4gICAgLm5hbWUoXCJjeXByZXNzLWNsb3VkXCIpXG4gICAgLmRlc2NyaXB0aW9uKFxuICAgICAgXCJSdW5zIEN5cHJlc3MgdGVzdHMgb24gQ0kgdXNpbmcgQ3VycmVudHMgYXMgYW4gb3JjaGVzdHJhdGlvbiBhbmQgcmVwb3J0aW5nIHNlcnZpY2VcIlxuICAgIClcbiAgICAub3B0aW9uKFxuICAgICAgXCItYiwgLS1icm93c2VyIDxicm93c2VyLW5hbWUtb3ItcGF0aD5cIixcbiAgICAgIFwicnVucyBDeXByZXNzIGluIHRoZSBicm93c2VyIHdpdGggdGhlIGdpdmVuIG5hbWU7IGlmIGEgZmlsZXN5c3RlbSBwYXRoIGlzIHN1cHBsaWVkLCBDeXByZXNzIHdpbGwgYXR0ZW1wdCB0byB1c2UgdGhlIGJyb3dzZXIgYXQgdGhhdCBwYXRoXCJcbiAgICApXG4gICAgLm9wdGlvbihcbiAgICAgIFwiLS1jaS1idWlsZC1pZCA8aWQ+XCIsXG4gICAgICBcInRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgYSBydW4sIHRoaXMgdmFsdWUgaXMgYXV0b21hdGljYWxseSBkZXRlY3RlZCBmb3IgbW9zdCBDSSBwcm92aWRlcnNcIlxuICAgIClcbiAgICAuYWRkT3B0aW9uKFxuICAgICAgbmV3IE9wdGlvbihcIi0tY29tcG9uZW50XCIsIFwicnVucyBDeXByZXNzIGNvbXBvbmVudCB0ZXN0XCIpXG4gICAgICAgIC5kZWZhdWx0KGZhbHNlKVxuICAgICAgICAuaW1wbGllcyh7XG4gICAgICAgICAgZTJlOiBmYWxzZSxcbiAgICAgICAgfSlcbiAgICApXG4gICAgLm9wdGlvbihcbiAgICAgIFwiLWMsIC0tY29uZmlnIDxjb25maWc+XCIsXG4gICAgICBcInNldHMgQ3lwcmVzcyBjb25maWd1cmF0aW9uIHZhbHVlcy4gc2VwYXJhdGUgbXVsdGlwbGUgdmFsdWVzIHdpdGggYSBjb21tYS4gb3ZlcnJpZGVzIGFueSB2YWx1ZSBpbiBjeXByZXNzLmNvbmZpZy57anMsdHMsbWpzLGNqc31cIlxuICAgIClcbiAgICAub3B0aW9uKFxuICAgICAgXCItZSwgLS1lbnYgPGVudj5cIixcbiAgICAgIFwic2V0cyBlbnZpcm9ubWVudCB2YXJpYWJsZXMuIHNlcGFyYXRlIG11bHRpcGxlIHZhbHVlcyB3aXRoIGEgY29tbWEuIG92ZXJyaWRlcyBhbnkgdmFsdWUgaW4gY3lwcmVzcy5jb25maWcue2pzLHRzLG1qcyxjanN9IG9yIGN5cHJlc3MuZW52Lmpzb25cIlxuICAgIClcbiAgICAub3B0aW9uKFxuICAgICAgXCItQywgLS1jb25maWctZmlsZSA8Y29uZmlnLWZpbGU+XCIsXG4gICAgICAnc3BlY2lmeSBDeXByZXNzIGNvbmZpZyBmaWxlLCBwYXRoIHRvIHNjcmlwdCBmaWxlIHdoZXJlIEN5cHJlc3MgY29uZmlndXJhdGlvbiB2YWx1ZXMgYXJlIHNldC4gZGVmYXVsdHMgdG8gXCJjeXByZXNzLmNvbmZpZy57anMsdHMsbWpzLGNqc31cIidcbiAgICApXG4gICAgLmFkZE9wdGlvbihuZXcgT3B0aW9uKFwiLS1lMmVcIiwgXCJydW5zIGVuZCB0byBlbmQgdGVzdHNcIikuZGVmYXVsdCh0cnVlKSlcbiAgICAub3B0aW9uKFwiLS1ncm91cCA8bmFtZT5cIiwgXCJhIG5hbWVkIGdyb3VwIGZvciByZWNvcmRlZCBydW5zIGluIEN1cnJlbnRzXCIpXG4gICAgLmFkZE9wdGlvbihcbiAgICAgIG5ldyBPcHRpb24oXG4gICAgICAgIFwiLWssIC0ta2V5IDxyZWNvcmQta2V5PlwiLFxuICAgICAgICBcInlvdXIgc2VjcmV0IFJlY29yZCBLZXkgb2J0YWluZWQgZnJvbSBDdXJyZW50cy4geW91IGNhbiBvbWl0IHRoaXMgaWYgeW91IHNldCBhIENVUlJFTlRTX1JFQ09SRF9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGVcIlxuICAgICAgKS5lbnYoXCJDVVJSRU5UU19SRUNPUkRfS0VZXCIpXG4gICAgKVxuICAgIC5vcHRpb24oXG4gICAgICBcIi0tcGFyYWxsZWxcIixcbiAgICAgIFwiZW5hYmxlcyBjb25jdXJyZW50IHJ1bnMgYW5kIGF1dG9tYXRpYyBsb2FkIGJhbGFuY2luZyBvZiBzcGVjcyBhY3Jvc3MgbXVsdGlwbGUgbWFjaGluZXMgb3IgcHJvY2Vzc2VzXCIsXG4gICAgICBmYWxzZVxuICAgIClcbiAgICAuYWRkT3B0aW9uKFxuICAgICAgbmV3IE9wdGlvbihcbiAgICAgICAgXCItcCwgLS1wb3J0IDxudW1iZXI+XCIsXG4gICAgICAgIFwicnVucyBDeXByZXNzIG9uIGEgc3BlY2lmaWMgcG9ydC4gb3ZlcnJpZGVzIGFueSB2YWx1ZSBpbiBjeXByZXNzLmNvbmZpZy57anMsdHMsbWpzLGNqc31cIlxuICAgICAgKS5hcmdQYXJzZXIoKGkpID0+IHBhcnNlSW50KGksIDEwKSlcbiAgICApXG4gICAgLm9wdGlvbihcbiAgICAgIFwiLVAsIC0tcHJvamVjdCA8cHJvamVjdC1wYXRoPlwiLFxuICAgICAgXCJwYXRoIHRvIHlvdXIgQ3lwcmVzcyBwcm9qZWN0IHJvb3QgbG9jYXRpb24gLSBkZWZhdWx0cyB0byB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeVwiXG4gICAgKVxuICAgIC5vcHRpb24oXCItcSwgLS1xdWlldFwiLCBcInN1cHByZXNzIHZlcmJvc2Ugb3V0cHV0IGZyb20gQ3lwcmVzc1wiKVxuICAgIC5hZGRPcHRpb24oXG4gICAgICBuZXcgT3B0aW9uKFxuICAgICAgICBcIi0tcmVjb3JkIFtib29sXVwiLFxuICAgICAgICBcInJlY29yZHMgdGhlIHJ1biBhbmQgc2VuZHMgdGVzdCByZXN1bHRzLCBzY3JlZW5zaG90cyBhbmQgdmlkZW9zIHRvIEN1cnJlbnRzXCJcbiAgICAgIClcbiAgICAgICAgLmRlZmF1bHQodHJ1ZSlcbiAgICAgICAgLmFyZ1BhcnNlcigoaSkgPT4gKGkgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDogdHJ1ZSkpXG4gICAgKVxuICAgIC5vcHRpb24oXG4gICAgICBcIi1yLCAtLXJlcG9ydGVyIDxyZXBvcnRlcj5cIixcbiAgICAgICd1c2UgYSBzcGVjaWZpYyBtb2NoYSByZXBvcnRlciBmb3IgQ3lwcmVzcywgcGFzcyBhIHBhdGggdG8gdXNlIGEgY3VzdG9tIHJlcG9ydGVyLCBkZWZhdWx0cyB0byBcInNwZWNcIidcbiAgICApXG4gICAgLm9wdGlvbihcbiAgICAgIFwiLW8sIC0tcmVwb3J0ZXItb3B0aW9ucyA8cmVwb3J0ZXItb3B0aW9ucz5cIixcbiAgICAgICdvcHRpb25zIGZvciB0aGUgbW9jaGEgcmVwb3J0ZXIuIGRlZmF1bHRzIHRvIFwibnVsbFwiJ1xuICAgIClcbiAgICAuYWRkT3B0aW9uKFxuICAgICAgbmV3IE9wdGlvbihcbiAgICAgICAgXCItcywgLS1zcGVjIDxzcGVjLXBhdHRlcm4+XCIsXG4gICAgICAgICdkZWZpbmUgc3BlY2lmaWMgZ2xvYiBwYXR0ZXJuIGZvciBydW5uaW5nIHRoZSBzcGVjIGZpbGUocyksIERlZmF1bHRzIHRvIHRoZSBcInNwZWNNYXRjaFwiIGVudHJ5IGZyb20gdGhlIFwiY3lwcmVzcy5jb25maWcue2pzLHRzLG1qcyxjanN9XCIgZmlsZSdcbiAgICAgICkuYXJnUGFyc2VyKHBhcnNlQ29tbWFTZXBhcmF0ZWRMaXN0KVxuICAgIClcbiAgICAub3B0aW9uKFxuICAgICAgXCItdCwgLS10YWcgPHRhZz5cIixcbiAgICAgIFwiY29tbWEtc2VwYXJhdGVkIHRhZyhzKSBmb3IgcmVjb3JkZWQgcnVucyBpbiBDdXJyZW50c1wiLFxuICAgICAgcGFyc2VDb21tYVNlcGFyYXRlZExpc3RcbiAgICApXG4gICAgLmFkZE9wdGlvbihcbiAgICAgIG5ldyBPcHRpb24oXG4gICAgICAgIFwiLS1hdXRvLWNhbmNlbC1hZnRlci1mYWlsdXJlcyA8bnVtYmVyIHwgZmFsc2U+XCIsXG4gICAgICAgIFwiQXV0b21hdGljYWxseSBhYm9ydCB0aGUgcnVuIGFmdGVyIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGZhaWxlZCB0ZXN0cy4gT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IHByb2plY3Qgc2V0dGluZ3MuIElmIHNldCwgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgJ2ZhbHNlJyB0byBkaXNhYmxlIChDdXJyZW50cy1vbmx5KVwiXG4gICAgICApLmFyZ1BhcnNlcihwYXJzZUF1dG9DYW5jZWxGYWlsdXJlcylcbiAgICApO1xuXG5leHBvcnQgY29uc3QgcHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oKTtcblxuZnVuY3Rpb24gcGFyc2VDb21tYVNlcGFyYXRlZExpc3QodmFsdWU6IHN0cmluZywgcHJldmlvdXM6IHN0cmluZ1tdID0gW10pIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgcmV0dXJuIHByZXZpb3VzLmNvbmNhdCh2YWx1ZS5zcGxpdChcIixcIikubWFwKCh0KSA9PiB0LnRyaW0oKSkpO1xuICB9XG4gIHJldHVybiBwcmV2aW91cztcbn1cblxuZnVuY3Rpb24gcGFyc2VBdXRvQ2FuY2VsRmFpbHVyZXModmFsdWU6IHN0cmluZyk6IG51bWJlciB8IGZhbHNlIHtcbiAgaWYgKHZhbHVlID09PSBcImZhbHNlXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG5cbiAgaWYgKGlzTmFOKHBhcnNlZFZhbHVlKSB8fCBwYXJzZWRWYWx1ZSA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludmFsaWQgYXJndW1lbnQgcHJvdmlkZWQuIE11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yICdmYWxzZScuXCJcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlZFZhbHVlO1xufVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxTQUFTLHFCQUFxQjtBQUM5QixPQUFPLFVBQVU7QUFGakI7QUFBQTtBQUFBO0FBQUE7OztBQ0FBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFBTSxZQUFZLFVBQVEsV0FBVztBQUlyQyxjQUFVLE9BQU8sVUFBVSxDQUFDO0FBSTVCLFlBQVEsVUFBVSxJQUFJLFVBQVUsUUFBUTtBQU14QyxZQUFRLFdBQVcsVUFBVTtBQUM3QixZQUFRLFVBQVUsVUFBVTtBQUM1QixZQUFRLGlCQUFpQixVQUFVO0FBQ25DLFlBQVEsT0FBTyxVQUFVO0FBQ3pCLFlBQVEsdUJBQXVCLFVBQVU7QUFDekMsWUFBUSw2QkFBNkIsVUFBVTtBQUMvQyxZQUFRLFNBQVMsVUFBVTtBQUszQixZQUFRLGdCQUFnQixDQUFDLFNBQVMsSUFBSSxVQUFVLFFBQVEsSUFBSTtBQUM1RCxZQUFRLGVBQWUsQ0FBQyxPQUFPLGdCQUM3QixJQUFJLFVBQVUsT0FBTyxPQUFPLFdBQVc7QUFDekMsWUFBUSxpQkFBaUIsQ0FBQyxNQUFNLGdCQUM5QixJQUFJLFVBQVUsU0FBUyxNQUFNLFdBQVc7QUFBQTtBQUFBOzs7QUM3QjFDO0FBQ0EsT0FBTzs7O0FDRFA7QUFBTyxJQUFNLGtCQUFOLGNBQThCLE1BQU07QUFBQSxFQUN6QyxZQUFZLFNBQWlCO0FBQzNCLFVBQU0sT0FBTztBQUNiLFNBQUssT0FBTztBQUFBLEVBQ2Q7QUFDRjs7O0FDTEE7QUFBQSxPQUFPLFdBQVc7QUFDbEIsT0FBTyxVQUFVO0FBRWpCLElBQU0sTUFBTSxJQUFJLFNBQW9CLFFBQVEsSUFBSSxLQUFLLE9BQU8sR0FBRyxJQUFJLENBQUM7QUFFN0QsSUFBTSxPQUFPO0FBRWIsSUFBTSxZQUFZLENBQUMsUUFDeEIsTUFBTSxNQUFNLE1BQU0sU0FBUyxJQUFJLE1BQU07QUFDaEMsSUFBTSxjQUFjLENBQUMsUUFDMUIsTUFBTSxTQUFTLE1BQU0sV0FBVyxJQUFJLE1BQU07QUFFckMsSUFBTSxPQUFPLElBQUksU0FDdEIsSUFBSSxZQUFZLEtBQUssT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDO0FBS2hDLElBQU0sUUFBUSxJQUFJLFNBQ3ZCLElBQUksVUFBVSxLQUFLLE9BQU8sR0FBRyxJQUFJLENBQUMsSUFBSSxJQUFJO0FBR3JDLElBQU0sUUFBUSxDQUFDLFVBQWlCLFNBQ3JDLEtBQUssU0FBYyxNQUFNLEtBQUssRUFBRSxLQUFLLEtBQUssT0FBTyxHQUFHLElBQUksQ0FBQyxJQUFJLE1BQVc7QUFFbkUsSUFBTSxVQUFVLE1BQ3JCLFFBQVEsSUFBSSxPQUFPLE1BQU0sS0FBSyxNQUFNLEdBQUcsRUFBRSxLQUFLLEdBQUcsRUFBRSxLQUFLLEVBQUUsQ0FBQyxJQUFJLElBQUk7QUFFOUQsSUFBTSxTQUFTLENBQUMsSUFBWSxNQUNqQyxRQUFRLElBQUksTUFBTSxDQUFDLEVBQUUsS0FBSyxFQUFFLEVBQUUsS0FBSyxJQUFJLENBQUM7QUFFbkMsSUFBTSxPQUFPLE1BQU07QUFDbkIsSUFBTSxPQUFPLE1BQU07QUFDbkIsSUFBTSxNQUFNLE1BQU07QUFDbEIsSUFBTSxRQUFRLE1BQU07QUFDcEIsSUFBTSxPQUFPLE1BQU07QUFDbkIsSUFBTSxRQUFRLE1BQU07QUFDcEIsSUFBTSxVQUFVLE1BQU07QUFDdEIsSUFBTSxPQUFPLE1BQU07OztBQ3RDMUI7OztBQ0FBOzs7QUNBQTtBQUFBLFNBQVMscUJBQXFCO0FBRXZCLElBQU1BLFdBQVUsY0FBYyxZQUFZLEdBQUc7OztBQ0ZwRDtBQUFBLE9BQU8sUUFBUTtBQUNmLElBQU0sVUFBVSxHQUFHO0FBR25CLEdBQUcsUUFBUSxTQUFVLFNBQVMsTUFBTSxTQUFTO0FBRTNDLE1BQUksUUFBUSxNQUFNLFNBQVMsR0FBRztBQUU1QixVQUFNQyxXQUFVLFFBQVEsU0FBUyxNQUFNO0FBQUEsTUFDckMsR0FBRztBQUFBO0FBQUEsTUFFSCxPQUFPLENBQUMsUUFBUSxRQUFRLE1BQU07QUFBQSxJQUNoQyxDQUFDO0FBQ0QsV0FBT0E7QUFBQSxFQUNUO0FBR0EsU0FBTyxRQUFRLFNBQVMsTUFBTSxPQUFPO0FBQ3ZDOzs7QUNsQkE7OztBQ0FBO0FBQUEsT0FBTyxXQUFXO0FBQ2xCLElBQU0sUUFBUSxNQUFNLGtCQUFrQjtBQUV0QyxJQUFNLFNBQVMsUUFBUSxPQUFPO0FBQzlCLElBQU0sT0FBTyxRQUFRO0FBRWQsSUFBTSxVQUFVLFdBQVk7QUFFakMsVUFBUSxPQUFPLFFBQVE7QUFDdkIsVUFBUSxNQUFNO0FBQ2hCO0FBSUEsSUFBTSxTQUFTLFdBQVk7QUFDekIsUUFBTSxrQkFBa0I7QUFDeEIsTUFBSSxPQUFpQixDQUFDO0FBR3RCLFFBQU0sRUFBRSxNQUFNLElBQUksUUFBUTtBQUMxQixRQUFNLEVBQUUsS0FBQUMsS0FBSSxJQUFJO0FBS2hCLE1BQUlBLE1BQUs7QUFDUCxZQUFRLE1BQU0sU0FBVSxLQUFhO0FBQ25DLFdBQUssS0FBSyxHQUFHO0FBSWIsYUFBT0EsS0FBSSxNQUFNLE1BQU0sU0FBUztBQUFBLElBQ2xDO0FBQUEsRUFDRjtBQUVBLFVBQVEsT0FBTyxRQUFRLFNBQVUsS0FBYTtBQUM1QyxTQUFLLEtBQUssR0FBRztBQUliLFdBQU8sTUFBTSxNQUFNLE1BQU0sU0FBUztBQUFBLEVBQ3BDO0FBRUEsU0FBTztBQUFBLElBQ0wsV0FBVztBQUNULGFBQU8sS0FBSyxLQUFLLEVBQUU7QUFBQSxJQUNyQjtBQUFBLElBQ0EsTUFBTTtBQUFBLElBQ047QUFBQSxJQUNBLE9BQU8sTUFBTTtBQUNYLFlBQU0sMkJBQTJCO0FBQ2pDLGFBQU8sQ0FBQztBQUFBLElBQ1Y7QUFBQSxFQUNGO0FBQ0Y7QUFFQSxJQUFJLGdCQUF3QjtBQUM1QixJQUFJLGlCQUFtRDtBQUVoRCxJQUFNLGNBQWMsTUFBTyxpQkFBaUIsT0FBTztBQUVuRCxJQUFNLG1CQUFtQixNQUFNO0FBQ3BDLE1BQUksQ0FBQztBQUFnQixVQUFNLElBQUksTUFBTSx3QkFBd0I7QUFDN0Qsa0JBQWdCLGVBQWUsU0FBUztBQUN4QyxpQkFBZSxNQUFNO0FBQ3ZCO0FBQ08sSUFBTSxlQUFlLE1BQU07QUFDaEMsTUFBSSxDQUFDO0FBQWdCLFVBQU0sSUFBSSxNQUFNLHdCQUF3QjtBQUM3RCxpQkFBZSxNQUFNO0FBQ3ZCO0FBRU8sSUFBTSxvQkFBb0IsTUFBTTtBQUNyQyxNQUFJLENBQUM7QUFBZ0IsVUFBTSxJQUFJLE1BQU0sd0JBQXdCO0FBQzdELFNBQU8sZUFBZSxTQUFTO0FBQ2pDO0FBQ08sSUFBTSxtQkFBbUIsTUFBTTs7O0FDM0V0Qzs7O0FDQUE7QUFBQSxTQUFxQixvQkFBb0I7QUFFbEMsSUFBTSxtQkFBbUIsQ0FBQyxRQUE2QjtBQUM1RCxNQUFJLENBQUMsYUFBYSxHQUFHLEdBQUc7QUFDdEIsV0FBTztBQUFBLEVBQ1Q7QUFDQSxNQUFJLElBQUksU0FBUyxnQkFBZ0I7QUFDL0IsV0FBTztBQUFBLEVBQ1Q7QUFDQSxTQUFPLENBQUMsRUFDTixLQUFLLFVBQVUsVUFDZixPQUFPLElBQUksU0FBUyxVQUNwQixJQUFJLFNBQVMsU0FBUztBQUUxQjtBQUVPLElBQU0sV0FBVyxDQUFDLE1BQWMsQ0FBQyxLQUFLLEtBQU0sS0FBSyxLQUFNLEtBQUssR0FBSSxFQUFFLElBQUksQ0FBQztBQUU5RSxJQUFJLFVBQVU7QUFDUCxJQUFNLGdCQUFnQixNQUFNLFdBQVc7QUFDdkMsSUFBTSxnQkFBZ0IsQ0FBQyxRQUMzQixVQUFVLE9BQU87OztBQ3JCcEI7QUFBQSxPQUFPLFdBTUE7QUFDUCxPQUFPLGdCQUFnQjtBQUN2QixPQUFPQyxZQUFXO0FBQ2xCLE9BQU9DLFFBQU87QUFDZCxPQUFPLHdCQUF3Qjs7O0FDVi9CO0FBQ0EsT0FBTyxPQUFPO0FBR1AsU0FBUyxpQkFDZCxLQUNBO0FBQ0EsTUFBSSxDQUFDLElBQUksVUFBVSxRQUFRLENBQUMsSUFBSSxVQUFVLFFBQVE7QUFDaEQ7QUFBQSxFQUNGO0FBRUEsUUFBTSxFQUFFLFNBQVMsT0FBTyxJQUFJLElBQUksU0FBUztBQUV6QyxVQUFRLElBQUksU0FBUyxRQUFRO0FBQUEsSUFDM0IsS0FBSztBQUNILFdBQUssMkJBQTJCO0FBQ2hDO0FBQUEsSUFDRixLQUFLO0FBQ0gsYUFBTyxDQUFDO0FBQ1IsV0FBSyxHQUFHLG1CQUFtQixTQUFTLE1BQU0sQ0FBQztBQUMzQyxhQUFPLENBQUM7QUFDUjtBQUFBLElBQ0Y7QUFDRTtBQUFBLEVBQ0o7QUFDRjtBQUVPLFNBQVMsbUJBQ2QsU0FDQSxRQUNVO0FBQ1YsTUFBSSxDQUFDLEVBQUUsU0FBUyxPQUFPLEdBQUc7QUFDeEIsV0FBTyxDQUFDLHlDQUF5QztBQUFBLEVBQ25EO0FBRUEsTUFBSSxRQUFRLFdBQVcsR0FBRztBQUN4QixXQUFPLENBQUMsT0FBaUI7QUFBQSxFQUMzQjtBQUNBLFNBQU87QUFBQSxJQUNMO0FBQUEsSUFDQTtBQUFBLEdBQ0QsVUFBVSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sT0FBTyxHQUFHLEVBQUUsS0FBSyxJQUFJO0FBQUE7QUFBQSxFQUUvQztBQUNGOzs7QUQ1QkEsSUFBTUMsU0FBUUMsT0FBTSxjQUFjO0FBRWxDLElBQU0sY0FBYztBQUVwQixJQUFJLFVBQWdDO0FBRTdCLFNBQVMsWUFBWTtBQUMxQixNQUFJLFNBQVM7QUFDWCxXQUFPO0FBQUEsRUFDVDtBQUNBLFlBQVUsTUFBTSxPQUFPO0FBQUEsSUFDckIsU0FBUyxjQUFjO0FBQUEsRUFDekIsQ0FBQztBQUVELFVBQVEsYUFBYSxRQUFRLElBQUksQ0FBQyxXQUFXO0FBQzNDLFVBQU0sVUFBa0M7QUFBQSxNQUN0QyxHQUFHLE9BQU87QUFBQTtBQUFBLE1BRVYsNkJBQTZCLE9BQU8sYUFBYSxHQUFHLGNBQWM7QUFBQSxNQUNsRSxxQkFBcUIsbUJBQW1CO0FBQUEsTUFDeEMsaUJBQWlCLG9CQUFvQjtBQUFBLElBQ3ZDO0FBQ0EsUUFBSSxRQUFRO0FBQ1YsY0FBUSxrQkFBa0IsSUFBSTtBQUFBLElBQ2hDO0FBQ0EsUUFBSSxDQUFDLFFBQVEsY0FBYyxHQUFHO0FBQzVCLGNBQVEsY0FBYyxJQUFJO0FBQUEsSUFDNUI7QUFDQSxVQUFNLE1BQU07QUFBQSxNQUNWLEdBQUc7QUFBQSxNQUNIO0FBQUEsSUFDRjtBQUVBLElBQUFELE9BQU0sdUJBQXVCO0FBQUEsTUFDM0IsR0FBR0UsR0FBRSxLQUFLLEtBQUssVUFBVSxPQUFPLFNBQVM7QUFBQSxNQUN6QyxNQUFNLE9BQU8sU0FBUyxJQUFJLElBQUksSUFBSSxXQUFXLElBQUk7QUFBQSxJQUNuRCxDQUFDO0FBQ0QsV0FBTztBQUFBLEVBQ1QsQ0FBQztBQUVELGFBQVcsU0FBUztBQUFBLElBQ2xCLFNBQVM7QUFBQSxJQUNULGdCQUFnQjtBQUFBLElBQ2hCLFlBQVk7QUFBQTtBQUFBLElBRVo7QUFBQSxFQUNGLENBQUM7QUFDRCxTQUFPO0FBQ1Q7QUFFQSxJQUFJLFNBQTZCO0FBQzFCLElBQU0sV0FBVyxDQUFDLFVBQWtCO0FBQ3pDLFdBQVM7QUFDWDtBQUVBLElBQUksa0JBQXNDO0FBQ25DLElBQU0sb0JBQW9CLENBQUMsbUJBQTJCO0FBQzNELG9CQUFrQjtBQUNwQjtBQUVBLElBQUksbUJBQXVDO0FBQ3BDLElBQU0scUJBQXFCLENBQUMsTUFBYztBQUMvQyxxQkFBbUI7QUFDckI7QUFFQSxTQUFTLFFBQ1AsWUFDQSxLQUNBQyxVQUNBO0FBQ0E7QUFBQSxJQUNFO0FBQUEsSUFDQSxJQUFJO0FBQUEsSUFDSixtQkFBbUIsU0FBUyxVQUFVLENBQUM7QUFBQSxJQUN2QztBQUFBLElBQ0E7QUFBQSxFQUNGO0FBQ0Y7QUFFTyxJQUFNLGNBQWMsQ0FDekIsV0FDRztBQUNILFNBQU8sVUFBVSxFQUF1QixNQUFNLEVBQzNDLEtBQUssQ0FBQyxRQUFRO0FBQ2IsSUFBQUgsT0FBTSx3QkFBd0JFLEdBQUUsS0FBSyxLQUFLLFdBQVcsUUFBUSxDQUFDO0FBQzlELFdBQU87QUFBQSxFQUNULENBQUMsRUFDQSxNQUFNLENBQUNFLFdBQVU7QUFDaEIscUJBQWlCQSxNQUFLO0FBQ3RCLFVBQU0sSUFBSSxnQkFBZ0JBLE9BQU0sT0FBTztBQUFBLEVBQ3pDLENBQUM7QUFDTDs7O0FQdkdBLElBQU0sYUFBYUMsU0FBUSxzQkFBc0I7QUFDakQsSUFBTSxNQUFNQSxTQUFRLDRCQUE0QjtBQUtoRCxZQUFZO0FBQ1osa0JBQWtCLFdBQVcsT0FBTztBQUNwQyxtQkFBbUIsSUFBSSxPQUFPOzs7QURWOUIsT0FBT0MsYUFBVzs7O0FVRmxCOzs7QUNBQTs7O0FDQUE7QUFBQSxPQUFPQyxRQUFPO0FBTVAsU0FBUyxjQUFjLFVBQTBCO0FBQ3RELE9BQUssNEJBQTRCO0FBQ2pDLFdBQVMsSUFBSSxDQUFDLE1BQU07QUFDbEIsV0FBTyxDQUFDO0FBQ1IsU0FBSyxRQUFRLEtBQUssRUFBRSxPQUFPLENBQUM7QUFDNUIsV0FBTyxRQUFRQyxHQUFFLEtBQUssR0FBRyxTQUFTLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxLQUFLLEtBQUssTUFBTTtBQUN6RCxXQUFLLFlBQVksS0FBSyxLQUFLO0FBQUEsSUFDN0IsQ0FBQztBQUNELFdBQU8sQ0FBQztBQUFBLEVBQ1YsQ0FBQztBQUNIOzs7QURETyxJQUFNLFlBQVksT0FBTyxZQUE4QjtBQUM1RCxRQUFNLFdBQVcsTUFBTSxZQUFpRDtBQUFBLElBQ3RFLFFBQVE7QUFBQSxJQUNSLEtBQUs7QUFBQSxJQUNMLE1BQU07QUFBQSxFQUNSLENBQUM7QUFFRCxPQUFLLFNBQVMsS0FBSyxVQUFVLFVBQVUsS0FBSyxHQUFHO0FBQzdDLGtCQUFjLFNBQVMsS0FBSyxRQUFRO0FBQUEsRUFDdEM7QUFFQSxTQUFPLFNBQVM7QUFDbEI7QUFFTyxJQUFNLGlCQUFpQixPQUFPO0FBQUEsRUFDbkM7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0EsVUFBQUM7QUFDRixNQUE2QjtBQUMzQixRQUFNLFdBQVcsTUFBTSxZQUdyQjtBQUFBLElBQ0EsUUFBUTtBQUFBLElBQ1IsS0FBSyxRQUFRO0FBQUEsSUFDYixNQUFNO0FBQUEsTUFDSjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQSxVQUFBQTtBQUFBLElBQ0Y7QUFBQSxFQUNGLENBQUM7QUFFRCxTQUFPLFNBQVM7QUFDbEI7QUFFTyxJQUFNLHlCQUF5QixPQUFPLFNBQWtDO0FBQzdFLFFBQU0sVUFBVSxNQUFNLFlBR3BCO0FBQUEsSUFDQSxRQUFRO0FBQUEsSUFDUixLQUFLLFFBQVEsS0FBSztBQUFBLElBQ2xCO0FBQUEsRUFDRixDQUFDO0FBRUQsU0FBTyxRQUFRO0FBQ2pCO0FBRU8sSUFBTSxtQkFBbUIsQ0FDOUIsWUFDQSxZQUVBLFlBQXlDO0FBQUEsRUFDdkMsUUFBUTtBQUFBLEVBQ1IsS0FBSyxhQUFhO0FBQUEsRUFDbEIsTUFBTTtBQUNSLENBQUMsRUFBRSxLQUFLLENBQUMsV0FBVyxPQUFPLElBQUk7QUFFMUIsSUFBTSx3QkFBd0IsQ0FDbkMsWUFDQSxZQUVBLFlBQXlFO0FBQUEsRUFDdkUsUUFBUTtBQUFBLEVBQ1IsS0FBSyxhQUFhO0FBQUEsRUFDbEIsTUFBTTtBQUNSLENBQUMsRUFBRSxLQUFLLENBQUMsV0FBVyxPQUFPLElBQUk7QUFFMUIsSUFBTSw4QkFBOEIsQ0FDekMsWUFDQSxZQUVBLFlBR0U7QUFBQSxFQUNBLFFBQVE7QUFBQSxFQUNSLEtBQUssYUFBYTtBQUFBLEVBQ2xCLE1BQU07QUFDUixDQUFDLEVBQUUsS0FBSyxDQUFDLFdBQVcsT0FBTyxJQUFJO0FBRTFCLElBQU0sdUJBQXVCLENBQUMsWUFBb0JDLFlBQ3ZELFlBQXFDO0FBQUEsRUFDbkMsUUFBUTtBQUFBLEVBQ1IsS0FBSyxhQUFhO0FBQUEsRUFDbEIsTUFBTTtBQUFBLElBQ0osUUFBQUE7QUFBQSxFQUNGO0FBQ0YsQ0FBQzs7O0FFekdIOzs7QUNBQTs7O0FDQUE7OztBQ0FBOzs7QUNBQTtBQUFBLE9BQU8sYUFBYTtBQUVwQixPQUFPQyxRQUFPO0FBR2QsSUFBTUMsU0FBUSxRQUFRLGFBQWE7QUFFbkMsSUFBTSxPQUFPLENBQUMsU0FBaUIsV0FBbUM7QUFDaEUsU0FBT0MsR0FBRSxNQUFNLE1BQU0sRUFBRSxRQUFRLEVBQUUsS0FBSyxJQUFJLEVBQUUsTUFBTTtBQUNwRDtBQUVBLElBQU0sZ0JBQWdCLENBQUMsS0FBVSxRQUFnQjtBQUMvQyxTQUFPQSxHQUFFLElBQUksS0FBS0EsR0FBRSxVQUFVLEdBQUcsR0FBRyxRQUFRLElBQUksR0FBRyxDQUFDO0FBQ3REO0FBRUEsSUFBTSxVQUFVLENBQUMsWUFBc0I7QUFDckMsU0FBT0EsR0FBRSxVQUFVLFNBQVMsZUFBZSxDQUFDLENBQUM7QUFDL0M7QUFNQSxJQUFNLG1CQUFtQixNQUFNO0FBQzdCLFNBQU8sUUFBUSxJQUFJLFlBQVksUUFBUSxJQUFJO0FBQzdDO0FBT0EsSUFBTSxZQUFZLE1BQU07QUFDdEIsU0FBTyxRQUFRLElBQUksWUFBWSxRQUFRLElBQUk7QUFDN0M7QUFFQSxJQUFNLGlCQUFpQixNQUFNO0FBQzNCLFNBQU9BLEdBQUUsS0FBSyxRQUFRLEtBQUssQ0FBQyxLQUFLLFFBQVE7QUFDdkMsV0FBTyxjQUFjLEtBQUssR0FBRztBQUFBLEVBQy9CLENBQUM7QUFDSDtBQUVBLElBQU0sV0FBVyxNQUFNO0FBQ3JCLFNBQU8sUUFBUSxJQUFJO0FBQ3JCO0FBRUEsSUFBTSxrQkFBa0IsTUFBTTtBQUM1QixTQUNFLFFBQVEsSUFBSSxXQUNaLFFBQVEsSUFBSSxZQUFZLGNBQ3hCLFFBQVEsSUFBSTtBQUVoQjtBQUVBLElBQU0sZ0JBQWdCLE1BQU07QUFDMUIsU0FDRSxRQUFRLElBQUksV0FDWixRQUFRLElBQUksWUFBWSxjQUN4QixDQUFDLFFBQVEsSUFBSTtBQUVqQjtBQUVBLElBQU0sY0FBYyxNQUFNO0FBQ3hCLFNBQU9BLEdBQUUsS0FBSyxRQUFRLEtBQUssQ0FBQyxLQUFLLFFBQVE7QUFDdkMsV0FBTyxjQUFjLEtBQUssR0FBRztBQUFBLEVBQy9CLENBQUM7QUFDSDtBQUVBLElBQU0sV0FBVyxNQUFNO0FBQ3JCLFNBQ0UsUUFBUSxJQUFJLGFBQ1gsUUFBUSxJQUFJLGtCQUFrQixVQUFVLEtBQUssUUFBUSxJQUFJLGNBQWM7QUFFNUU7QUFFQSxJQUFNLGdCQUFnQixNQUFNO0FBSTFCLFNBQ0UsUUFBUSxJQUFJLGVBQ1osUUFBUSxJQUFJLGtCQUNaLFFBQVEsSUFBSTtBQUVoQjtBQUVBLElBQU0sWUFBWSxNQUFNO0FBQ3RCLFNBQ0UsUUFBUSxJQUFJLGVBQ1osUUFBUSxJQUFJLGdCQUNaLFFBQVEsSUFBSSxtQkFDWixRQUFRLElBQUksY0FDWixRQUFRLElBQUk7QUFFaEI7QUFFQSxJQUFNLFlBQVksTUFBTTtBQUN0QixTQUFPLFFBQVEsSUFBSSxXQUFXLFFBQVEsSUFBSTtBQUM1QztBQVVBLElBQU0sZUFBZTtBQUFBLEVBQ25CLFVBQVU7QUFBQSxFQUNWLE9BQU87QUFBQSxFQUNQLGNBQWM7QUFBQSxFQUNkLFFBQVE7QUFBQSxFQUNSLFdBQVc7QUFBQSxFQUNYLFdBQVc7QUFBQSxFQUNYLFFBQVE7QUFBQSxFQUNSLGVBQWU7QUFBQSxFQUNmLGFBQWE7QUFBQSxFQUNiLFdBQVc7QUFBQSxFQUNYLFdBQVc7QUFBQSxFQUNYLE9BQU87QUFBQSxFQUNQLGVBQWU7QUFBQSxFQUNmLFFBQVE7QUFBQSxFQUNSLE1BQU07QUFBQSxFQUNOLGFBQWE7QUFBQSxFQUNiLFNBQVM7QUFBQSxFQUNULFdBQVc7QUFBQSxFQUNYLFdBQVc7QUFBQSxFQUNYLFVBQVU7QUFBQSxFQUNWLGdCQUFnQjtBQUFBLEVBQ2hCLFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULFNBQVM7QUFBQSxFQUNULFNBQVM7QUFDWDtBQUVBLFNBQVMsc0JBQTBDO0FBQ2pELFFBQU0sRUFBRSxJQUFJLElBQUk7QUFJaEIsU0FBT0EsR0FBRSxRQUFRLGNBQWMsQ0FBQyxVQUFVO0FBQ3hDLFFBQUlBLEdBQUUsU0FBUyxLQUFLLEdBQUc7QUFDckIsYUFBTyxJQUFJLEtBQUs7QUFBQSxJQUNsQjtBQUVBLFFBQUlBLEdBQUUsV0FBVyxLQUFLLEdBQUc7QUFDdkIsYUFBTyxNQUFNO0FBQUEsSUFDZjtBQUFBLEVBQ0YsQ0FBQztBQUNIO0FBSUEsSUFBTSxvQkFBb0IsTUFBMkI7QUFDbkQsU0FBTztBQUFBLElBQ0wsVUFBVSxRQUFRO0FBQUEsTUFDaEI7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGLENBQUM7QUFBQSxJQUNELE9BQU8sUUFBUTtBQUFBLE1BQ2I7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGLENBQUM7QUFBQSxJQUNELGNBQWMsUUFBUTtBQUFBLE1BQ3BCO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0YsQ0FBQztBQUFBLElBQ0QsUUFBUSxRQUFRO0FBQUEsTUFDZDtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0YsQ0FBQztBQUFBLElBQ0QsV0FBVyxRQUFRO0FBQUEsTUFDakI7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUVBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGLENBQUM7QUFBQSxJQUNELFdBQVcsUUFBUTtBQUFBLE1BQ2pCO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGLENBQUM7QUFBQSxJQUNELFFBQVEsUUFBUTtBQUFBLE1BQ2Q7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRixDQUFDO0FBQUEsSUFDRCxlQUFlLFFBQVE7QUFBQSxNQUNyQjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRixDQUFDO0FBQUE7QUFBQTtBQUFBLElBR0QsYUFBYSxRQUFRLENBQUMsZUFBZSxnQkFBZ0IsZUFBZSxDQUFDO0FBQUE7QUFBQSxJQUVyRSxXQUFXLFFBQVE7QUFBQSxNQUNqQjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRixDQUFDO0FBQUE7QUFBQSxJQUVELFdBQVcsUUFBUTtBQUFBLE1BQ2pCO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BRUE7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGLENBQUM7QUFBQSxJQUNELE9BQU8sUUFBUTtBQUFBLE1BQ2I7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGLENBQUM7QUFBQTtBQUFBLElBRUQsZUFBZSxRQUFRO0FBQUEsTUFDckI7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0YsQ0FBQztBQUFBO0FBQUEsSUFFRCxRQUFRLFFBQVE7QUFBQTtBQUFBLE1BRWQ7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUVBO0FBQUE7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BRUE7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBO0FBQUEsSUFFRixDQUFDO0FBQUE7QUFBQSxJQUVELE1BQU0sUUFBUTtBQUFBLE1BQ1o7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGLENBQUM7QUFBQSxJQUNELGFBQWEsUUFBUTtBQUFBO0FBQUEsTUFFbkI7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUVBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBO0FBQUEsSUFFRixDQUFDO0FBQUEsSUFDRCxTQUFTLFFBQVEsQ0FBQyxZQUFZLGFBQWEsZ0JBQWdCLGFBQWEsQ0FBQztBQUFBO0FBQUE7QUFBQSxJQUd6RSxXQUFXLFFBQVE7QUFBQSxNQUNqQjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLElBQ0YsQ0FBQztBQUFBO0FBQUEsSUFFRCxXQUFXLFFBQVE7QUFBQTtBQUFBLE1BRWpCO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQTtBQUFBLE1BRUE7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBO0FBQUEsTUFFQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsSUFDRixDQUFDO0FBQUEsSUFDRCxVQUFVO0FBQUEsSUFDVixnQkFBZ0IsUUFBUTtBQUFBLE1BQ3RCO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGLENBQUM7QUFBQSxJQUNELFFBQVEsUUFBUTtBQUFBLE1BQ2Q7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRixDQUFDO0FBQUEsSUFDRCxTQUFTO0FBQUE7QUFBQSxJQUVULFNBQVMsUUFBUTtBQUFBLE1BQ2Y7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFB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S0FBSyxDQUFDO0FBQUEsRUFDaEI7QUFDQSxNQUFJLE9BQU8sV0FBVyxVQUFVO0FBQzlCLFlBQVEsS0FBSyxDQUFDO0FBQUEsRUFDaEI7QUFFQSxRQUFNLGdCQUFnQixPQUFPLGNBQWMsT0FBTztBQUNsRCxNQUFJLGdCQUFnQixHQUFHO0FBQ3JCLFlBQVEsS0FBSyxhQUFhO0FBQUEsRUFDNUI7QUFDQSxVQUFRLEtBQUssQ0FBQztBQUNoQixDQUFDLEVBQ0EsTUFBTSxDQUFDLFFBQVE7QUFDZCxNQUFJLGVBQWUsaUJBQWlCO0FBQ2xDLFlBQVEsTUFBTSxVQUFVLElBQUksU0FBUyxDQUFDLENBQUM7QUFBQSxFQUN6QyxPQUFPO0FBQ0wsWUFBUSxNQUFNLEdBQUc7QUFBQSxFQUNuQjtBQUNBLFVBQVEsS0FBSyxDQUFDO0FBQ2hCLENBQUM7IiwKICAibmFtZXMiOiBbInJlcXVpcmUiLCAicHJvY2VzcyIsICJsb2ciLCAiRGVidWciLCAiXyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJfIiwgIl9jb25maWciLCAiZXJyb3IiLCAicmVxdWlyZSIsICJEZWJ1ZyIsICJfIiwgIl8iLCAicGxhdGZvcm0iLCAic3Rkb3V0IiwgIl8iLCAiZGVidWciLCAiXyIsICJfIiwgImRlYnVnIiwgIkRlYnVnIiwgInBhdGgiLCAiRGVidWciLCAicGF0aCIsICJEZWJ1ZyIsICJfIiwgImRlYnVnIiwgIkRlYnVnIiwgIl8iLCAiZGVidWciLCAiRGVidWciLCAicmVxdWlyZSIsICJzdGRvdXQiLCAicGF0aCIsICJmaWxlIiwgImRlYnVnIiwgIkRlYnVnIiwgInBhdGgiLCAicmVxdWlyZSIsICJEZWJ1ZyIsICJfIiwgImRlYnVnIiwgIkRlYnVnIiwgIl8iLCAiRGVidWciLCAiXyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJfIiwgImVycm9yIiwgIkRlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgIkRlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgIl8iLCAiZGVidWciLCAiZXJyb3IiLCAicnVuIiwgIl8iLCAiXyIsICJyIiwgIkRlYnVnIiwgIkRlYnVnIiwgIkRlYnVnIiwgImZzIiwgImZzIiwgImRlYnVnIiwgIkRlYnVnIiwgImZpbGUiLCAiZGVidWciLCAiRGVidWciLCAiZGVidWciLCAiRGVidWciLCAicnVuIiwgInN0ZG91dCIsICJEZWJ1ZyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJwbGF0Zm9ybSIsICJlcnJvciIsICJEZWJ1ZyIsICJwYXRoIiwgIl8iLCAiZGVidWciLCAiRGVidWciLCAiXyIsICJwYXRoIiwgInBsYXRmb3JtIiwgImRlYnVnIiwgIkRlYnVnIiwgInBsYXRmb3JtIiwgInJ1biIsICJEZWJ1ZyIsICJfIiwgIl8iLCAiZGVidWciLCAiRGVidWciXQp9Cg==